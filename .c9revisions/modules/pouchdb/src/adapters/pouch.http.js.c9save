{"ts":1353418605477,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var HTTP_TIMEOUT = 10000;\n\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nfunction parseUri (str) {\n  var o = parseUri.options;\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) uri[o.key[i]] = m[i] || \"\";\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2;\n  });\n\n  return uri;\n};\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name) {\n  // If the given name contains \"http:\"\n  if (/http(s?):/.test(name)) {\n    // Prase the URI into all its little bits\n    var uri = parseUri(name);\n\n    // Store the fact that it is a remote URI\n    uri.remote = true;\n\n    // Store the user and password as a separate auth object\n    if (uri.user || uri.password) {\n      uri.auth = {username: uri.user, password: uri.password};\n    }\n\n    // Split the path part of the URI into parts using '/' as the delimiter\n    // after removing any leading '/' and any trailing '/'\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n    // Store the first part as the database name and remove it from the parts\n    // array\n    uri.db = parts.pop();\n\n    // Restore the path by joining all the remaining parts (all the parts\n    // except for the database name) with '/'s\n    uri.path = parts.join('/');\n\n    return uri;\n  }\n\n  // If the given name does not contain 'http:' then return a very basic object\n  // with no host, the current path, the given name as the database name and no\n  // username/password\n  return {host: '', path: '/', db: name, auth: false};\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host is remote\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // Return the URL made up of all the host's information and the given path\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + opts.path\n      + pathDel + opts.db + '/' + path;\n  }\n\n  // If the host is not remote, then return the URL made up of just the\n  // database name and the given path\n  return '/' + opts.db + '/' + path;\n};\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nvar HttpPouch = function(opts, callback) {\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var host = getHost(opts.name);\n\n  // Generate the database URL based on the host\n  var db_url = genUrl(host, '');\n\n  // The functions that will be publically available for HttpPouch\n  var api = {};\n\n  // Create a new CouchDB database based on the given opts\n  var createDB = function(){\n    ajax({auth: host.auth, type: 'PUT', url: db_url}, function(err, ret) {\n      // If we get an \"Unauthorized\" error\n      if (err && err.status === 401) {\n        // Test if the database already exists\n        ajax({auth: host.auth, type: 'HEAD', url: db_url}, function (err, ret) {\n          // If there is still an error\n          if (err) {\n            // Give the error to the callback to deal with\n            call(callback, err);\n          } else {\n            // Continue as if there had been no errors\n            call(callback, null, api);\n          }\n        });\n      // If there were no errros or if the only error is \"Precondition Failed\"\n      // (note: \"Precondition Failed\" occurs when we try to create a database\n      // that already exists)\n      } else if (!err || err.status === 412) {\n        // Continue as if there had been no errors\n        call(callback, null, api);\n      } else {\n      call(callback, Pouch.Errors.UNKNOWN_ERROR);\n    }\n  });\n};\n  ajax({auth: host.auth, type: 'GET', url: db_url}, function(err, ret) {\n    //check if the db exists\n    if (err) {\n      if (err.status === 404) {\n        //if it doesn't, create it\n        createDB();  \n      } else {\n        call(callback, err);\n      }\n    } else {\n      //go do stuff with the db\n      call(callback, null, api);\n      }\n  });\n  // The HttpPouch's ID is its URL\n  api.id = function() {\n    return genUrl(host, '');\n  };\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api.info = function(callback) {\n    ajax({\n      auth: host.auth,\n      type:'GET',\n      url: genUrl(host, ''),\n    }, callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = function(id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // If it exists, add the opts.revs value to the list of parameters.\n    // If revs=true then the resulting JSON will include a field\n    // _revisions containing an array of the revision IDs.\n    if (opts.revs) {\n      params.push('revs=true');\n    }\n\n    // If it exists, add the opts.revs_info value to the list of parameters.\n    // If revs_info=true then the resulting JSON will include the field\n    // _revs_info containing an array of objects in which each object\n    // representing an available revision.\n    if (opts.revs_info) {\n      params.push('revs_info=true');\n    }\n\n    // If it exists, add the opts.attachments value to the list of parameters.\n    // If attachments=true the resulting JSON will include the base64-encoded\n    // contents in the \"data\" property of each attachment.\n    if (opts.attachments) {\n      params.push('attachments=true');\n    }\n\n    // If it exists, add the opts.rev value to the list of parameters.\n    // If rev is given a revision number then get the specified revision.\n    if (opts.rev) {\n      params.push('rev=' + opts.rev);\n    }\n\n    // If it exists, add the opts.conflicts value to the list of parameters.\n    // If conflicts=true then the resulting JSON will include the field\n    // _conflicts containing all the conflicting revisions.\n    if (opts.conflicts) {\n      params.push('conflicts=' + opts.conflicts);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // Set the options for the ajax call\n    var options = {\n      auth: host.auth,\n      type: 'GET',\n      url: genUrl(host, id + params)\n    };\n\n    // If the given id contains at least one '/' and the part before the '/'\n    // is NOT \"_design\" and is NOT \"_local\"\n    // OR\n    // If the given id contains at least two '/' and the part before the first\n    // '/' is \"_design\".\n    // TODO This second condition seems strange since if parts[0] === '_design'\n    // then we already know that parts[0] !== '_local'.\n    var parts = id.split('/');\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\n      // Nothing is expected back from the server\n      options.dataType = false;\n    }\n\n    // Get the document\n    ajax(options, function(err, doc, xhr) {\n      // If the document does not exist, send an error to the callback\n      if (err) {\n        return call(callback, Pouch.Errors.MISSING_DOC);\n      }\n\n      // Send the document to the callback\n      call(callback, null, doc, xhr);\n    });\n  };\n\n  // Get the view given by fun of the database given by host.\n  // fun is formatted in two parts separated by a '/'; the first\n  // part is the design and the second is the view.\n  api.query = function(fun, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the PUT request\n    var params = [];\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    if (typeof opts.reduce !== 'undefined') {\n      params.push('reduce=' + opts.reduce);\n    }\n    if (typeof opts.include_docs !== 'undefined') {\n      params.push('include_docs=' + opts.include_docs);\n    }\n    if (typeof opts.limit !== 'undefined') {\n      params.push('limit=' + opts.limit);\n    }\n    if (typeof opts.descending !== 'undefined') {\n      params.push('descending=' + opts.descending);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = fun.split('/');\n      ajax({\n        auth: host.auth,\n        type:'GET',\n        url: genUrl(host, '_design/' + parts[0] + '/_view/' + parts[1] + params),\n      }, callback);\n      return;\n    }\n\n    // We are using a temporary view, terrible for performance but good for testing\n    var queryObject = JSON.stringify(fun, function(key, val) {\n      if (typeof val === 'function') {\n        return val + ''; // implicitly `toString` it\n      }\n      return val;\n    });\n\n    ajax({\n      auth: host.auth,\n      type:'POST',\n      url: genUrl(host, '_temp_view' + params),\n      data: queryObject\n    }, callback);\n  };\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Delete the document\n    ajax({\n      auth: host.auth,\n      type:'DELETE',\n      url: genUrl(host, doc._id) + '?rev=' + doc._rev\n    }, callback);\n  };\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    ajax({\n      auth: host.auth,\n      type: 'DELETE',\n      url: genUrl(host, id) + '?rev=' + rev,\n    }, callback);\n  };\n\n  // Add the attachment given by doc and the content type given by type\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = function(id, rev, doc, type, callback) {\n    // Add the attachment\n    ajax({\n      auth: host.auth,\n      type:'PUT',\n      url: genUrl(host, id) + '?rev=' + rev,\n      headers: {'Content-Type': type},\n      data: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This assumes that doc has a _id field.\n  api.put = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameter to add to the PUT request\n    var params = [];\n\n    // If it exists, add the opts.new_edits value to the list of parameters.\n    // If new_edits = false then the database will NOT assign this document a\n    // new revision number\n    if (opts && typeof opts.new_edits !== 'undefined') {\n      params.push('new_edits=' + opts.new_edits);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Add the document\n    ajax({\n      auth: host.auth,\n      type: 'PUT',\n      url: genUrl(host, doc._id) + params,\n      data: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This assumes that doc is a new document (i.e. does not\n  // have a _id or a _rev field.\n  api.post = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Add the document\n    ajax({\n      auth: host.auth,\n      type: 'POST',\n      url: genUrl(host, ''),\n      data: doc\n    }, callback);\n  };\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api.bulkDocs = function(req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {}\n    }\n\n    // If opts.new_edits exists add it to the document data to be\n    // send to the database.\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    if (typeof opts.new_edits !== 'undefined') {\n      req.new_edits = opts.new_edits;\n    }\n\n    // Update/create the documents\n    ajax({\n      auth: host.auth,\n      type:'POST',\n      url: genUrl(host, '_bulk_docs'),\n      data: req\n    }, callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = function(opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // TODO I don't see conflicts as a valid parameter for a\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.include_docs exists, add the include_docs value to the\n    // list of parameters.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs) {\n      params.push('include_docs=true');\n    }\n\n    // If opts.startkey exists, add the startkey value to the list of\n    // parameters.\n    // If startkey is given then the returned list of documents will\n    // start with the document whose id is startkey.\n    if (opts.startkey) {\n      params.push('startkey=' +\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n\n    // If opts.endkey exists, add the endkey value to the list of parameters.\n    // If endkey is given then the returned list of docuemnts will\n    // end with the document whose id is endkey.\n    if (opts.endkey) {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Get the document listing\n    ajax({\n      auth: host.auth,\n      type:'GET',\n      url: genUrl(host, '_all_docs' + params)\n    }, callback);\n  };\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api.changes = function(opts, callback) {\n    // If no options were given, set the callback to the first parameter\n    if (typeof opts === 'function') {\n      opts = {complete: opts};\n    }\n\n    // If a callback was provided outside of opts, then it is the one that\n    // will be called upon completion\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    console.info(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    // Query string of all the parameters to add to the GET request\n    var params = '?style=all_docs'\n\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\n    // function, add the include_docs value to the query string.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params += '&include_docs=true'\n    }\n\n    // If opts.continuous exists, add the feed value to the query string.\n    // If feed=longpoll then it waits for either a timeout or a change to\n    // occur before returning.\n    if (opts.continuous) {\n      params += '&feed=longpoll';\n    }\n\n    // If opts.conflicts exists, add the conflicts value to the query string.\n    // TODO I can't find documentation of what conflicts=true does. See\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\n    if (opts.conflicts) {\n      params += '&conflicts=true';\n    }\n\n    // If opts.descending exists, add the descending value to the query string.\n    // if descending=true then the change results are returned in\n    // descending order (most recent change first).\n    if (opts.descending) {\n      params += '&descending=true';\n    }\n\n    // If opts.filter exists and is a string then add the filter value\n    // to the query string.\n    // If filter is given a string containing the name of a filter in\n    // the design, then only documents passing through the filter will\n    // be returned.\n    if (opts.filter && typeof opts.filter === 'string') {\n      params += '&filter=' + opts.filter;\n    }\n\n    var xhr;\n    var last_seq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function(since, callback) {\n      // Set the options for the ajax call\n      var xhrOpts = {\n        auth: host.auth, type:'GET',\n        url: genUrl(host, '_changes' + params + '&since=' + since)\n      };\n      last_seq = since;\n\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      xhr = ajax(xhrOpts, function(err, res) {\n        callback(res);\n      });\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var fetched = function(res) {\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        // For each change\n        res.results.forEach(function(c) {\n          var hasFilter = opts.filter && typeof opts.filter === 'function';\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc])) {\n            return;\n          }\n\n          // Process the change\n          call(opts.onChange, c);\n        });\n      }\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        last_seq = res.last_seq;\n      }\n\n      if (opts.continuous) {\n        // Call fetch again with the newest sequence number\n        fetch(last_seq, fetched);\n      } else {\n        // We're done, call the callback\n        call(opts.complete, null, res);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function() {\n        console.info(db_url + ': Cancel Changes Feed');\n        opts.aborted = true;\n        xhr.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = function(req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax({\n      auth: host.auth,\n      type:'POST',\n      url: genUrl(host, '_revs_diff'),\n      data: req\n    }, function(err, res) {\n      call(callback, null, res);\n    });\n  };\n\n  api.replicate = {};\n\n  // Replicate from the database given by url to this HttpPouch\n  api.replicate.from = function(url, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, api, opts, callback);\n  };\n\n  // Replicate to the database given by dbName from this HttpPouch\n  api.replicate.to = function(dbName, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(api, dbName, opts, callback);\n  };\n\n\n  return api;\n};\n\n// Delete the HttpPouch specified by the given name.\nHttpPouch.destroy = function(name, callback) {\n  var host = getHost(name);\n  ajax({auth: host.auth, type: 'DELETE', url: genUrl(host, '')}, callback);\n};\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function() {\n  return true;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  // running in node\n  var pouchdir = '../';\n  this.Pouch = require(pouchdir + 'pouch.js')\n  this.ajax = Pouch.utils.ajax;\n}\n\n// Set HttpPouch to be the adapter used with the http scheme.\nPouch.adapter('http', HttpPouch);\nPouch.adapter('https', HttpPouch);\n"]],"start1":0,"start2":0,"length1":0,"length2":21849}]],"length":21849}
