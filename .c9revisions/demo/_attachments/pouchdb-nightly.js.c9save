{"ts":1365010651714,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*PouchDB*/\n(function() {\n // BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n(function() {\n  // Private array of chars to use\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\n  Math.uuid = function (len, radix) {\n    var chars = CHARS, uuid = [];\n    radix = radix || chars.length;\n\n    if (len) {\n      // Compact form\n      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\n    } else {\n      // rfc4122, version 4 form\n      var r;\n\n      // rfc4122 requires these characters\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n      uuid[14] = '4';\n\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\n      // per rfc4122, sec. 4.1.5\n      for (var i = 0; i < 36; i++) {\n        if (!uuid[i]) {\n          r = 0 | Math.random()*16;\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join('');\n  };\n\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\n  // by minimizing calls to random()\n  Math.uuidFast = function() {\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\n    for (var i = 0; i < 36; i++) {\n      if (i==8 || i==13 ||  i==18 || i==23) {\n        uuid[i] = '-';\n      } else if (i==14) {\n        uuid[i] = '4';\n      } else {\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n        r = rnd & 0xf;\n        rnd = rnd >> 4;\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n      }\n    }\n    return uuid.join('');\n  };\n\n  // A more compact, but less performant, RFC4122v4 solution:\n  Math.uuidCompact = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    }).toUpperCase();\n  };\n})();\n\n// END Math.uuid.js\n\n/**\n*\n*  MD5 (Message-Digest Algorithm)\n*\n*  For original source see http://www.webtoolkit.info/\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\n*\n*  Licensed under CC-BY 2.0 License\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\n*\n**/\n\nvar Crypto = {};\n(function() {\n  Crypto.MD5 = function(string) {\n\n    function RotateLeft(lValue, iShiftBits) {\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n    }\n\n    function AddUnsigned(lX,lY) {\n      var lX4,lY4,lX8,lY8,lResult;\n      lX8 = (lX & 0x80000000);\n      lY8 = (lY & 0x80000000);\n      lX4 = (lX & 0x40000000);\n      lY4 = (lY & 0x40000000);\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n      if (lX4 & lY4) {\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n      }\n      if (lX4 | lY4) {\n        if (lResult & 0x40000000) {\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        } else {\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n        }\n      } else {\n        return (lResult ^ lX8 ^ lY8);\n      }\n    }\n\n    function F(x,y,z) { return (x & y) | ((~x) & z); }\n    function G(x,y,z) { return (x & z) | (y & (~z)); }\n    function H(x,y,z) { return (x ^ y ^ z); }\n    function I(x,y,z) { return (y ^ (x | (~z))); }\n\n    function FF(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function GG(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function HH(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function II(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function ConvertToWordArray(string) {\n      var lWordCount;\n      var lMessageLength = string.length;\n      var lNumberOfWords_temp1=lMessageLength + 8;\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n      var lWordArray=Array(lNumberOfWords-1);\n      var lBytePosition = 0;\n      var lByteCount = 0;\n      while ( lByteCount < lMessageLength ) {\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\n        lBytePosition = (lByteCount % 4)*8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n        lByteCount++;\n      }\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n      return lWordArray;\n    };\n\n    function WordToHex(lValue) {\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n      for (lCount = 0;lCount<=3;lCount++) {\n        lByte = (lValue>>>(lCount*8)) & 255;\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n      }\n      return WordToHexValue;\n    };\n\n    //**\tfunction Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\n\n    var x=Array();\n    var k,AA,BB,CC,DD,a,b,c,d;\n    var S11=7, S12=12, S13=17, S14=22;\n    var S21=5, S22=9 , S23=14, S24=20;\n    var S31=4, S32=11, S33=16, S34=23;\n    var S41=6, S42=10, S43=15, S44=21;\n\n    //\tstring = Utf8Encode(string); #function call removed\n\n    x = ConvertToWordArray(string);\n\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n    for (k=0;k<x.length;k+=16) {\n      AA=a; BB=b; CC=c; DD=d;\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n      a=AddUnsigned(a,AA);\n      b=AddUnsigned(b,BB);\n      c=AddUnsigned(c,CC);\n      d=AddUnsigned(d,DD);\n    }\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n    return temp.toLowerCase();\n  }\n})();\n\n// END Crypto.md5.js\n\n//----------------------------------------------------------------------\n//\n// ECMAScript 5 Polyfills\n//  from www.calocomrmen./polyfill/\n//\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n// ES5 15.2 Object Objects\n//----------------------------------------------------------------------\n\n\n\n// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )\n// Partial support for most common case - getters, setters, and values\n(function() {\n  if (!Object.defineProperty ||\n      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {\n    var orig = Object.defineProperty;\n    Object.defineProperty = function (o, prop, desc) {\n      \"use strict\";\n\n      // In IE8 try built-in implementation for defining properties on DOM prototypes.\n      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }\n\n      if (o !== Object(o)) { throw new TypeError(\"Object.defineProperty called on non-object\"); }\n      if (Object.prototype.__defineGetter__ && ('get' in desc)) {\n        Object.prototype.__defineGetter__.call(o, prop, desc.get);\n      }\n      if (Object.prototype.__defineSetter__ && ('set' in desc)) {\n        Object.prototype.__defineSetter__.call(o, prop, desc.set);\n      }\n      if ('value' in desc) {\n        o[prop] = desc.value;\n      }\n      return o;\n    };\n  }\n}());\n\n\n\n// ES5 15.2.3.14 Object.keys ( O )\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\nif (!Object.keys) {\n  Object.keys = function (o) {\n    if (o !== Object(o)) { throw new TypeError('Object.keys called on non-object'); }\n    var ret = [], p;\n    for (p in o) {\n      if (Object.prototype.hasOwnProperty.call(o, p)) {\n        ret.push(p);\n      }\n    }\n    return ret;\n  };\n}\n\n//----------------------------------------------------------------------\n// ES5 15.4 Array Objects\n//----------------------------------------------------------------------\n\n\n\n// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        fun.call(thisp, t[i], i, t);\n      }\n    }\n  };\n}\n\n\n// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\nif (!Array.prototype.map) {\n  Array.prototype.map = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var res = []; res.length = len;\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        res[i] = fun.call(thisp, t[i], i, t);\n      }\n    }\n\n    return res;\n  };\n}\n\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[ \"[object \" + typename + \"]\" ] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nvar type = function(obj) {\n  if (obj === null) {\n    return String( obj );\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n};\n\nvar isWindow = function(obj) {\n  return obj !== null && obj === obj.window;\n};\n\nvar isPlainObject = function( obj ) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n\n  var key;\n  for ( key in obj ) {}\n\n  return key === undefined || core_hasOwn.call( obj, key );\n};\n\nvar isFunction = function(obj) {\n  return type(obj) === \"function\";\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return type(obj) === \"array\";\n};\n\nvar extend = function() {\n  var options, name, src, copy, copyIsArray, clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if ( typeof target !== \"object\" && !isFunction(target) ) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if ( length === i ) {\n    target = this;\n    --i;\n  }\n\n  for ( ; i < length; i++ ) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[ i ]) != null) {\n      // Extend the base object\n      for ( name in options ) {\n        src = target[ name ];\n        copy = options[ name ];\n\n        // Prevent never-ending loop\n        if ( target === copy ) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = isArray(copy)) ) ) {\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && isArray(src) ? src : [];\n\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[ name ] = extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = extend;\n}\n\nvar ajax = function ajax(options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  var call = function(fun) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (typeof fun === typeof Function) {\n      fun.apply(this, args);\n    }\n  }; \n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000\n  };\n  options = extend(true, defaultOptions, options);\n  if (options.auth) {\n      var token = btoa(options.auth.username + ':' + options.auth.password);\n      options.headers.Authorization = 'Basic ' + token;\n  }\n  var onSuccess = function(obj, resp, cb){\n    if (!options.binary && !options.json && options.processData && typeof obj !== 'string') {\n      obj = JSON.stringify(obj);\n    } else if (!options.binary && options.json && typeof obj === 'string') {\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        call(cb, e);\n        return;\n      }\n    }\n    call(cb, null, obj, resp);\n  };\n  var onError = function(err, cb){\n    var errParsed;\n    var errObj = err.responseText ? {status: err.status} : err; //this seems too clever\n    try{\n      errParsed = JSON.parse(err.responseText); //would prefer not to have a try/catch clause\n      errObj = extend(true, {}, errObj, errParsed);\n    } catch(e){}\n    call(cb, errObj);\n  };\n  if (typeof window !== 'undefined' && window.XMLHttpRequest) {\n    var timer,timedout  = false;\n    var xhr = new XMLHttpRequest();\n    xhr.open(options.method, options.url);\n    if (options.json) {\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n      if (options.body && options.processData && typeof options.body !== \"string\") {\n        options.body = JSON.stringify(options.body);\n      }\n    }\n    if (options.binary) {\n      xhr.responseType = 'arraybuffer';\n    }\n    for (var key in options.headers){\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n    if (!(\"body\" in options)) {\n      options.body = null;\n    }\n\n    var abortReq = function() {\n        timedout=true;\n        xhr.abort();\n        call(onError, xhr, callback);\n    };\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState !== 4 || timedout) {\n        return;\n      }\n      clearTimeout(timer);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        var data;\n        if (options.binary) {\n          data = new Blob([xhr.response || ''], {type: xhr.getResponseHeader('Content-Type')});\n        } else {\n          data = xhr.responseText;\n        }\n        call(onSuccess, data, xhr, callback);\n      } else {\n         call(onError, xhr, callback);\n      }\n    };\n    if (options.timeout > 0) {\n      timer = setTimeout(abortReq, options.timeout);\n    }\n    xhr.send(options.body);\n    return {abort:abortReq};\n  } else {\n    if (options.json) {\n      if (!options.binary) {\n        options.headers.Accept = 'application/json';\n      }\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n    }\n    if (options.binary) {\n      options.encoding = null;\n      options.json = false;\n    }\n    if (!options.processData) {\n      options.json = false;\n    }\n    return request(options, function(err, response, body) {\n      if (err) {\n        err.status = response ? response.statusCode : 400;\n        return call(onError, err, callback);\n      }\n\n      var content_type = response.headers['content-type'];\n      var data = (body || '');\n\n      // CouchDB doesn't always return the right content-type for JSON data, so\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n      if (!options.binary && (options.json || !options.processData) && typeof data !== 'object' &&\n          (/json/.test(content_type) ||\n           (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n        data = JSON.parse(data);\n      }\n      \n      if (data.error) {\n        data.status = response.statusCode;\n        call(onError, data, callback);\n      }\n      else {\n        call(onSuccess, data, response, callback);\n      }\n    });\n  }\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = ajax;\n}\n/*globals PouchAdapter: true, extend: true */\n\n\"use strict\";\n\nvar Pouch = function Pouch(name, opts, callback) {\n\n  if (!(this instanceof Pouch)) {\n    return new Pouch(name, opts, callback);\n  }\n\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n\n  if (typeof callback === 'undefined') {\n    callback = function() {};\n  }\n\n  var backend = Pouch.parseAdapter(opts.name || name);\n  opts.originalName = name;\n  opts.name = opts.name || backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  if (!Pouch.adapters[opts.adapter]) {\n    throw 'Adapter is missing';\n  }\n\n  if (!Pouch.adapters[opts.adapter].valid()) {\n    throw 'Invalid Adapter';\n  }\n\n  var adapter = new PouchAdapter(opts, function(err, db) {\n    if (err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n\n    for (var plugin in Pouch.plugins) {\n      // In future these will likely need to be async to allow the plugin\n      // to initialise\n      var pluginObj = Pouch.plugins[plugin](db);\n      for (var api in pluginObj) {\n        // We let things like the http adapter use its own implementation\n        // as it shares a lot of code\n        if (!(api in db)) {\n          db[api] = pluginObj[api];\n        }\n      }\n    }\n    db.taskqueue.ready(true);\n    db.taskqueue.execute(db);\n    callback(null, db);\n  });\n  for (var j in adapter) {\n    this[j] = adapter[j];\n  }\n  for (var plugin in Pouch.plugins) {\n    // In future these will likely need to be async to allow the plugin\n    // to initialise\n    var pluginObj = Pouch.plugins[plugin](this);\n    for (var api in pluginObj) {\n      // We let things like the http adapter use its own implementation\n      // as it shares a lot of code\n      if (!(api in this)) {\n        this[api] = pluginObj[api];\n      }\n    }\n  }\n};\n\nPouch.DEBUG = false;\n\nPouch.adapters = {};\nPouch.plugins = {};\n\nPouch.parseAdapter = function(name) {\n\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    var adapter = match[1];\n    if (!Pouch.adapters[adapter].valid()) {\n      throw 'Invalid adapter';\n    }\n    return {name: name, adapter: match[1]};\n  }\n\n  var preferredAdapters = ['idb', 'leveldb', 'websql'];\n  for (var i = 0; i < preferredAdapters.length; ++i) {\n    if (preferredAdapters[i] in Pouch.adapters) {\n      return {\n        name: name,\n        adapter: preferredAdapters[i]\n      };\n    }\n  }\n\n  throw 'No valid adapter found';\n};\n\nPouch.destroy = function(name, callback) {\n  var opts = Pouch.parseAdapter(name);\n  var cb = function(err, response) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    for (var plugin in Pouch.plugins) {\n      Pouch.plugins[plugin]._delete(name);\n    }\n    if (Pouch.DEBUG) {\n      console.log(name + ': Delete Database');\n    }\n\n    // call destroy method of the particular adaptor\n    Pouch.adapters[opts.adapter].destroy(opts.name, callback);\n  };\n \n  // remove Pouch from allDBs\n  Pouch.removeFromAllDbs(opts, cb);\n};\n\nPouch.removeFromAllDbs = function(opts, callback) {\n  // Only execute function if flag is enabled\n  if (!Pouch.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  // skip http and https adaptors for allDbs\n  var adapter = opts.adapter;\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  // remove db from Pouch.ALL_DBS\n  new Pouch(Pouch.allDBName(opts.adapter), function(err, db) {\n    if (err) {\n      // don't fail when allDbs fail\n      console.log(err);\n      callback();\n      return;\n    }\n    // check if db has been registered in Pouch.ALL_DBS\n    var dbname = Pouch.dbName(opts.adapter, opts.name);\n    db.get(dbname, function(err, doc) {\n      if (err) {\n        callback();\n      } else {\n        db.remove(doc, function(err, response) {\n          if (err) {\n            console.log(err);\n          }\n          callback();\n        });\n      }\n    });\n  });\n \n};\n\nPouch.adapter = function (id, obj) {\n  if (obj.valid()) {\n    Pouch.adapters[id] = obj;\n  }\n};\n\nPouch.plugin = function(id, obj) {\n  Pouch.plugins[id] = obj;\n};\n\n// flag to toggle allDbs (off by default)\nPouch.enableAllDbs = false;\n\n// name of database used to keep track of databases\nPouch.ALL_DBS = \"_allDbs\";\nPouch.dbName = function(adapter, name) {\n  return [adapter, \"-\", name].join('');\n};\nPouch.realDBName = function(adapter, name) {\n  return [adapter, \"://\", name].join('');\n};\nPouch.allDBName = function(adapter) {\n  return [adapter, \"://\", Pouch.ALL_DBS].join('');\n};\n\nPouch.open = function(opts, callback) {\n  // Only register pouch with allDbs if flag is enabled\n  if (!Pouch.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  var adapter = opts.adapter;\n  // skip http and https adaptors for allDbs\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  new Pouch(Pouch.allDBName(adapter), function(err, db) {\n    if (err) {\n      // don't fail when allDb registration fails\n      console.log(err);\n      callback();\n      return;\n    }\n\n    // check if db has been registered in Pouch.ALL_DBS\n    var dbname = Pouch.dbName(adapter, opts.name);\n    db.get(dbname, function(err, response) {\n      if (err && err.status === 404) {\n        db.put({\n          _id: dbname,\n          dbname: opts.originalName \n        }, function(err) {\n            if (err) {\n                console.log(err);\n            }\n\n            callback();\n        });\n      } else {\n        callback();\n      }\n    });\n  });\n};\n\nPouch.allDbs = function(callback) {\n  var accumulate = function(adapters, all_dbs) {\n    if (adapters.length === 0) {\n      // remove duplicates\n      var result = [];\n      all_dbs.forEach(function(doc) {\n        var exists = result.some(function(db) {\n          return db.id === doc.id;\n        });\n\n        if (!exists) {\n          result.push(doc);\n        }\n      });\n\n      // return an array of dbname\n      callback(null, result.map(function(row) {\n          return row.doc.dbname;\n      }));\n      return;\n    }\n\n    var adapter = adapters.shift();\n\n    // skip http and https adaptors for allDbs\n    if (adapter === \"http\" || adapter === \"https\") {\n      accumulate(adapters, all_dbs);\n      return;\n    }\n\n    new Pouch(Pouch.allDBName(adapter), function(err, db) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      db.allDocs({include_docs: true}, function(err, response) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // append from current adapter rows\n        all_dbs.unshift.apply(all_dbs, response.rows);\n\n        // code to clear allDbs.\n        // response.rows.forEach(function(row) {\n        //   db.remove(row.doc, function() {\n        //     console.log(arguments);\n        //   });\n        // });\n\n        // recurse\n        accumulate(adapters, all_dbs);\n      });\n    });\n  };\n  var adapters = Object.keys(Pouch.adapters);\n  accumulate(adapters, []);\n};\n\n// Enumerate errors, add the status code so we can reflect the HTTP api\n// in future\nPouch.Errors = {\n  MISSING_BULK_DOCS: {\n    status: 400,\n    error: 'bad_request',\n    reason: \"Missing JSON list of 'docs'\"\n  },\n  MISSING_DOC: {\n    status: 404,\n    error: 'not_found',\n    reason: 'missing'\n  },\n  REV_CONFLICT: {\n    status: 409,\n    error: 'conflict',\n    reason: 'Document update conflict'\n  },\n  INVALID_ID: {\n    status: 400,\n    error: 'invalid_id',\n    reason: '_id field must contain a string'\n  },\n  MISSING_ID: {\n    status: 412,\n    error: 'missing_id',\n    reason: '_id is required for puts'\n  },\n  RESERVED_ID: {\n    status: 400,\n    error: 'bad_request',\n    reason: 'Only reserved document ids may start with underscore.'\n  },\n  NOT_OPEN: {\n    status: 412,\n    error: 'precondition_failed',\n    reason: 'Database not open so cannot close'\n  },\n  UNKNOWN_ERROR: {\n    status: 500,\n    error: 'unknown_error',\n    reason: 'Database encountered an unknown error'\n  },\n  INVALID_REQUEST: {\n    status: 400,\n    error: 'invalid_request',\n    reason: 'Request was invalid'\n  },\n  QUERY_PARSE_ERROR: {\n    status: 400,\n    error: 'query_parse_error',\n    reason: 'Some query parameter is invalid'\n  },\n  BAD_REQUEST: {\n    status: 400,\n    error: 'bad_request',\n    reason: 'Something wrong with the request'\n  }\n};\nPouch.error = function(error, reason){\n return extend({}, error, {reason: reason});\n};\nif (typeof module !== 'undefined' && module.exports) {\n  global.Pouch = Pouch;\n  Pouch.merge = require('./pouch.merge.js').merge;\n  Pouch.collate = require('./pouch.collate.js').collate;\n  Pouch.replicate = require('./pouch.replicate.js').replicate;\n  Pouch.utils = require('./pouch.utils.js');\n  extend = Pouch.utils.extend;\n  module.exports = Pouch;\n  var PouchAdapter = require('./pouch.adapter.js');\n  //load adapters known to work under node\n  var adapters = ['leveldb', 'http'];\n  adapters.map(function(adapter) {\n    var adapter_path = './adapters/pouch.'+adapter+'.js';\n    require(adapter_path);\n  });\n  require('./plugins/pouchdb.mapreduce.js');\n} else {\n  window.Pouch = Pouch;\n}\n\n'use strict';\n\n// a few hacks to get things in the right place for node.js\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n}\n\nvar stringCollate = function(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n};\n\nvar objectCollate = function(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = Pouch.collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = Pouch.collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n};\n\nvar arrayCollate = function(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = Pouch.collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n};\n\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\nvar collationIndex = function(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  if (id.indexOf(typeof x) !== -1) {\n    if (x === null) {\n      return 1;\n    }\n    return id.indexOf(typeof x) + 2;\n  }\n  if (Array.isArray(x)) {\n    return 4.5;\n  }\n};\n\nPouch.collate = function(a, b) {\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  if (typeof a === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'boolean') {\n    return a < b ? -1 : 1;\n  }\n  if (typeof a === 'string') {\n    return stringCollate(a, b);\n  }\n  if (Array.isArray(a)) {\n    return arrayCollate(a, b);\n  }\n  if (typeof a === 'object') {\n    return objectCollate(a, b);\n  }\n};\n/*globals rootToLeaf: false, extend: false */\n\n'use strict';\n\n// a few hacks to get things in the right place for node.js\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n  var utils = require('./pouch.utils.js');\n  for (var k in utils) {\n    global[k] = utils[k];\n  }\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\n// Turn a path as a flat array into a tree with a single branch\nfunction pathToTree(path) {\n  var doc = path.shift();\n  var root = [doc.id, doc.opts, []];\n  var leaf = root;\n  var nleaf;\n\n  while (path.length) {\n    doc = path.shift();\n    nleaf = [doc.id, doc.opts, []];\n    leaf[2].push(nleaf);\n    leaf = nleaf;\n  }\n  return root;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        tree1[2].push(tree2[2][i]);\n        tree1[2].sort();\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res, branch;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  tree.forEach(function(branch) {\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we want to\n      // merge.  If the keys match we return the longer path with the other merged\n      // After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        if (!item.ids) {\n          continue;\n        }\n        /*jshint loopfunc:true */\n        item.ids[2].forEach(function(el, idx) {\n          trees.push({ids: el, diff: item.diff-1, parent: item.ids, parentIdx: idx});\n        });\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  });\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(function(a, b) {\n    return a.pos - b.pos;\n  });\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths,\n  // we cut off the start of the path and generate a new set of flat trees\n  var stemmedPaths = rootToLeaf(tree).map(function(path) {\n    var stemmed = path.ids.slice(-depth);\n    return {\n      pos: path.pos + (path.ids.length - stemmed.length),\n      ids: pathToTree(stemmed)\n    };\n  });\n  // Then we remerge all those flat trees together, ensuring that we dont\n  // connect trees that would go beyond the depth limit\n  return stemmedPaths.reduce(function(prev, current, i, arr) {\n    return doMerge(prev, current, true).tree;\n  }, [stemmedPaths.shift()]);\n}\n\nPouch.merge = function(tree, path, depth) {\n  // Ugh, nicer way to not modify arguments in place?\n  tree = extend(true, [], tree);\n  path = extend(true, {}, path);\n  var newTree = doMerge(tree, path);\n  return {\n    tree: stem(newTree.tree, depth),\n    conflicts: newTree.conflicts\n  };\n};\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nPouch.merge.winningRev = function(metadata) {\n  var leafs = [];\n  Pouch.merge.traverseRevTree(metadata.rev_tree,\n                              function(isLeaf, pos, id, something, opts) {\n    if (isLeaf) {\n      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});\n    }\n  });\n  leafs.sort(function(a, b) {\n    if (a.deleted !== b.deleted) {\n      return a.deleted > b.deleted ? 1 : -1;\n    }\n    if (a.pos !== b.pos) {\n      return b.pos - a.pos;\n    }\n    return a.id < b.id ? 1 : -1;\n  });\n\n  return leafs[0].pos + '-' + leafs[0].id;\n};\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// Callback has signature function(isLeaf, pos, id, [context])\n// The return value from the callback will be passed as context to all\n// children of that node\nPouch.merge.traverseRevTree = function(revs, callback) {\n  var toVisit = [];\n\n  revs.forEach(function(tree) {\n    toVisit.push({pos: tree.pos, ids: tree.ids});\n  });\n  while (toVisit.length > 0) {\n    var node = toVisit.pop();\n    var pos = node.pos;\n    var tree = node.ids;\n    var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);\n    /*jshint loopfunc: true */\n    tree[2].forEach(function(branch) {\n      toVisit.push({pos: pos+1, ids: branch, ctx: newCtx});\n    });\n  }\n};\n\nPouch.merge.collectLeaves = function(revs) {\n  var leaves = [];\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.unshift({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(function(a, b) {\n    return b.pos - a.pos;\n  });\n  leaves.map(function(leaf) { delete leaf.pos; });\n  return leaves;\n};\n\n// returns all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nPouch.merge.collectConflicts = function(metadata) {\n  var win = Pouch.merge.winningRev(metadata);\n  var leaves = Pouch.merge.collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  leaves.forEach(function(leaf) {\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  });\n  return conflicts;\n};\n\n\n/*globals call: false, Crypto: false*/\n\n'use strict';\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\nvar Promise = function() {\n  this.cancelled = false;\n  this.cancel = function() {\n    this.cancelled = true;\n  };\n};\n\n// The RequestManager ensures that only one database request is active at\n// at time, it ensures we dont max out simultaneous HTTP requests and makes\n// the replication process easier to reason about\nvar RequestManager = function() {\n\n  var queue = [];\n  var api = {};\n  var processing = false;\n\n  // Add a new request to the queue, if we arent currently processing anything\n  // then process it immediately\n  api.enqueue = function(fun, args) {\n    queue.push({fun: fun, args: args});\n    if (!processing) {\n      api.process();\n    }\n  };\n\n  // Process the next request\n  api.process = function() {\n    if (processing || !queue.length) {\n      return;\n    }\n    processing = true;\n    var task = queue.shift();\n    task.fun.apply(null, task.args);\n  };\n\n  // We need to be notified whenever a request is complete to process\n  // the next request\n  api.notifyRequestComplete = function() {\n    processing = false;\n    api.process();\n  };\n\n  return api;\n};\n\n// TODO: check CouchDB's replication id generation, generate a unique id particular\n// to this replication\nvar genReplicationId = function(src, target, opts) {\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  return '_local/' + Crypto.MD5(src.id() + target.id() + filterFun);\n};\n\n// A checkpoint lets us restart replications from when they were last cancelled\nvar fetchCheckpoint = function(target, id, callback) {\n  target.get(id, function(err, doc) {\n    if (err && err.status === 404) {\n      callback(null, 0);\n    } else {\n      callback(null, doc.last_seq);\n    }\n  });\n};\n\nvar writeCheckpoint = function(target, id, checkpoint, callback) {\n  var check = {\n    _id: id,\n    last_seq: checkpoint\n  };\n  target.get(check._id, function(err, doc) {\n    if (doc && doc._rev) {\n      check._rev = doc._rev;\n    }\n    target.put(check, function(err, doc) {\n      callback();\n    });\n  });\n};\n\nfunction replicate(src, target, opts, promise) {\n\n  var requests = new RequestManager();\n  var writeQueue = [];\n  var repId = genReplicationId(src, target, opts);\n  var results = [];\n  var completed = false;\n  var pending = 0;\n  var last_seq = 0;\n  var continuous = opts.continuous || false;\n  var result = {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0\n  };\n\n  function docsWritten(err, res, len) {\n    requests.notifyRequestComplete();\n    if (opts.onChange) {\n      for (var i = 0; i < len; i++) {\n        /*jshint validthis:true */\n        opts.onChange.apply(this, [result]);\n      }\n    }\n    pending -= len;\n    result.docs_written += len;\n    isCompleted();\n  }\n\n  function writeDocs() {\n    if (!writeQueue.length) {\n      return requests.notifyRequestComplete();\n    }\n    var len = writeQueue.length;\n    target.bulkDocs({docs: writeQueue}, {new_edits: false}, function(err, res) {\n      docsWritten(err, res, len);\n    });\n    writeQueue = [];\n  }\n\n  function eachRev(id, rev) {\n    src.get(id, {revs: true, rev: rev, attachments: true}, function(err, doc) {\n      requests.notifyRequestComplete();\n      writeQueue.push(doc);\n      requests.enqueue(writeDocs);\n    });\n  }\n\n  function onRevsDiff(err, diffs) {\n    requests.notifyRequestComplete();\n    if (err) {\n      if (continuous) {\n        promise.cancel();\n      }\n      call(opts.complete, err, null);\n      return;\n    }\n\n    // We already have the full document stored\n    if (Object.keys(diffs).length === 0) {\n      pending--;\n      isCompleted();\n      return;\n    }\n\n    var _enqueuer = function (rev) {\n        requests.enqueue(eachRev, [id, rev]);\n    };\n\n    for (var id in diffs) {\n      diffs[id].missing.forEach(_enqueuer);\n    }\n  }\n\n  function fetchRevsDiff(diff) {\n    target.revsDiff(diff, onRevsDiff);\n  }\n\n  function onChange(change) {\n    last_seq = change.seq;\n    results.push(change);\n    result.docs_read++;\n    pending++;\n    var diff = {};\n    diff[change.id] = change.changes.map(function(x) { return x.rev; });\n    requests.enqueue(fetchRevsDiff, [diff]);\n  }\n\n  function complete() {\n    completed = true;\n    isCompleted();\n  }\n\n  function isCompleted() {\n    if (completed && pending === 0) {\n      result.end_time = Date.now();\n      writeCheckpoint(target, repId, last_seq, function(err, res) {\n        call(opts.complete, err, result);\n      });\n    }\n  }\n\n  fetchCheckpoint(target, repId, function(err, checkpoint) {\n\n    if (err) {\n      return call(opts.complete, err);\n    }\n\n    last_seq = checkpoint;\n\n    // Was the replication cancelled by the caller before it had a chance\n    // to start. Shouldnt we be calling complete?\n    if (promise.cancelled) {\n      return;\n    }\n\n    var repOpts = {\n      limit: 25,\n      continuous: continuous,\n      since: last_seq,\n      style: 'all_docs',\n      onChange: onChange,\n      complete: complete\n    };\n\n    if (opts.filter) {\n      repOpts.filter = opts.filter;\n    }\n\n    if (opts.query_params) {\n      repOpts.query_params = opts.query_params;\n    }\n\n    var changes = src.changes(repOpts);\n\n    if (opts.continuous) {\n      promise.cancel = changes.cancel;\n    }\n  });\n\n}\n\nfunction toPouch(db, callback) {\n  if (typeof db === 'string') {\n    return new Pouch(db, callback);\n  }\n  callback(null, db);\n}\n\nPouch.replicate = function(src, target, opts, callback) {\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  if (opts === undefined) {\n    opts = {};\n  }\n  opts.complete = callback;\n  var replicateRet = new Promise();\n  toPouch(src, function(err, src) {\n    if (err) {\n      return call(callback, err);\n    }\n    toPouch(target, function(err, target) {\n      if (err) {\n        return call(callback, err);\n      }\n      replicate(src, target, opts, replicateRet);\n    });\n  });\n  return replicateRet;\n};\n\n/*jshint strict: false */\n/*global request: true, Buffer: true, escape: true, $:true */\n/*global extend: true, Crypto: true */\n/*global chrome*/\n\n// Pretty dumb name for a function, just wraps callback calls so we dont\n// to if (callback) callback() everywhere\nvar call = function(fun) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (typeof fun === typeof Function) {\n    fun.apply(this, args);\n  }\n};\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nvar yankError = function(callback) {\n  return function(err, results) {\n    if (err || results[0].error) {\n      call(callback, err || results[0]);\n    } else {\n      call(callback, null, results[0]);\n    }\n  };\n};\n\nvar isLocalId = function(id) {\n  return (/^_local/).test(id);\n};\n\nvar isAttachmentId = function(id) {\n  return (/\\//.test(id) && !isLocalId(id) && !/^_design/.test(id));\n};\n\n// Parse document ids: docid[/attachid]\n//   - /attachid is optional, and can have slashes in it too\n//   - int ids and strings beginning with _design or _local are not split\n// returns an object: { docId: docid, attachmentId: attachid }\nvar parseDocId = function(id) {\n  var ids = (typeof id === 'string') && !(/^_(design|local)\\//.test(id)) ?\n    id.split('/') : [id];\n  return {\n    docId: ids[0],\n    attachmentId: ids.splice(1).join('/').replace(/^\\/+/, '')\n  };\n};\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\n//   - any other string value is a valid id\nvar isValidId = function(id) {\n  if (/^_/.test(id)) {\n    return (/^_(design|local)/).test(id);\n  }\n  return true;\n};\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nvar parseDoc = function(doc, newEdits) {\n  var error = null;\n\n  // check for an attachment id and add attachments as needed\n  if (doc._id) {\n    var id = parseDocId(doc._id);\n    if (id.attachmentId !== '') {\n      var attachment = btoa(JSON.stringify(doc));\n      doc = {_id: id.docId};\n      if (!doc._attachments) {\n        doc._attachments = {};\n      }\n      doc._attachments[id.attachmentId] = {\n        content_type: 'application/json',\n        data: attachment\n      };\n    }\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = Math.uuid();\n    }\n    newRevId = Math.uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      if (!revInfo) {\n        throw \"invalid value for property '_rev'\";\n      }\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], {}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = parseInt(revInfo[1], 10) + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = [{\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\n        ids: doc._revisions.ids.reduce(function(acc, x) {\n          if (acc === null) {\n            return [x, opts, []];\n          } else {\n            return [x, {}, [acc]];\n          }\n        }, null)\n      }];\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      nRevNum = parseInt(revInfo[1], 10);\n      newRevId = revInfo[2];\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], opts, []]\n      }];\n    }\n  }\n\n  if (typeof doc._id !== 'string') {\n    error = Pouch.Errors.INVALID_ID;\n  }\n  else if (!isValidId(doc._id)) {\n    error = Pouch.Errors.RESERVED_ID;\n  }\n\n  doc._id = decodeURIComponent(doc._id);\n  doc._rev = [nRevNum, newRevId].join('-');\n\n  if (error) {\n    return error;\n  }\n\n  return Object.keys(doc).reduce(function(acc, key) {\n    if (/^_/.test(key) && key !== '_attachments') {\n      acc.metadata[key.slice(1)] = doc[key];\n    } else {\n      acc.data[key] = doc[key];\n    }\n    return acc;\n  }, {metadata : {}, data : {}});\n};\n\nvar compareRevs = function(a, b) {\n  // Sort by id\n  if (a.id !== b.id) {\n    return (a.id < b.id ? -1 : 1);\n  }\n  // Then by deleted\n  if (a.deleted ^ b.deleted) {\n    return (a.deleted ? -1 : 1);\n  }\n  // Then by rev id\n  if (a.rev_tree[0].pos === b.rev_tree[0].pos) {\n    return (a.rev_tree[0].ids < b.rev_tree[0].ids ? -1 : 1);\n  }\n  // Then by depth of edits\n  return (a.rev_tree[0].start < b.rev_tree[0].start ? -1 : 1);\n};\n\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nvar computeHeight = function(revs) {\n  var height = {};\n  var edges = [];\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function(edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n};\n\n// returns first element of arr satisfying callback predicate\nvar arrayFirst = function(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n  return false;\n};\n\nvar filterChange = function(opts) {\n  return function(change) {\n    var req = {};\n    req.query = opts.query_params;\n    if (opts.filter && !opts.filter.call(this, change.doc, req)) {\n      return;\n    }\n    if (!opts.include_docs) {\n      delete change.doc;\n    }\n    call(opts.onChange, change);\n  };\n};\n\n// returns array of all branches from root to leaf in the ids form:\n// [[id, ...], ...]\nvar rootToLeaf = function(tree) {\n  var paths = [];\n  Pouch.merge.traverseRevTree(tree, function(isLeaf, pos, id, history, opts) {\n    history = history ? history.slice(0) : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      var rootPos = pos + 1 - history.length;\n      paths.unshift({pos: rootPos, ids: history});\n    }\n    return history;\n  });\n  return paths;\n};\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nvar isDeleted = function(metadata, rev) {\n  if (!rev) {\n    rev = Pouch.merge.winningRev(metadata);\n  }\n  if (rev.indexOf('-') >= 0) {\n    rev = rev.split('-')[1];\n  }\n  var deleted = false;\n  Pouch.merge.traverseRevTree(metadata.rev_tree, function(isLeaf, pos, id, acc, opts) {\n    if (id === rev) {\n      deleted = !!opts.deleted;\n    }\n  });\n\n  return deleted;\n};\n\nvar isChromeApp = function(){\n  return (typeof chrome !== \"undefined\" && typeof chrome.storage !== \"undefined\" && typeof chrome.storage.local !== \"undefined\");\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  // use node.js's crypto library instead of the Crypto object created by deps/uuid.js\n  var crypto = require('crypto');\n  var Crypto = {\n    MD5: function(str) {\n      return crypto.createHash('md5').update(str).digest('hex');\n    }\n  };\n  var extend = require('./deps/extend');\n  var ajax = require('./deps/ajax');\n\n  request = require('request');\n  _ = require('underscore');\n  $ = _;\n\n  module.exports = {\n    Crypto: Crypto,\n    call: call,\n    yankError: yankError,\n    isLocalId: isLocalId,\n    isAttachmentId: isAttachmentId,\n    parseDocId: parseDocId,\n    parseDoc: parseDoc,\n    isDeleted: isDeleted,\n    compareRevs: compareRevs,\n    computeHeight: computeHeight,\n    arrayFirst: arrayFirst,\n    filterChange: filterChange,\n    atob: function(str) {\n      return decodeURIComponent(escape(new Buffer(str, 'base64').toString('binary')));\n    },\n    btoa: function(str) {\n      return new Buffer(unescape(encodeURIComponent(str)), 'binary').toString('base64');\n    },\n    extend: extend,\n    ajax: ajax,\n    rootToLeaf: rootToLeaf,\n    isChromeApp: isChromeApp\n  };\n}\n\nvar Changes = function() {\n\n  var api = {};\n  var listeners = {};\n\n  if (isChromeApp()){\n    chrome.storage.onChanged.addListener(function(e){\n      api.notify(e.db_name.newValue);//object only has oldValue, newValue members\n    });\n  }\n  else {\n    window.addEventListener(\"storage\", function(e) {\n      api.notify(e.key);\n    });\n  }\n\n  api.addListener = function(db_name, id, db, opts) {\n    if (!listeners[db_name]) {\n      listeners[db_name] = {};\n    }\n    listeners[db_name][id] = {\n      db: db,\n      opts: opts\n    };\n  };\n\n  api.removeListener = function(db_name, id) {\n    delete listeners[db_name][id];\n  };\n\n  api.clearListeners = function(db_name) {\n    delete listeners[db_name];\n  };\n\n  api.notifyLocalWindows = function(db_name){\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (!isChromeApp()){\n      localStorage[db_name] = (localStorage[db_name] === \"a\") ? \"b\" : \"a\";\n    } else {\n      chrome.storage.local.set({db_name: db_name});\n    }\n  };\n\n  api.notify = function(db_name) {\n    if (!listeners[db_name]) { return; }\n\n    Object.keys(listeners[db_name]).forEach(function (i) {\n      var opts = listeners[db_name][i].opts;\n      listeners[db_name][i].db.changes({\n        include_docs: opts.include_docs,\n        conflicts: opts.conflicts,\n        continuous: false,\n        descending: false,\n        filter: opts.filter,\n        since: opts.since,\n        query_params: opts.query_params,\n        onChange: function(c) {\n          if (c.seq > opts.since && !opts.cancelled) {\n            opts.since = c.seq;\n            call(opts.onChange, c);\n          }\n        }\n      });\n    });\n  };\n\n  return api;\n};\n\n\n/*globals Pouch: true, yankError: false, extend: false, call: false, parseDocId: false, traverseRevTree: false */\n/*globals arrayFirst: false, rootToLeaf: false, computeHeight: false */\n\n\"use strict\";\n\n/*\n * A generic pouch adapter\n */\nvar PouchAdapter = function(opts, callback) {\n\n  var api = {};\n\n  var customApi = Pouch.adapters[opts.adapter](opts, function(err, db) {\n    if (err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n\n    for (var j in api) {\n      if (!db.hasOwnProperty(j)) {\n        db[j] = api[j];\n      }\n    }\n\n    // Don't call Pouch.open for ALL_DBS\n    // Pouch.open saves the db's name into ALL_DBS\n    if (opts.name === Pouch.ALL_DBS) {\n      callback(err, db);\n    } else {\n      Pouch.open(opts, function(err) {\n        callback(err, db);\n      });\n    }\n  });\n\n  var auto_compaction = (opts.auto_compaction === true);\n\n  // wraps a callback with a function that runs compaction after each edit\n  var autoCompact = function(callback) {\n    if (!auto_compaction) {\n      return callback;\n    }\n    return function(err, res) {\n      if (err) {\n        call(callback, err);\n      } else {\n        var count = res.length;\n        var decCount = function() {\n          count--;\n          if (!count) {\n            call(callback, null, res);\n          }\n        };\n        res.forEach(function(doc) {\n          if (doc.ok) {\n            // TODO: we need better error handling\n            compactDocument(doc.id, 1, decCount);\n          } else {\n            decCount();\n          }\n        });\n      }\n    };\n  };\n\n  api.post = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return customApi.bulkDocs({docs: [doc]}, opts,\n        autoCompact(yankError(callback)));\n  };\n\n  api.put = function(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n    return customApi.bulkDocs({docs: [doc]}, opts,\n        autoCompact(yankError(callback)));\n  };\n\n  api.putAttachment = function (id, rev, blob, type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    if (typeof type === 'undefined') {\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    id = parseDocId(id);\n\n    function createAttachment(doc) {\n      doc._attachments = doc._attachments || {};\n      doc._attachments[id.attachmentId] = {\n        content_type: type,\n        data: blob\n      };\n      api.put(doc, callback);\n    }\n\n    api.get(id.docId, function(err, doc) {\n      // create new doc\n      if (err && err.error === Pouch.Errors.MISSING_DOC.error) {\n        createAttachment({_id: id.docId});\n        return;\n      }\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (doc._rev !== rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      createAttachment(doc);\n    });\n  };\n\n  api.removeAttachment = function (id, rev, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, function(err, obj) {\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (obj._rev !== rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      obj._attachments = obj._attachments || {};\n      delete obj._attachments[id.attachmentId];\n      api.put(obj, callback);\n    });\n  };\n\n  api.remove = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (opts === undefined) {\n      opts = {};\n    }\n    opts.was_delete = true;\n    var newDoc = extend(true, {}, doc);\n    newDoc._deleted = true;\n    return customApi.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n  };\n\n  api.revsDiff = function (req, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ids = Object.keys(req);\n    var count = 0;\n    var missing = {};\n\n    function readDoc(err, doc, id) {\n      req[id].map(function(revId) {\n        var matches = function(x) { return x.rev !== revId; };\n        if (!doc || doc._revs_info.every(matches)) {\n          if (!missing[id]) {\n            missing[id] = {missing: []};\n          }\n          missing[id].missing.push(revId);\n        }\n      });\n\n      if (++count === ids.length) {\n        return call(callback, null, missing);\n      }\n    }\n\n    ids.map(function(id) {\n      api.get(id, {revs_info: true}, function(err, doc) {\n        readDoc(err, doc, id);\n      });\n    });\n  };\n\n  // compact one document and fire callback\n  // by compacting we mean removing all revisions which\n  // are further from the leaf in revision tree than max_height\n  var compactDocument = function(docId, max_height, callback) {\n    customApi._getRevisionTree(docId, function(err, rev_tree){\n      if (err) {\n        return call(callback);\n      }\n      var height = computeHeight(rev_tree);\n      var nonLeaves = [];\n      Object.keys(height).forEach(function(rev) {\n        if (height[rev] > max_height) {\n          nonLeaves.push(rev);\n        }\n      });\n      customApi._removeDocRevisions(docId, nonLeaves, callback);\n    });\n  };\n\n  // compact the whole database using single document\n  // compaction\n  api.compact = function(callback) {\n    api.allDocs(function(err, res) {\n      var count = res.rows.length;\n      if (!count) {\n        call(callback);\n        return;\n      }\n      res.rows.forEach(function(row) {\n        compactDocument(row.key, 0, function() {\n          count--;\n          if (!count) {\n            call(callback);\n          }\n        });\n      });\n    });\n  };\n\n  /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\n  api.get = function (id, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('get', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var leaves = [];\n    function finishOpenRevs() {\n      var result = [];\n      var count = leaves.length;\n      if (!count) {\n        return call(callback, null, result);\n      }\n      // order with open_revs is unspecified\n      leaves.forEach(function(leaf){\n        api.get(id, {rev: leaf, revs: opts.revs}, function(err, doc){\n          if (!err) {\n            result.push({ok: doc});\n          } else {\n            result.push({missing: leaf});\n          }\n          count--;\n          if(!count) {\n            call(callback, null, result);\n          }\n        });\n      });\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs === \"all\") {\n        customApi._getRevisionTree(id, function(err, rev_tree){\n          if (err) {\n            // if there's no such document we should treat this\n            // situation the same way as if revision tree was empty\n            rev_tree = [];\n          }\n          leaves = Pouch.merge.collectLeaves(rev_tree).map(function(leaf){\n            return leaf.rev;\n          });\n          finishOpenRevs();\n        });\n      } else {\n        if (Array.isArray(opts.open_revs)) {\n          leaves = opts.open_revs;\n          for (var i = 0; i < leaves.length; i++) {\n            var l = leaves[i];\n            // looks like it's the only thing couchdb checks\n            if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\n              return call(callback, Pouch.error(Pouch.Errors.BAD_REQUEST,\n                \"Invalid rev format\" ));\n            }\n          }\n          finishOpenRevs();\n        } else {\n          return call(callback, Pouch.error(Pouch.Errors.UNKNOWN_ERROR,\n            'function_clause'));\n        }\n      }\n      return; // open_revs does not like other options\n    }\n\n    id = parseDocId(id);\n    if (id.attachmentId !== '') {\n      return customApi.getAttachment(id, callback);\n    }\n    return customApi._get(id, opts, function(result, metadata) {\n      if ('error' in result) {\n        return call(callback, result);\n      }\n\n      var doc = result;\n      function finish() {\n        call(callback, null, doc);\n      }\n\n      if (opts.conflicts) {\n        var conflicts = Pouch.merge.collectConflicts(metadata);\n        if (conflicts.length) {\n          doc._conflicts = conflicts;\n        }\n      }\n\n      if (opts.revs || opts.revs_info) {\n        var paths = rootToLeaf(metadata.rev_tree);\n        paths.map(function(path, i) {\n          paths[i].ids = path.ids.map(function(x) { return x.id; });\n        });\n        var path = arrayFirst(paths, function(arr) {\n          return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\n        });\n        path.ids.splice(path.ids.indexOf(doc._rev.split('-')[1]) + 1);\n        path.ids.reverse();\n\n        if (opts.revs) {\n          doc._revisions = {\n            start: (path.pos + path.ids.length) - 1,\n            ids: path.ids\n          };\n        }\n        if (opts.revs_info) {\n          // TODO: it could be slow to test status like this\n          var count = path.ids.length;\n          var pos = path.pos + path.ids.length - 1;\n          doc._revs_info = [];\n\n          path.ids.forEach(function(hash) {\n            var rev = pos + '-' + hash;\n            var info = {\n              rev: rev,\n              status: \"available\"\n            };\n            pos--;\n            doc._revs_info.push(info);\n\n            api.get(id.docId, {rev: rev}, function(err, ok) {\n              if (err) {\n                info.status = \"missing\";\n              }\n              count--;\n              if (!count) {\n                finish();\n              }\n            });\n          });\n        } else {\n          finish();\n        }\n      } else {\n        finish();\n      }\n\n    });\n  };\n\n  api.getAttachment = function(id, opts, callback) {\n    if (opts instanceof Function) {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof id === 'string') {\n      id = parseDocId(id);\n    }\n\n    return customApi._getAttachment(id, opts, callback);\n  };\n\n  api.allDocs = function(opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('allDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if ('keys' in opts) {\n      if ('startkey' in opts) {\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\n          'Query parameter `start_key` is not compatible with multi-get'\n        ));\n        return;\n      }\n      if ('endkey' in opts) {\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\n          'Query parameter `end_key` is not compatible with multi-get'\n        ));\n        return;\n      }\n    }\n\n    return customApi._allDocs(opts, callback);\n  };\n\n  api.changes = function(opts) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('changes', arguments);\n      return;\n    }\n    opts = extend(true, {}, opts);\n\n    // 0 and 1 should return 1 document\n    opts.limit = opts.limit === 0 ? 1 : opts.limit;\n    return customApi._changes(opts);\n  };\n\n  api.close = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('close', arguments);\n      return;\n    }\n    return customApi._close(callback);\n  };\n\n  api.info = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('info', arguments);\n      return;\n    }\n    return customApi._info(callback);\n  };\n\n  api.id = function() {\n    return customApi._id();\n  };\n\n  api.type = function() {\n    return (typeof customApi._type === 'function') ? customApi._type() : opts.adapter;\n  };\n\n  api.bulkDocs = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('bulkDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    } else {\n      opts = extend(true, {}, opts);\n    }\n\n    if (!req || !req.docs || req.docs.length < 1) {\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\n    }\n\n    if (!Array.isArray(req.docs)) {\n      return call(callback, Pouch.Errors.QUERY_PARSE_ERROR);\n    }\n\n    req = extend(true, {}, req);\n    if (!('new_edits' in opts)) {\n      opts.new_edits = true;\n    }\n\n    return customApi._bulkDocs(req, opts, autoCompact(callback));\n  };\n\n  /* End Wrappers */\n  var taskqueue = {};\n\n  taskqueue.ready = false;\n  taskqueue.queue = [];\n\n  api.taskqueue = {};\n\n  api.taskqueue.execute = function (db) {\n    if (taskqueue.ready) {\n      taskqueue.queue.forEach(function(d) {\n        db[d.task].apply(null, d.parameters);\n      });\n    }\n  };\n\n  api.taskqueue.ready = function() {\n    if (arguments.length === 0) {\n      return taskqueue.ready;\n    }\n    taskqueue.ready = arguments[0];\n  };\n\n  api.taskqueue.addTask = function(task, parameters) {\n    taskqueue.queue.push({ task: task, parameters: parameters });\n  };\n\n  api.replicate = {};\n\n  api.replicate.from = function (url, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, customApi, opts, callback);\n  };\n\n  api.replicate.to = function (dbName, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(customApi, dbName, opts, callback);\n  };\n\n  for (var j in api) {\n    if (!customApi.hasOwnProperty(j)) {\n      customApi[j] = api[j];\n    }\n  }\n\n  // Http adapter can skip setup so we force the db to be ready and execute any jobs\n  if (opts.skipSetup) {\n    api.taskqueue.ready(true);\n    api.taskqueue.execute(api);\n  }\n\n  return customApi;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = PouchAdapter;\n}\n\n/*globals Pouch: true, call: false, ajax: true */\n/*globals require: false, console: false */\n\n\"use strict\";\n\nvar HTTP_TIMEOUT = 10000;\n\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nfunction parseUri (str) {\n  var o = parseUri.options;\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    uri[o.key[i]] = m[i] || \"\";\n  }\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) {\n      uri[o.q.name][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name) {\n  // If the given name contains \"http:\"\n  if (/http(s?):/.test(name)) {\n    // Prase the URI into all its little bits\n    var uri = parseUri(name);\n\n    // Store the fact that it is a remote URI\n    uri.remote = true;\n\n    // Store the user and password as a separate auth object\n    if (uri.user || uri.password) {\n      uri.auth = {username: uri.user, password: uri.password};\n    }\n\n    // Split the path part of the URI into parts using '/' as the delimiter\n    // after removing any leading '/' and any trailing '/'\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n    // Store the first part as the database name and remove it from the parts\n    // array\n    uri.db = parts.pop();\n\n    // Restore the path by joining all the remaining parts (all the parts\n    // except for the database name) with '/'s\n    uri.path = parts.join('/');\n\n    return uri;\n  }\n\n  // If the given name does not contain 'http:' then return a very basic object\n  // with no host, the current path, the given name as the database name and no\n  // username/password\n  return {host: '', path: '/', db: name, auth: false};\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  // If the host is remote\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // Return the URL made up of all the host's information and the given path\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\n      opts.path + pathDel + opts.db + '/' + path;\n  }\n\n  // If the host is not remote, then return the URL made up of just the\n  // database name and the given path\n  return '/' + opts.db + '/' + path;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  if (opts.remote) {\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + path;\n  }\n  return '/' + path;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nvar HttpPouch = function(opts, callback) {\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var host = getHost(opts.name);\n  if (opts.auth) {\n    host.auth = opts.auth;\n  }\n\n  // Generate the database URL based on the host\n  var db_url = genDBUrl(host, '');\n\n  // The functions that will be publically available for HttpPouch\n  var api = {};\n\n  var uuids = {\n    list: [],\n    get: function(opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {count: 10};\n      }\n      var cb = function(err, body) {\n        if (err || !('uuids' in body)) {\n          call(callback, err || Pouch.Errors.UNKNOWN_ERROR);\n        } else {\n          uuids.list = uuids.list.concat(body.uuids);\n          call(callback, null, \"OK\");\n        }\n      };\n      var params = '?count=' + opts.count;\n      ajax({\n        auth: host.auth,\n        method: 'GET',\n        url: genUrl(host, '_uuids') + params\n      }, cb);\n    }\n  };\n\n  // Create a new CouchDB database based on the given opts\n  var createDB = function(){\n    ajax({auth: host.auth, method: 'PUT', url: db_url}, function(err, ret) {\n      // If we get an \"Unauthorized\" error\n      if (err && err.status === 401) {\n        // Test if the database already exists\n        ajax({auth: host.auth, method: 'HEAD', url: db_url}, function (err, ret) {\n          // If there is still an error\n          if (err) {\n            // Give the error to the callback to deal with\n            call(callback, err);\n          } else {\n            // Continue as if there had been no errors\n            call(callback, null, api);\n          }\n        });\n        // If there were no errros or if the only error is \"Precondition Failed\"\n        // (note: \"Precondition Failed\" occurs when we try to create a database\n        // that already exists)\n      } else if (!err || err.status === 412) {\n        // Continue as if there had been no errors\n        call(callback, null, api);\n      } else {\n        call(callback, Pouch.Errors.UNKNOWN_ERROR);\n      }\n    });\n  };\n  if (!opts.skipSetup) {\n    ajax({auth: host.auth, method: 'GET', url: db_url}, function(err, ret) {\n      //check if the db exists\n      if (err) {\n        if (err.status === 404) {\n          //if it doesn't, create it\n          createDB();\n        } else {\n          call(callback, err);\n        }\n      } else {\n        //go do stuff with the db\n        call(callback, null, api);\n        }\n    });\n  }\n\n  api.type = function() {\n    return 'http';\n  };\n\n  // The HttpPouch's ID is its URL\n  api.id = function() {\n    return genDBUrl(host, '');\n  };\n\n  api.request = function(options, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('request', arguments);\n      return;\n    }\n    options.auth = host.auth;\n    options.url = genDBUrl(host, options.url);\n    ajax(options, callback);\n  };\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = function(opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('compact', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    ajax({\n      auth: host.auth,\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function() {\n      function ping() {\n        api.info(function(err, res) {\n          if (!res.compact_running) {\n            call(callback, null);\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      if (typeof callback === \"function\") {\n        ping();\n      }\n    });\n  };\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api.info = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('info', arguments);\n      return;\n    }\n    ajax({\n      auth: host.auth,\n      method:'GET',\n      url: genDBUrl(host, '')\n    }, callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = function(id, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('get', arguments);\n      return;\n    }\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // If it exists, add the opts.revs value to the list of parameters.\n    // If revs=true then the resulting JSON will include a field\n    // _revisions containing an array of the revision IDs.\n    if (opts.revs) {\n      params.push('revs=true');\n    }\n\n    // If it exists, add the opts.revs_info value to the list of parameters.\n    // If revs_info=true then the resulting JSON will include the field\n    // _revs_info containing an array of objects in which each object\n    // representing an available revision.\n    if (opts.revs_info) {\n      params.push('revs_info=true');\n    }\n\n    // If it exists, add the opts.open_revs value to the list of parameters.\n    // If open_revs=all then the resulting JSON will include all the leaf\n    // revisions. If open_revs=[\"rev1\", \"rev2\",...] then the resulting JSON\n    // will contain an array of objects containing data of all revisions\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.push('open_revs=' + opts.open_revs);\n    }\n\n    // If it exists, add the opts.attachments value to the list of parameters.\n    // If attachments=true the resulting JSON will include the base64-encoded\n    // contents in the \"data\" property of each attachment.\n    if (opts.attachments) {\n      params.push('attachments=true');\n    }\n\n    // If it exists, add the opts.rev value to the list of parameters.\n    // If rev is given a revision number then get the specified revision.\n    if (opts.rev) {\n      params.push('rev=' + opts.rev);\n    }\n\n    // If it exists, add the opts.conflicts value to the list of parameters.\n    // If conflicts=true then the resulting JSON will include the field\n    // _conflicts containing all the conflicting revisions.\n    if (opts.conflicts) {\n      params.push('conflicts=' + opts.conflicts);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // Set the options for the ajax call\n    var options = {\n      auth: host.auth,\n      method: 'GET',\n      url: genDBUrl(host, id + params)\n    };\n\n    // If the given id contains at least one '/' and the part before the '/'\n    // is NOT \"_design\" and is NOT \"_local\"\n    // OR\n    // If the given id contains at least two '/' and the part before the first\n    // '/' is \"_design\".\n    // TODO This second condition seems strange since if parts[0] === '_design'\n    // then we already know that parts[0] !== '_local'.\n    var parts = id.split('/');\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\n      // Binary is expected back from the server\n      options.binary = true;\n    }\n\n    // Get the document\n    ajax(options, function(err, doc, xhr) {\n      // If the document does not exist, send an error to the callback\n      if (err) {\n        return call(callback, err);\n      }\n\n      // Send the document to the callback\n      call(callback, null, doc, xhr);\n    });\n  };\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('remove', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Delete the document\n    ajax({\n      auth: host.auth,\n      method:'DELETE',\n      url: genDBUrl(host, doc._id) + '?rev=' + doc._rev\n    }, callback);\n  };\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('removeAttachment', arguments);\n      return;\n    }\n    ajax({\n      auth: host.auth,\n      method: 'DELETE',\n      url: genDBUrl(host, id) + '?rev=' + rev\n    }, callback);\n  };\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = function(id, rev, blob, type, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('putAttachment', arguments);\n      return;\n    }\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    if (typeof type === 'undefined') {\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    // Add the attachment\n    ajax({\n      auth: host.auth,\n      method:'PUT',\n      url: url,\n      headers: {'Content-Type': type},\n      processData: false,\n      body: blob\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This fails if the doc has no _id field.\n  api.put = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('put', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n\n    // List of parameter to add to the PUT request\n    var params = [];\n\n    // If it exists, add the opts.new_edits value to the list of parameters.\n    // If new_edits = false then the database will NOT assign this document a\n    // new revision number\n    if (opts && typeof opts.new_edits !== 'undefined') {\n      params.push('new_edits=' + opts.new_edits);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Add the document\n    ajax({\n      auth: host.auth,\n      method: 'PUT',\n      url: genDBUrl(host, doc._id) + params,\n      body: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This does not assume that doc is a new document (i.e. does not\n  // have a _id or a _rev field.\n  api.post = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('post', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (! (\"_id\" in doc)) {\n      if (uuids.list.length > 0) {\n        doc._id = uuids.list.pop();\n        api.put(doc, opts, callback);\n      }else {\n        uuids.get(function(err, resp) {\n          if (err) {\n            return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n          }\n          doc._id = uuids.list.pop();\n          api.put(doc, opts, callback);\n        });\n      }\n    } else {\n      api.put(doc, opts, callback);\n    }\n  };\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api.bulkDocs = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('bulkDocs', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    }\n\n    // If opts.new_edits exists add it to the document data to be\n    // send to the database.\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    if (typeof opts.new_edits !== 'undefined') {\n      req.new_edits = opts.new_edits;\n    }\n\n    // Update/create the documents\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_bulk_docs'),\n      body: req\n    }, callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = function(opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('allDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // TODO I don't see conflicts as a valid parameter for a\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.descending is truthy add it to params\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.include_docs exists, add the include_docs value to the\n    // list of parameters.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs) {\n      params.push('include_docs=true');\n    }\n\n    // If opts.startkey exists, add the startkey value to the list of\n    // parameters.\n    // If startkey is given then the returned list of documents will\n    // start with the document whose id is startkey.\n    if (opts.startkey) {\n      params.push('startkey=' +\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n\n    // If opts.endkey exists, add the endkey value to the list of parameters.\n    // If endkey is given then the returned list of docuemnts will\n    // end with the document whose id is endkey.\n    if (opts.endkey) {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys:opts.keys});\n    }\n\n    // Get the document listing\n    ajax({\n      auth: host.auth,\n      method: method,\n      url: genDBUrl(host, '_all_docs' + params),\n      body: body\n    }, callback);\n  };\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api.changes = function(opts) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('changes', arguments);\n      return;\n    }\n\n    if (Pouch.DEBUG) {\n      console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    // Query string of all the parameters to add to the GET request\n    var params = [],\n        paramsStr;\n\n    if (opts.style) {\n      params.push('style='+opts.style);\n    }\n\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\n    // function, add the include_docs value to the query string.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.push('include_docs=true');\n    }\n\n    // If opts.continuous exists, add the feed value to the query string.\n    // If feed=longpoll then it waits for either a timeout or a change to\n    // occur before returning.\n    if (opts.continuous) {\n      params.push('feed=longpoll');\n    }\n\n    // If opts.conflicts exists, add the conflicts value to the query string.\n    // TODO I can't find documentation of what conflicts=true does. See\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    if (opts.limit || opts.limit === 0) {\n      params.push('limit=' + opts.limit);\n    }\n\n    // If opts.descending exists, add the descending value to the query string.\n    // if descending=true then the change results are returned in\n    // descending order (most recent change first).\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.filter exists and is a string then add the filter value\n    // to the query string.\n    // If filter is given a string containing the name of a filter in\n    // the design, then only documents passing through the filter will\n    // be returned.\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.push('filter=' + opts.filter);\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params.push(param_name+'='+opts.query_params[param_name]);\n        }\n      }\n    }\n\n    paramsStr = '?';\n\n    if (params.length > 0) {\n      paramsStr += params.join('&');\n    }\n\n    var xhr;\n    var last_seq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function(since, callback) {\n      // Set the options for the ajax call\n      var xhrOpts = {\n        auth: host.auth, method:'GET',\n        url: genDBUrl(host, '_changes' + paramsStr + '&since=' + since),\n        timeout: null          // _changes can take a long time to generate, especially when filtered\n      };\n      last_seq = since;\n\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      xhr = ajax(xhrOpts, callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var fetchTimeout = 10;\n    var fetchRetryCount = 0;\n    var fetched = function(err, res) {\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        // For each change\n        res.results.forEach(function(c) {\n          var hasFilter = opts.filter && typeof opts.filter === 'function';\n          var req = {};\n          req.query = opts.query_params;\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc, req])) {\n            return;\n          }\n\n          // Process the change\n          call(opts.onChange, c);\n        });\n      }\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        last_seq = res.last_seq;\n      }\n\n      if (opts.continuous) {\n        // Increase retry delay exponentially as long as errors persist\n        if (err) {\n          fetchRetryCount += 1;\n        } else {\n          fetchRetryCount = 0;\n        }\n        var timeoutMultiplier = 1 << fetchRetryCount;\n        // i.e. Math.pow(2, fetchRetryCount)\n\n        var retryWait = fetchTimeout * timeoutMultiplier;\n        var maximumWait = opts.maximumWait || 30000;\n        if (retryWait > maximumWait) {\n          call(opts.complete, err || Pouch.Errors.UNKNOWN_ERROR, null);\n        }\n\n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () {\n          fetch(last_seq, fetched);\n        }, retryWait);\n      } else {\n        // We're done, call the callback\n        call(opts.complete, null, res);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function() {\n        if (Pouch.DEBUG) {\n          console.log(db_url + ': Cancel Changes Feed');\n        }\n        opts.aborted = true;\n        xhr.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('revsDiff', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, function(err, res) {\n      call(callback, err, res);\n    });\n  };\n\n  api.close = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('close', arguments);\n      return;\n    }\n    call(callback, null);\n  };\n\n  return api;\n};\n\n// Delete the HttpPouch specified by the given name.\nHttpPouch.destroy = function(name, callback) {\n  var host = getHost(name);\n  ajax({auth: host.auth, method: 'DELETE', url: genDBUrl(host, '')}, callback);\n};\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function() {\n  return true;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  // running in node\n  var pouchdir = '../';\n  Pouch = require(pouchdir + 'pouch.js');\n  ajax = Pouch.utils.ajax;\n}\n\n// Set HttpPouch to be the adapter used with the http scheme.\nPouch.adapter('http', HttpPouch);\nPouch.adapter('https', HttpPouch);\n\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\n\n'use strict';\n\n// While most of the IDB behaviors match between implementations a\n// lot of the names still differ. This section tries to normalize the\n// different objects & methods.\nvar indexedDB = window.indexedDB ||\n  window.mozIndexedDB ||\n  window.webkitIndexedDB;\n\n// still needed for R/W transactions in Android Chrome. follow MDN example:\n// https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#transaction\n// note though that Chrome Canary fails on undefined READ_WRITE constants\n// on the native IDBTransaction object\nvar IDBTransaction = (window.IDBTransaction && window.IDBTransaction.READ_WRITE) ?\n  window.IDBTransaction :\n  (window.webkitIDBTransaction && window.webkitIDBTransaction.READ_WRITE) ?\n    window.webkitIDBTransaction :\n    { READ_WRITE: 'readwrite' };\n\nvar IDBKeyRange = window.IDBKeyRange ||\n  window.webkitIDBKeyRange;\n\nwindow.storageInfo = window.storageInfo ||\n  window.webkitStorageInfo;\n\nwindow.requestFileSystem = window.requestFileSystem ||\n    window.webkitRequestFileSystem;\n\nvar idbError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar IdbPouch = function(opts, callback) {\n\n  // IndexedDB requires a versioned database structure, this is going to make\n  // it hard to dynamically create object stores if we needed to for things\n  // like views\n  var POUCH_VERSION = 1;\n\n  // The object stores created for each database\n  // DOC_STORE stores the document meta data, its revision history and state\n  var DOC_STORE = 'document-store';\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\n  // sequence id\n  var BY_SEQ_STORE = 'by-sequence';\n  // Where we store attachments\n  var ATTACH_STORE = 'attach-store';\n  // Where we store meta data\n  var META_STORE = 'meta-store';\n  // Where we detect blob support\n  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\n\n  var name = opts.name;\n  var req = indexedDB.open(name, POUCH_VERSION);\n  var meta = {\n    id: 'meta-store',\n    updateSeq: 0\n  };\n\n  var blobSupport = null;\n\n  var instanceId = null;\n  var api = {};\n  var idb = null;\n\n  if (Pouch.DEBUG) {\n    console.log(name + ': Open Database');\n  }\n\n  req.onupgradeneeded = function(e) {\n    var db = e.target.result;\n    var currentVersion = e.oldVersion;\n    while (currentVersion !== e.newVersion) {\n      if (currentVersion === 0) {\n        createSchema(db);\n      }\n      currentVersion++;\n    }\n  };\n\n  function createSchema(db) {\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\n      .createIndex('seq', 'seq', {unique: true});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n  }\n\n  req.onsuccess = function(e) {\n\n    idb = e.target.result;\n\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],\n                              IDBTransaction.READ_WRITE);\n\n    idb.onversionchange = function() {\n      idb.close();\n    };\n\n    // polyfill the new onupgradeneeded api for chrome. can get rid of when\n    // saucelabs moves to chrome 23\n    if (idb.setVersion && Number(idb.version) !== POUCH_VERSION) {\n      var versionReq = idb.setVersion(POUCH_VERSION);\n      versionReq.onsuccess = function(evt) {\n        function setVersionComplete() {\n          req.onsuccess(e);\n        }\n        evt.target.result.oncomplete = setVersionComplete;\n        req.onupgradeneeded(e);\n      };\n      return;\n    }\n\n    var req = txn.objectStore(META_STORE).get('meta-store');\n\n    req.onsuccess = function(e) {\n      var reqDBId,\n          result;\n\n      if (e.target.result) {\n        meta = e.target.result;\n      }\n\n      if (name + '_id' in meta) {\n        instanceId = meta[name + '_id'];\n      } else {\n        instanceId = Math.uuid();\n\n        meta[name + '_id'] = instanceId;\n        reqDBId = txn.objectStore(META_STORE).put(meta);\n      }\n\n      // detect blob support\n      try {\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(new Blob(), \"key\");\n        blobSupport = true;\n      } catch (err) {\n        blobSupport = false;\n      } finally {\n        call(callback, null, api);\n      }\n    };\n  };\n\n  req.onerror = idbError(callback);\n\n  api.type = function() {\n    return 'idb';\n  };\n\n  // Each database needs a unique id so that we can store the sequence\n  // checkpoint without having other databases confuse itself.\n  api.id = function idb_id() {\n    return instanceId;\n  };\n\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function(docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return call(callback, docInfoErrors[0]);\n    }\n\n    var results = [];\n    var docs = [];\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function processDocs() {\n      if (!docs.length) {\n        return;\n      }\n      var currentDoc = docs.shift();\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\n      req.onsuccess = function process_docRead(event) {\n        var oldDoc = event.target.result;\n        if (!oldDoc) {\n          insertDoc(currentDoc);\n        } else {\n          updateDoc(oldDoc, currentDoc);\n        }\n      };\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = Pouch.merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (isLocalId(metadata.id)) {\n          return;\n        }\n\n        IdbPouch.Changes.notify(name);\n        IdbPouch.Changes.notifyLocalWindows(name);\n      });\n      call(callback, null, aresults);\n    }\n\n    function preprocessAttachment(att, callback) {\n      if (att.stub) {\n        return callback();\n      }\n      if (typeof att.data === 'string') {\n        var data = atob(att.data);\n        att.digest = 'md5-' + Crypto.MD5(data);\n        if (blobSupport) {\n          var type = att.content_type;\n          att.data = new Blob([data], {type: type});\n        }\n        return callback();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function(e) {\n        att.digest = 'md5-' + Crypto.MD5(this.result);\n        if (!blobSupport) {\n          att.data = btoa(this.result);\n        }\n        callback();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      docInfos.forEach(function(docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        var recv = 0;\n        function attachmentProcessed() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback) {\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      meta.updateSeq++;\n      var req = txn.objectStore(META_STORE).put(meta);\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      function finish() {\n        docInfo.data._doc_id_rev = docInfo.data._id + \"::\" + docInfo.data._rev;\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\n        dataReq.onsuccess = function(e) {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Wrote Document ', docInfo.metadata.id);\n          }\n          docInfo.metadata.seq = e.target.result;\n          // Current _rev is calculated from _rev_tree on read\n          delete docInfo.metadata.rev;\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\n          metaDataReq.onsuccess = function() {\n            results.push(docInfo);\n            call(callback);\n          };\n        };\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var wasPreviouslyDeleted = isDeleted(oldDoc);\n      var inConflict = (wasPreviouslyDeleted && isDeleted(docInfo.metadata)) ||\n        (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs);\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var objectStore = txn.objectStore(ATTACH_STORE);\n      var getReq = objectStore.get(digest).onsuccess = function(e) {\n        var originalRefs = e.target.result && e.target.result.refs || {};\n        var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n        var newAtt = {\n          digest: digest,\n          body: data,\n          refs: originalRefs\n        };\n        newAtt.refs[ref] = true;\n        var putReq = objectStore.put(newAtt).onsuccess = function(e) {\n          call(callback);\n        };\n      };\n    }\n\n    var txn;\n    preprocessAttachments(function() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],\n                            IDBTransaction.READ_WRITE);\n      txn.onerror = idbError(callback);\n      txn.ontimeout = idbError(callback);\n      txn.oncomplete = complete;\n\n      processDocs();\n    });\n  };\n\n  function sortByBulkSeq(a, b) {\n    return a._bulk_seq - b._bulk_seq;\n  }\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var result;\n    var metadata;\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n    txn.oncomplete = function() {\n      call(callback, result, metadata);\n    };\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      metadata = e.target.result;\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        result = Pouch.Errors.MISSING_DOC;\n        return;\n      }\n      if (isDeleted(metadata) && !opts.rev) {\n        result = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\n        return;\n      }\n\n      var rev = Pouch.merge.winningRev(metadata);\n      var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);\n      var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n\n      index.get(key).onsuccess = function(e) {\n        var doc = e.target.result;\n        if(doc && doc._doc_id_rev) {\n          delete(doc._doc_id_rev);\n        }\n        if (!doc) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n        if (opts.attachments && doc._attachments) {\n          var attachments = Object.keys(doc._attachments);\n          var recv = 0;\n\n          attachments.forEach(function(key) {\n            api.getAttachment(doc._id + '/' + key, {encode: true, txn: txn}, function(err, data) {\n              doc._attachments[key].data = data;\n\n              if (++recv === attachments.length) {\n                result = doc;\n              }\n            });\n          });\n        } else {\n          if (doc._attachments){\n            for (var key in doc._attachments) {\n              doc._attachments[key].stub = true;\n            }\n          }\n          result = doc;\n        }\n      };\n    };\n  };\n\n  api._getAttachment = function(id, opts, callback) {\n    var result;\n    var txn;\n\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      txn = opts.txn;\n    } else {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      txn.oncomplete = function() { call(callback, null, result); };\n    }\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      var metadata = e.target.result;\n      var bySeq = txn.objectStore(BY_SEQ_STORE);\n      bySeq.get(metadata.seq).onsuccess = function(e) {\n        var attachment = e.target.result._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type;\n\n        txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {\n          var data = e.target.result.body;\n          if (opts.encode) {\n            if (blobSupport) {\n              var reader = new FileReader();\n              reader.onloadend = function(e) {\n                result = btoa(this.result);\n\n                if ('txn' in opts) {\n                  call(callback, null, result);\n                }\n              };\n              reader.readAsBinaryString(data);\n            } else {\n              result = data;\n\n              if ('txn' in opts) {\n                call(callback, null, result);\n              }\n            }\n          } else {\n            if (blobSupport) {\n              result = data;\n            } else {\n              result = new Blob([atob(data)], {type: type});\n            }\n            if ('txn' in opts) {\n              call(callback, null, result);\n            }\n          }\n        };\n      };\n    };\n    return;\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var keyRange = start && end ? IDBKeyRange.bound(start, end)\n      : start ? IDBKeyRange.lowerBound(start)\n      : end ? IDBKeyRange.upperBound(end) : null;\n\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\n    transaction.oncomplete = function() {\n      if ('keys' in opts) {\n        opts.keys.forEach(function(key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      call(callback, null, {\n        total_rows: results.length,\n        rows: results\n      });\n    };\n\n    var oStore = transaction.objectStore(DOC_STORE);\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\n      : oStore.openCursor(keyRange);\n    var results = [];\n    var resultsMap = {};\n    oCursor.onsuccess = function(e) {\n      if (!e.target.result) {\n        return;\n      }\n      var cursor = e.target.result;\n      var metadata = cursor.value;\n      // If opts.keys is set we want to filter here only those docs with\n      // key in opts.keys. With no performance tests it is difficult to\n      // guess if iteration with filter is faster than many single requests\n      function allDocsInner(metadata, data) {\n        if (isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n        var doc = {\n          id: metadata.id,\n          key: metadata.id,\n          value: {\n            rev: Pouch.merge.winningRev(metadata)\n          }\n        };\n        if (opts.include_docs) {\n          doc.doc = data;\n          doc.doc._rev = Pouch.merge.winningRev(metadata);\n          if (doc.doc._doc_id_rev) {\n              delete(doc.doc._doc_id_rev);\n          }\n          if (opts.conflicts) {\n            doc.doc._conflicts = Pouch.merge.collectConflicts(metadata)\n              .map(function(x) { return x.id; });\n          }\n        }\n        if ('keys' in opts) {\n          if (opts.keys.indexOf(metadata.id) > -1) {\n            if (isDeleted(metadata)) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            }\n            resultsMap[doc.id] = doc;\n          }\n        } else {\n          if(!isDeleted(metadata)) {\n            results.push(doc);\n          }\n        }\n        cursor['continue']();\n      }\n\n      if (!opts.include_docs) {\n        allDocsInner(metadata);\n      } else {\n        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        var mainRev = Pouch.merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        index.get(key).onsuccess = function(event) {\n          allDocsInner(cursor.value, event.target.result);\n        };\n      }\n    };\n  };\n\n  // Looping through all the documents in the database is a terrible idea\n  // easiest to implement though, should probably keep a counter\n  api._info = function idb_info(callback) {\n    var count = 0;\n    var result;\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n\n    txn.oncomplete = function() {\n      callback(null, result);\n    };\n\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = function(e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          result = {\n            db_name: name,\n            doc_count: count,\n            update_seq: meta.updateSeq\n          };\n          return;\n        }\n        if (cursor.value.deleted !== true) {\n          count++;\n        }\n        cursor['continue']();\n      };\n  };\n\n  api._changes = function idb_changes(opts) {\n    if (Pouch.DEBUG) {\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    if (!opts.since) {\n      opts.since = 0;\n    }\n\n    if (opts.continuous) {\n      var id = name + ':' + Math.uuid();\n      opts.cancelled = false;\n      IdbPouch.Changes.addListener(name, id, api, opts);\n      IdbPouch.Changes.notify(name);\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Cancel Changes Feed');\n          }\n          opts.cancelled = true;\n          IdbPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var txn;\n\n    function fetchChanges() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\n      txn.oncomplete = onTxnComplete;\n\n      var req;\n\n      if (opts.limit && descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true), descending);\n      } else if (opts.limit && !descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true));\n      } else if (descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true), descending);\n      } else {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true));\n      }\n\n      req.onsuccess = onsuccess;\n      req.onerror = onerror;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        /*jshint evil: true */\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n\n    function onsuccess(event) {\n      if (!event.target.result) {\n        // Filter out null results casued by deduping\n        for (var i = 0, l = results.length; i < l; i++ ) {\n          var result = results[i];\n          if (result) {\n            dedupResults.push(result);\n          }\n        }\n        return false;\n      }\n\n      var cursor = event.target.result;\n\n      // Try to pre-emptively dedup to save us a bunch of idb calls\n      var changeId = cursor.value._id;\n      var changeIdIndex = resultIndices[changeId];\n      if (changeIdIndex !== undefined) {\n        results[changeIdIndex].seq = cursor.key;\n        // update so it has the later sequence number\n        results.push(results[changeIdIndex]);\n        results[changeIdIndex] = null;\n        resultIndices[changeId] = results.length - 1;\n        return cursor['continue']();\n      }\n\n      var index = txn.objectStore(DOC_STORE);\n      index.get(cursor.value._id).onsuccess = function(event) {\n        var metadata = event.target.result;\n        if (isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n\n        var mainRev = Pouch.merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        index.get(key).onsuccess = function(docevent) {\n          var doc = docevent.target.result;\n          var changeList = [{rev: mainRev}];\n          if (opts.style === 'all_docs') {\n            changeList = Pouch.merge.collectLeaves(metadata.rev_tree)\n              .map(function(x) { return {rev: x.rev}; });\n          }\n          var change = {\n            id: metadata.id,\n            seq: cursor.key,\n            changes: changeList,\n            doc: doc\n          };\n\n          if (isDeleted(metadata, mainRev)) {\n            change.deleted = true;\n          }\n          if (opts.conflicts) {\n            change.doc._conflicts = Pouch.merge.collectConflicts(metadata)\n              .map(function(x) { return x.id; });\n          }\n\n          // Dedupe the changes feed\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\n          if (changeIdIndex !== undefined) {\n            results[changeIdIndex] = null;\n          }\n          results.push(change);\n          resultIndices[changeId] = results.length - 1;\n          cursor['continue']();\n        };\n      };\n    }\n\n    function onTxnComplete() {\n      dedupResults.map(filterChange(opts));\n      call(opts.complete, null, {results: dedupResults});\n    }\n\n    function onerror(error) {\n      // TODO: shouldn't we pass some params here?\n      call(opts.complete);\n    }\n  };\n\n  api._close = function(callback) {\n    if (idb === null) {\n      return call(callback, Pouch.Errors.NOT_OPEN);\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    call(callback, null);\n  };\n\n  // compaction internal functions\n  api._getRevisionTree = function(docId, callback) {\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = event.target.result;\n      if (!doc) {\n        call(callback, Pouch.Errors.MISSING_DOC);\n      } else {\n        call(callback, null, doc.rev_tree);\n      }\n    };\n  };\n\n  api._removeDocRevisions = function(docId, revs, callback) {\n    var txn = idb.transaction([BY_SEQ_STORE], IDBTransaction.READ_WRITE);\n    var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n    revs.forEach(function(rev) {\n      var key = docId + \"::\" + rev;\n      index.getKey(key).onsuccess = function(e) {\n        var seq = e.target.result;\n        if (!seq) {\n          return;\n        }\n        var req = txn.objectStore(BY_SEQ_STORE)['delete'](seq);\n      };\n    });\n    txn.oncomplete = function() {\n      callback();\n    };\n  };\n  // end of compaction internal functions\n\n  return api;\n};\n\nIdbPouch.valid = function idb_valid() {\n  return !!indexedDB;\n};\n\nIdbPouch.destroy = function idb_destroy(name, callback) {\n  if (Pouch.DEBUG) {\n    console.log(name + ': Delete Database');\n  }\n  IdbPouch.Changes.clearListeners(name);\n  var req = indexedDB.deleteDatabase(name);\n\n  req.onsuccess = function() {\n    call(callback, null);\n  };\n\n  req.onerror = idbError(callback);\n};\n\nIdbPouch.Changes = new Changes();\n\nPouch.adapter('idb', IdbPouch);\n\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\n\n'use strict';\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar POUCH_VERSION = 1;\nvar POUCH_SIZE = 5 * 1024 * 1024;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE = quote('attach-store');\nvar META_STORE = quote('metadata-store');\n\nvar unknownError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar webSqlPouch = function(opts, callback) {\n\n  var api = {};\n  var update_seq = 0;\n  var instanceId = null;\n  var name = opts.name;\n\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  if (!db) {\n    return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n  }\n\n  function dbCreated() {\n    callback(null, api);\n  }\n\n  db.transaction(function (tx) {\n    var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\n      ' (update_seq, dbid)';\n    var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\n      ' (digest, json, body BLOB)';\n    var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\n      ' (id unique, seq, json, winningseq)';\n    var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\n      ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json)';\n\n    tx.executeSql(attach);\n    tx.executeSql(doc);\n    tx.executeSql(seq);\n    tx.executeSql(meta);\n\n    var updateseq = 'SELECT update_seq FROM ' + META_STORE;\n    tx.executeSql(updateseq, [], function(tx, result) {\n      if (!result.rows.length) {\n        var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\n        var newId = Math.uuid();\n        tx.executeSql(initSeq, [0]);\n        return;\n      }\n      update_seq = result.rows.item(0).update_seq;\n    });\n    var dbid = 'SELECT dbid FROM ' + META_STORE;\n    tx.executeSql(dbid, [], function(tx, result) {\n      if (!result.rows.length) {\n        var initDb = 'INSERT INTO ' + META_STORE + ' (dbid) VALUES (?)';\n        var newId = Math.uuid();\n        tx.executeSql(initDb, [newId]);\n        return;\n      }\n      instanceId = result.rows.item(0).dbid;\n    });\n  }, unknownError(callback), dbCreated);\n\n  api.type = function() {\n    return 'websql';\n  };\n\n  api.id = function() {\n    return instanceId;\n  };\n\n  api._info = function(callback) {\n    db.transaction(function(tx) {\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\n      tx.executeSql(sql, [], function(tx, result) {\n        callback(null, {\n          db_name: name,\n          doc_count: result.rows.item(0).count,\n          update_seq: update_seq\n        });\n      });\n    });\n  };\n\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\n\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function(docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return call(callback, docInfoErrors[0]);\n    }\n\n    var tx;\n    var results = [];\n    var docs = [];\n    var fetchedDocs = {};\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function sortByBulkSeq(a, b) {\n      return a._bulk_seq - b._bulk_seq;\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = Pouch.merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (isLocalId(metadata.id)) {\n          return;\n        }\n\n        update_seq++;\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\n        tx.executeSql(sql, [update_seq], function() {\n          webSqlPouch.Changes.notify(name);\n          webSqlPouch.Changes.notifyLocalWindows(name);\n        });\n      });\n      call(callback, null, aresults);\n    }\n\n    function preprocessAttachment(att, callback) {\n      if (att.stub) {\n        return callback();\n      }\n      if (typeof att.data === 'string') {\n        att.data = atob(att.data);\n        att.digest = 'md5-' + Crypto.MD5(att.data);\n        return callback();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function(e) {\n        att.data = this.result;\n        att.digest = 'md5-' + Crypto.MD5(this.result);\n        callback();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      var recv = 0;\n\n      docInfos.forEach(function(docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        function processedAttachment() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], processedAttachment);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback, isUpdate) {\n\n      function finish() {\n        var data = docInfo.data;\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (doc_id_rev, json) VALUES (?, ?);';\n        tx.executeSql(sql, [data._id + \"::\" + data._rev,\n                            JSON.stringify(data)], dataWritten);\n      }\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n\n      function dataWritten(tx, result) {\n        var seq = docInfo.metadata.seq = result.insertId;\n        delete docInfo.metadata.rev;\n\n        var mainRev = Pouch.merge.winningRev(docInfo.metadata);\n\n        var sql = isUpdate ?\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +\n          BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json) VALUES (?, ?, ?, ?);';\n        var metadataStr = JSON.stringify(docInfo.metadata);\n        var key = docInfo.metadata.id + \"::\" + mainRev;\n        var params = isUpdate ?\n          [seq, metadataStr, key, docInfo.metadata.id] :\n          [docInfo.metadata.id, seq, seq, metadataStr];\n        tx.executeSql(sql, params, function(tx, result) {\n          results.push(docInfo);\n          call(callback, null);\n        });\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs, true);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs, false);\n    }\n\n    function processDocs() {\n      if (!docs.length) {\n        return complete();\n      }\n      var currentDoc = docs.shift();\n      var id = currentDoc.metadata.id;\n      if (id in fetchedDocs) {\n        updateDoc(fetchedDocs[id], currentDoc);\n      } else {\n        // if we have newEdits=false then we can update the same\n        // document twice in a single bulk docs call\n        fetchedDocs[id] = currentDoc.metadata;\n        insertDoc(currentDoc);\n      }\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n      var newAtt = {digest: digest};\n      var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';\n      tx.executeSql(sql, [digest], function(tx, result) {\n        if (!result.rows.length) {\n          newAtt.refs = {};\n          newAtt.refs[ref] = true;\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function() {\n            call(callback, null);\n          });\n        } else {\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';\n          tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function() {\n            call(callback, null);\n          });\n        }\n      });\n    }\n\n    function metadataFetched(tx, results) {\n      for (var j=0; j<results.rows.length; j++) {\n        var row = results.rows.item(j);\n        fetchedDocs[row.id] = JSON.parse(row.json);\n      }\n      processDocs();\n    }\n\n    preprocessAttachments(function() {\n      db.transaction(function(txn) {\n        tx = txn;\n        var ids = '(' + docs.map(function(d) {\n          return quote(d.metadata.id);\n        }).join(',') + ')';\n        var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\n        tx.executeSql(sql, [], metadataFetched);\n      }, unknownError(callback));\n    });\n  };\n\n  api._get = function(id, opts, callback) {\n    var result;\n    var metadata;\n    db.transaction(function(tx) {\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\n      tx.executeSql(sql, [id.docId], function(tx, results) {\n        if (!results.rows.length) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n        metadata = JSON.parse(results.rows.item(0).json);\n        if (isDeleted(metadata) && !opts.rev) {\n          result = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\n          return;\n        }\n\n        var rev = Pouch.merge.winningRev(metadata);\n        var key = opts.rev ? opts.rev : rev;\n        key = metadata.id + '::' + key;\n        var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';\n        tx.executeSql(sql, [key], function(tx, results) {\n          if (!results.rows.length) {\n            result = Pouch.Errors.MISSING_DOC;\n            return;\n          }\n          var doc = JSON.parse(results.rows.item(0).json);\n\n          if (opts.attachments && doc._attachments) {\n            var attachments = Object.keys(doc._attachments);\n            var recv = 0;\n            attachments.forEach(function(key) {\n              api.getAttachment(doc._id + '/' + key, {encode: true, txn: tx}, function(err, data) {\n                doc._attachments[key].data = data;\n                if (++recv === attachments.length) {\n                  result = doc;\n                }\n              });\n            });\n          } else {\n            if (doc._attachments){\n              for (var key in doc._attachments) {\n                doc._attachments[key].stub = true;\n              }\n            }\n            result = doc;\n          }\n        });\n      });\n    }, unknownError(callback), function () {\n      call(callback, result, metadata);\n    });\n  };\n\n  function makeRevs(arr) {\n    return arr.map(function(x) { return {rev: x.rev}; });\n  }\n  function makeIds(arr) {\n    return arr.map(function(x) { return x.id; });\n  }\n\n  api._allDocs = function(opts, callback) {\n    var results = [];\n    var resultsMap = {};\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n      DOC_STORE + '.winningseq';\n\n    if ('keys' in opts) {\n      sql += ' WHERE ' + DOC_STORE + '.id IN (' + opts.keys.map(function(key){\n        return quote(key);\n      }).join(',') + ')';\n    } else {\n      if (start) {\n        sql += ' WHERE ' + DOC_STORE + '.id >= \"' + start + '\"';\n      }\n      if (end) {\n        sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= \"' + end + '\"';\n      }\n      sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\n    }\n\n    db.transaction(function(tx) {\n      tx.executeSql(sql, [], function(tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++ ) {\n          var doc = result.rows.item(i);\n          var metadata = JSON.parse(doc.metadata);\n          var data = JSON.parse(doc.data);\n          if (!(isLocalId(metadata.id))) {\n            doc = {\n              id: metadata.id,\n              key: metadata.id,\n              value: {rev: Pouch.merge.winningRev(metadata)}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = Pouch.merge.winningRev(metadata);\n              if (opts.conflicts) {\n                doc.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\n              }\n            }\n            if ('keys' in opts) {\n              if (opts.keys.indexOf(metadata.id) > -1) {\n                if (isDeleted(metadata)) {\n                  doc.value.deleted = true;\n                  doc.doc = null;\n                }\n                resultsMap[doc.id] = doc;\n              }\n            } else {\n              if(!isDeleted(metadata)) {\n                results.push(doc);\n              }\n            }\n          }\n        }\n      });\n    }, unknownError(callback), function() {\n      if ('keys' in opts) {\n        opts.keys.forEach(function(key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      call(callback, null, {\n        total_rows: results.length,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function idb_changes(opts) {\n\n    if (Pouch.DEBUG) {\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    if (!opts.since) {\n      opts.since = 0;\n    }\n\n    if (opts.continuous) {\n      var id = name + ':' + Math.uuid();\n      opts.cancelled = false;\n      webSqlPouch.Changes.addListener(name, id, api, opts);\n      webSqlPouch.Changes.notify(name);\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Cancel Changes Feed');\n          }\n          opts.cancelled = true;\n          webSqlPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var txn;\n\n    function fetchChanges() {\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\n\n      if (opts.limit) {\n        sql += ' LIMIT ' + opts.limit;\n      }\n\n      db.transaction(function(tx) {\n        tx.executeSql(sql, [], function(tx, result) {\n          for (var i = 0, l = result.rows.length; i < l; i++ ) {\n            var doc = result.rows.item(i);\n            var metadata = JSON.parse(doc.metadata);\n            if (!isLocalId(metadata.id)) {\n              var change = {\n                id: metadata.id,\n                seq: doc.seq,\n                changes: makeRevs(Pouch.merge.collectLeaves(metadata.rev_tree)),\n                doc: JSON.parse(doc.data)\n              };\n              change.doc._rev = Pouch.merge.winningRev(metadata);\n              if (isDeleted(metadata, change.doc._rev)) {\n                change.deleted = true;\n              }\n              if (opts.conflicts) {\n                change.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\n              }\n              results.push(change);\n            }\n          }\n          for (i = 0, l = results.length; i < l; i++ ) {\n            result = results[i];\n            if (result) {\n              dedupResults.push(result);\n            }\n          }\n          dedupResults.map(filterChange(opts));\n\n          call(opts.complete, null, {results: dedupResults});\n        });\n      });\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        /*jshint evil: true */\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n  };\n\n  api._getAttachment = function(id, opts, callback) {\n\n    var res;\n    function fetchAttachment(tx) {\n      var sql = 'SELECT ' + BY_SEQ_STORE + '.json AS data FROM ' + DOC_STORE +\n        ' JOIN ' + BY_SEQ_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' + DOC_STORE +\n        '.seq WHERE ' + DOC_STORE + '.id = \"' + id.docId + '\"' ;\n      tx.executeSql(sql, [], function(tx, result) {\n        var doc = JSON.parse(result.rows.item(0).data);\n        var attachment = doc._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type;\n        var sql = 'SELECT body FROM ' + ATTACH_STORE + ' WHERE digest=?';\n        tx.executeSql(sql, [digest], function(tx, result) {\n          var data = result.rows.item(0).body;\n          if (opts.encode) {\n            res = btoa(data);\n          } else {\n            res = new Blob([data], {type: type});\n          }\n          if ('txn' in opts) {\n            call(callback, null, res);\n          }\n        });\n      });\n    }\n\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      fetchAttachment(opts.txn);\n    } else {\n      db.transaction(fetchAttachment, unknownError(callback), function() {\n        call(callback, null, res);\n      });\n    }\n  };\n  // comapction internal functions\n  api._getRevisionTree = function(docId, callback) {\n    db.transaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function(tx, result) {\n        if (!result.rows.length) {\n          call(callback, Pouch.Errors.MISSING_DOC);\n        } else {\n          var data = JSON.parse(result.rows.item(0).metadata);\n          call(callback, null, data.rev_tree);\n        }\n      });\n    });\n  };\n  api._removeDocRevisions = function(docId, revs, callback) {\n    db.transaction(function (tx) {\n      var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +\n        revs.map(function(rev){return quote(docId + '::' + rev);}).join(',') + ')';\n      console.log(sql);\n      tx.executeSql(sql, [], function(tx, result) {\n        callback();\n      });\n    });\n  };\n  // end of compaction internal functions\n\n  return api;\n};\n\nwebSqlPouch.valid = function() {\n  return !!window.openDatabase;\n};\n\nwebSqlPouch.destroy = function(name, callback) {\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  db.transaction(function (tx) {\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\n  }, unknownError(callback), function() {\n    call(callback, null);\n  });\n};\n\nwebSqlPouch.Changes = new Changes();\n\nPouch.adapter('websql', webSqlPouch);\n\n/*global Pouch: true */\n\n\"use strict\";\n\n// This is the first implementation of a basic plugin, we register the\n// plugin object with pouch and it is mixin'd to each database created\n// (regardless of adapter), adapters can override plugins by providing\n// their own implementation. functions on the plugin object that start\n// with _ are reserved function that are called by pouchdb for special\n// notifications.\n\n// If we wanted to store incremental views we can do it here by listening\n// to the changes feed (keeping track of our last update_seq between page loads)\n// and storing the result of the map function (possibly using the upcoming\n// extracted adapter functions)\n\nvar MapReduce = function(db) {\n\n  function viewQuery(fun, options) {\n    if (!options.complete) {\n      return;\n    }\n\n    if (!fun.reduce) {\n      options.reduce = false;\n    }\n\n    function sum(values) {\n      return values.reduce(function(a, b) { return a + b; }, 0);\n    }\n\n    var results = [];\n    var current = null;\n    var num_started= 0;\n    var completed= false;\n\n    var emit = function(key, val) {\n      var viewRow = {\n        id: current.doc._id,\n        key: key,\n        value: val\n      };\n\n      if (options.startkey && Pouch.collate(key, options.startkey) < 0) return;\n      if (options.endkey && Pouch.collate(key, options.endkey) > 0) return;\n      if (options.key && Pouch.collate(key, options.key) !== 0) return;\n\n      num_started++;\n      if (options.include_docs) {\n        //in this special case, join on _id (issue #106)\n        if (val && typeof val === 'object' && val._id){\n          db.get(val._id,\n              function(_, joined_doc){\n                if (joined_doc) {\n                  viewRow.doc = joined_doc;\n                }\n                results.push(viewRow);\n                checkComplete();\n              });\n          return;\n        } else {\n          viewRow.doc = current.doc;\n        }\n      }\n      results.push(viewRow);\n    };\n\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\n    // above emit\n    eval('fun.map = ' + fun.map.toString() + ';');\n    if (fun.reduce) {\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\n    }\n\n    //only proceed once all documents are mapped and joined\n    var checkComplete= function(){\n      if (completed && results.length == num_started){\n        results.sort(function(a, b) {\n          return Pouch.collate(a.key, b.key);\n        });\n        if (options.descending) {\n          results.reverse();\n        }\n        if (options.reduce === false) {\n          return options.complete(null, {\n            rows: results,\n            total_rows: results.length\n          });\n        }\n\n        var groups = [];\n        results.forEach(function(e) {\n          var last = groups[groups.length-1] || null;\n          if (last && Pouch.collate(last.key[0][0], e.key) === 0) {\n            last.key.push([e.key, e.id]);\n            last.value.push(e.value);\n            return;\n          }\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\n        });\n        groups.forEach(function(e) {\n          e.value = fun.reduce(e.key, e.value) || null;\n          e.key = e.key[0][0];\n        });\n        options.complete(null, {rows: groups, total_rows: groups.length});\n      }\n    }\n\n    db.changes({\n      conflicts: true,\n      include_docs: true,\n      onChange: function(doc) {\n        if (!('deleted' in doc)) {\n          current = {doc: doc.doc};\n          fun.map.call(this, doc.doc);\n        }\n      },\n      complete: function() {\n        completed= true;\n        checkComplete();\n      }\n    });\n  }\n\n  function httpQuery(fun, opts, callback) {\n\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body = undefined;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    if (typeof opts.reduce !== 'undefined') {\n      params.push('reduce=' + opts.reduce);\n    }\n    if (typeof opts.include_docs !== 'undefined') {\n      params.push('include_docs=' + opts.include_docs);\n    }\n    if (typeof opts.limit !== 'undefined') {\n      params.push('limit=' + opts.limit);\n    }\n    if (typeof opts.descending !== 'undefined') {\n      params.push('descending=' + opts.descending);\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n    if (typeof opts.key !== 'undefined') {\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys:opts.keys});\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = fun.split('/');\n      db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }, callback);\n      return;\n    }\n\n    // We are using a temporary view, terrible for performance but good for testing\n    var queryObject = JSON.parse(JSON.stringify(fun, function(key, val) {\n      if (typeof val === 'function') {\n        return val + ''; // implicitly `toString` it\n      }\n      return val;\n    }));\n\n    db.request({\n      method:'POST',\n      url: '_temp_view' + params,\n      body: queryObject\n    }, callback);\n  }\n\n  function query(fun, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    if (db.type() === 'http') {\n\t  if (typeof fun === 'function'){\n\t    return httpQuery({map: fun}, opts, callback);\n\t  }\n\t  return httpQuery(fun, opts, callback);\n    }\n\n    if (typeof fun === 'object') {\n      return viewQuery(fun, opts);\n    }\n\n    if (typeof fun === 'function') {\n      return viewQuery({map: fun}, opts);\n    }\n\n    var parts = fun.split('/');\n    db.get('_design/' + parts[0], function(err, doc) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      viewQuery({\n        map: doc.views[parts[1]].map,\n        reduce: doc.views[parts[1]].reduce\n      }, opts);\n    });\n  }\n\n  return {'query': query};\n};\n\n// Deletion is a noop since we dont store the results of the view\nMapReduce._delete = function() { };\n\nPouch.plugin('mapreduce', MapReduce);\n\n })(this);"]],"start1":0,"start2":0,"length1":0,"length2":151439}]],"length":151439}
{"contributors":[],"silentsave":false,"ts":1366911799443,"patch":[[{"diffs":[[0,"DB*/"],[-1,"\n(function() {\n // BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n(function() {\n  // Private array of chars to use\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\n  Math.uuid = function (len, radix) {\n    var chars = CHARS, uuid = [];\n    radix = radix || chars.length;\n\n    if (len) {\n      // Compact form\n      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\n    } else {\n      // rfc4122, version 4 form\n      var r;\n\n      // rfc4122 requires these characters\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n      uuid[14] = '4';\n\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\n      // per rfc4122, sec. 4.1.5\n      for (var i = 0; i < 36; i++) {\n        if (!uuid[i]) {\n          r = 0 | Math.random()*16;\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join('');\n  };\n\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\n  // by minimizing calls to random()\n  Math.uuidFast = function() {\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\n    for (var i = 0; i < 36; i++) {\n      if (i==8 || i==13 ||  i==18 || i==23) {\n        uuid[i] = '-';\n      } else if (i==14) {\n        uuid[i] = '4';\n      } else {\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n        r = rnd & 0xf;\n        rnd = rnd >> 4;\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n      }\n    }\n    return uuid.join('');\n  };\n\n  // A more compact, but less performant, RFC4122v4 solution:\n  Math.uuidCompact = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    }).toUpperCase();\n  };\n})();\n\n// END Math.uuid.js\n\n/**\n*\n*  MD5 (Message-Digest Algorithm)\n*\n*  For original source see http://www.webtoolkit.info/\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\n*\n*  Licensed under CC-BY 2.0 License\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\n*\n**/\n\nvar Crypto = {};\n(function() {\n  Crypto.MD5 = function(string) {\n\n    function RotateLeft(lValue, iShiftBits) {\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n    }\n\n    function AddUnsigned(lX,lY) {\n      var lX4,lY4,lX8,lY8,lResult;\n      lX8 = (lX & 0x80000000);\n      lY8 = (lY & 0x80000000);\n      lX4 = (lX & 0x40000000);\n      lY4 = (lY & 0x40000000);\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n      if (lX4 & lY4) {\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n      }\n      if (lX4 | lY4) {\n        if (lResult & 0x40000000) {\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        } else {\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n        }\n      } else {\n        return (lResult ^ lX8 ^ lY8);\n      }\n    }\n\n    function F(x,y,z) { return (x & y) | ((~x) & z); }\n    function G(x,y,z) { return (x & z) | (y & (~z)); }\n    function H(x,y,z) { return (x ^ y ^ z); }\n    function I(x,y,z) { return (y ^ (x | (~z))); }\n\n    function FF(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function GG(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function HH(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function II(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function ConvertToWordArray(string) {\n      var lWordCount;\n      var lMessageLength = string.length;\n      var lNumberOfWords_temp1=lMessageLength + 8;\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n      var lWordArray=Array(lNumberOfWords-1);\n      var lBytePosition = 0;\n      var lByteCount = 0;\n      while ( lByteCount < lMessageLength ) {\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\n        lBytePosition = (lByteCount % 4)*8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n        lByteCount++;\n      }\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n      return lWordArray;\n    };\n\n    function WordToHex(lValue) {\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n      for (lCount = 0;lCount<=3;lCount++) {\n        lByte = (lValue>>>(lCount*8)) & 255;\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n      }\n      return WordToHexValue;\n    };\n\n    //**\tfunction Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\n\n    var x=Array();\n    var k,AA,BB,CC,DD,a,b,c,d;\n    var S11=7, S12=12, S13=17, S14=22;\n    var S21=5, S22=9 , S23=14, S24=20;\n    var S31=4, S32=11, S33=16, S34=23;\n    var S41=6, S42=10, S43=15, S44=21;\n\n    //\tstring = Utf8Encode(string); #function call removed\n\n    x = ConvertToWordArray(string);\n\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n    for (k=0;k<x.length;k+=16) {\n      AA=a; BB=b; CC=c; DD=d;\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n      a=AddUnsigned(a,AA);\n      b=AddUnsigned(b,BB);\n      c=AddUnsigned(c,CC);\n      d=AddUnsigned(d,DD);\n    }\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n    return temp.toLowerCase();\n  }\n})();\n\n// END Crypto.md5.js\n\n//----------------------------------------------------------------------\n//\n// ECMAScript 5 Polyfills\n//  from www.calocomrmen./polyfill/\n//\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n// ES5 15.2 Object Objects\n//----------------------------------------------------------------------\n\n\n\n// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )\n// Partial support for most common case - getters, setters, and values\n(function() {\n  if (!Object.defineProperty ||\n      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {\n    var orig = Object.defineProperty;\n    Object.defineProperty = function (o, prop, desc) {\n      \"use strict\";\n\n      // In IE8 try built-in implementation for defining properties on DOM prototypes.\n      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }\n\n      if (o !== Object(o)) { throw new TypeError(\"Object.defineProperty called on non-object\"); }\n      if (Object.prototype.__defineGetter__ && ('get' in desc)) {\n        Object.prototype.__defineGetter__.call(o, prop, desc.get);\n      }\n      if (Object.prototype.__defineSetter__ && ('set' in desc)) {\n        Object.prototype.__defineSetter__.call(o, prop, desc.set);\n      }\n      if ('value' in desc) {\n        o[prop] = desc.value;\n      }\n      return o;\n    };\n  }\n}());\n\n\n\n// ES5 15.2.3.14 Object.keys ( O )\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\nif (!Object.keys) {\n  Object.keys = function (o) {\n    if (o !== Object(o)) { throw new TypeError('Object.keys called on non-object'); }\n    var ret = [], p;\n    for (p in o) {\n      if (Object.prototype.hasOwnProperty.call(o, p)) {\n        ret.push(p);\n      }\n    }\n    return ret;\n  };\n}\n\n//----------------------------------------------------------------------\n// ES5 15.4 Array Objects\n//----------------------------------------------------------------------\n\n\n\n// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        fun.call(thisp, t[i], i, t);\n      }\n    }\n  };\n}\n\n\n// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\nif (!Array.prototype.map) {\n  Array.prototype.map = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var res = []; res.length = len;\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        res[i] = fun.call(thisp, t[i], i, t);\n      }\n    }\n\n    return res;\n  };\n}\n\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[ \"[object \" + typename + \"]\" ] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nvar type = function(obj) {\n  if (obj === null) {\n    return String( obj );\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n};\n\nvar isWindow = function(obj) {\n  return obj !== null && obj === obj.window;\n};\n\nvar isPlainObject = function( obj ) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n\n  var key;\n  for ( key in obj ) {}\n\n  return key === undefined || core_hasOwn.call( obj, key );\n};\n\nvar isFunction = function(obj) {\n  return type(obj) === \"function\";\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return type(obj) === \"array\";\n};\n\nvar extend = function() {\n  var options, name, src, copy, copyIsArray, clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if ( typeof target !== \"object\" && !isFunction(target) ) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if ( length === i ) {\n    target = this;\n    --i;\n  }\n\n  for ( ; i < length; i++ ) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[ i ]) != null) {\n      // Extend the base object\n      for ( name in options ) {\n        src = target[ name ];\n        copy = options[ name ];\n\n        // Prevent never-ending loop\n        if ( target === copy ) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = isArray(copy)) ) ) {\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && isArray(src) ? src : [];\n\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[ name ] = extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = extend;\n}\n\nvar ajax = function ajax(options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  var call = function(fun) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (typeof fun === typeof Function) {\n      fun.apply(this, args);\n    }\n  }; \n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000\n  };\n  options = extend(true, defaultOptions, options);\n  if (options.auth) {\n      var token = btoa(options.auth.username + ':' + options.auth.password);\n      options.headers.Authorization = 'Basic ' + token;\n  }\n  var onSuccess = function(obj, resp, cb){\n    if (!options.binary && !options.json && options.processData && typeof obj !== 'string') {\n      obj = JSON.stringify(obj);\n    } else if (!options.binary && options.json && typeof obj === 'string') {\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        call(cb, e);\n        return;\n      }\n    }\n    call(cb, null, obj, resp);\n  };\n  var onError = function(err, cb){\n    var errParsed;\n    var errObj = err.responseText ? {status: err.status} : err; //this seems too clever\n    try{\n      errParsed = JSON.parse(err.responseText); //would prefer not to have a try/catch clause\n      errObj = extend(true, {}, errObj, errParsed);\n    } catch(e){}\n    call(cb, errObj);\n  };\n  if (typeof window !== 'undefined' && window.XMLHttpRequest) {\n    var timer,timedout  = false;\n    var xhr = new XMLHttpRequest();\n    xhr.open(options.method, options.url);\n    if (options.json) {\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n      if (options.body && options.processData && typeof options.body !== \"string\") {\n        options.body = JSON.stringify(options.body);\n      }\n    }\n    if (options.binary) {\n      xhr.responseType = 'arraybuffer';\n    }\n    for (var key in options.headers){\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n    if (!(\"body\" in options)) {\n      options.body = null;\n    }\n\n    var abortReq = function() {\n        timedout=true;\n        xhr.abort();\n        call(onError, xhr, callback);\n    };\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState !== 4 || timedout) {\n        return;\n      }\n      clearTimeout(timer);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        var data;\n        if (options.binary) {\n          data = new Blob([xhr.response || ''], {type: xhr.getResponseHeader('Content-Type')});\n        } else {\n          data = xhr.responseText;\n        }\n        call(onSuccess, data, xhr, callback);\n      } else {\n         call(onError, xhr, callback);\n      }\n    };\n    if (options.timeout > 0) {\n      timer = setTimeout(abortReq, options.timeout);\n    }\n    xhr.send(options.body);\n    return {abort:abortReq};\n  } else {\n    if (options.json) {\n      if (!options.binary) {\n        options.headers.Accept = 'application/json';\n      }\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n    }\n    if (options.binary) {\n      options.encoding = null;\n      options.json = false;\n    }\n    if (!options.processData) {\n      options.json = false;\n    }\n    return request(options, function(err, response, body) {\n      if (err) {\n        err.status = response ? response.statusCode : 400;\n        return call(onError, err, callback);\n      }\n\n      var content_type = response.headers['content-type'];\n      var data = (body || '');\n\n      // CouchDB doesn't always return the right content-type for JSON data, so\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n      if (!options.binary && (options.json || !options.processData) && typeof data !== 'object' &&\n          (/json/.test(content_type) ||\n           (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n        data = JSON.parse(data);\n      }\n      \n      if (data.error) {\n        data.status = response.statusCode;\n        call(onError, data, callback);\n      }\n      else {\n        call(onSuccess, data, response, callback);\n      }\n    });\n  }\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = ajax;\n}\n/*globals PouchAdapter: true, extend: true */\n\n\"use strict\";\n\nvar Pouch = function Pouch(name, opts, callback) {\n\n  if (!(this instanceof Pouch)) {\n    return new Pouch(name, opts, callback);\n  }\n\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n\n  if (typeof callback === 'undefined') {\n    callback = function() {};\n  }\n\n  var backend = Pouch.parseAdapter(opts.name || name);\n  opts.originalName = name;\n  opts.name = opts.name || backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  if (!Pouch.adapters[opts.adapter]) {\n    throw 'Adapter is missing';\n  }\n\n  if (!Pouch.adapters[opts.adapter].valid()) {\n    throw 'Invalid Adapter';\n  }\n\n  var adapter = new PouchAdapter(opts, function(err, db) {\n    if (err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n\n    for (var plugin in Pouch.plugins) {\n      // In future these will likely need to be async to allow the plugin\n      // to initialise\n      var pluginObj = Pouch.plugins[plugin](db);\n      for (var api in pluginObj) {\n        // We let things like the http adapter use its own implementation\n        // as it shares a lot of code\n        if (!(api in db)) {\n          db[api] = pluginObj[api];\n        }\n      }\n    }\n    db.taskqueue.ready(true);\n    db.taskqueue.execute(db);\n    callback(null, db);\n  });\n  for (var j in adapter) {\n    this[j] = adapter[j];\n  }\n  for (var plugin in Pouch.plugins) {\n    // In future these will likely need to be async to allow the plugin\n    // to initialise\n    var pluginObj = Pouch.plugins[plugin](this);\n    for (var api in pluginObj) {\n      // We let things like the http adapter use its own implementation\n      // as it shares a lot of code\n      if (!(api in this)) {\n        this[api] = pluginObj[api];\n      }\n    }\n  }\n};\n\nPouch.DEBUG = false;\n\nPouch.adapters = {};\nPouch.plugins = {};\n\nPouch.parseAdapter = function(name) {\n\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    var adapter = match[1];\n    if (!Pouch.adapters[adapter].valid()) {\n      throw 'Invalid adapter';\n    }\n    return {name: name, adapter: match[1]};\n  }\n\n  var preferredAdapters = ['idb', 'leveldb', 'websql'];\n  for (var i = 0; i < preferredAdapters.length; ++i) {\n    if (preferredAdapters[i] in Pouch.adapters) {\n      return {\n        name: name,\n        adapter: preferredAdapters[i]\n      };\n    }\n  }\n\n  throw 'No valid adapter found';\n};\n\nPouch.destroy = function(name, callback) {\n  var opts = Pouch.parseAdapter(name);\n  var cb = function(err, response) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    for (var plugin in Pouch.plugins) {\n      Pouch.plugins[plugin]._delete(name);\n    }\n    if (Pouch.DEBUG) {\n      console.log(name + ': Delete Database');\n    }\n\n    // call destroy method of the particular adaptor\n    Pouch.adapters[opts.adapter].destroy(opts.name, callback);\n  };\n \n  // remove Pouch from allDBs\n  Pouch.removeFromAllDbs(opts, cb);\n};\n\nPouch.removeFromAllDbs = function(opts, callback) {\n  // Only execute function if flag is enabled\n  if (!Pouch.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  // skip http and https adaptors for allDbs\n  var adapter = opts.adapter;\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  // remove db from Pouch.ALL_DBS\n  new Pouch(Pouch.allDBName(opts.adapter), function(err, db) {\n    if (err) {\n      // don't fail when allDbs fail\n      console.log(err);\n      callback();\n      return;\n    }\n    // check if db has been registered in Pouch.ALL_DBS\n    var dbname = Pouch.dbName(opts.adapter, opts.name);\n    db.get(dbname, function(err, doc) {\n      if (err) {\n        callback();\n      } else {\n        db.remove(doc, function(err, response) {\n          if (err) {\n            console.log(err);\n          }\n          callback();\n        });\n      }\n    });\n  });\n \n};\n\nPouch.adapter = function (id, obj) {\n  if (obj.valid()) {\n    Pouch.adapters[id] = obj;\n  }\n};\n\nPouch.plugin = function(id, obj) {\n  Pouch.plugins[id] = obj;\n};\n\n// flag to toggle allDbs (off by default)\nPouch.enableAllDbs = false;\n\n// name of database used to keep track of databases\nPouch.ALL_DBS = \"_allDbs\";\nPouch.dbName = function(adapter, name) {\n  return [adapter, \"-\", name].join('');\n};\nPouch.realDBName = function(adapter, name) {\n  return [adapter, \"://\", name].join('');\n};\nPouch.allDBName = function(adapter) {\n  return [adapter, \"://\", Pouch.ALL_DBS].join('');\n};\n\nPouch.open = function(opts, callback) {\n  // Only register pouch with allDbs if flag is enabled\n  if (!Pouch.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  var adapter = opts.adapter;\n  // skip http and https adaptors for allDbs\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  new Pouch(Pouch.allDBName(adapter), function(err, db) {\n    if (err) {\n      // don't fail when allDb registration fails\n      console.log(err);\n      callback();\n      return;\n    }\n\n    // check if db has been registered in Pouch.ALL_DBS\n    var dbname = Pouch.dbName(adapter, opts.name);\n    db.get(dbname, function(err, response) {\n      if (err && err.status === 404) {\n        db.put({\n          _id: dbname,\n          dbname: opts.originalName \n        }, function(err) {\n            if (err) {\n                console.log(err);\n            }\n\n            callback();\n        });\n      } else {\n        callback();\n      }\n    });\n  });\n};\n\nPouch.allDbs = function(callback) {\n  var accumulate = function(adapters, all_dbs) {\n    if (adapters.length === 0) {\n      // remove duplicates\n      var result = [];\n      all_dbs.forEach(function(doc) {\n        var exists = result.some(function(db) {\n          return db.id === doc.id;\n        });\n\n        if (!exists) {\n          result.push(doc);\n        }\n      });\n\n      // return an array of dbname\n      callback(null, result.map(function(row) {\n          return row.doc.dbname;\n      }));\n      return;\n    }\n\n    var adapter = adapters.shift();\n\n    // skip http and https adaptors for allDbs\n    if (adapter === \"http\" || adapter === \"https\") {\n      accumulate(adapters, all_dbs);\n      return;\n    }\n\n    new Pouch(Pouch.allDBName(adapter), function(err, db) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      db.allDocs({include_docs: true}, function(err, response) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // append from current adapter rows\n        all_dbs.unshift.apply(all_dbs, response.rows);\n\n        // code to clear allDbs.\n        // response.rows.forEach(function(row) {\n        //   db.remove(row.doc, function() {\n        //     console.log(arguments);\n        //   });\n        // });\n\n        // recurse\n        accumulate(adapters, all_dbs);\n      });\n    });\n  };\n  var adapters = Object.keys(Pouch.adapters);\n  accumulate(adapters, []);\n};\n\n// Enumerate errors, add the status code so we can reflect the HTTP api\n// in future\nPouch.Errors = {\n  MISSING_BULK_DOCS: {\n    status: 400,\n    error: 'bad_request',\n    reason: \"Missing JSON list of 'docs'\"\n  },\n  MISSING_DOC: {\n    status: 404,\n    error: 'not_found',\n    reason: 'missing'\n  },\n  REV_CONFLICT: {\n    status: 409,\n    error: 'conflict',\n    reason: 'Document update conflict'\n  },\n  INVALID_ID: {\n    status: 400,\n    error: 'invalid_id',\n    reason: '_id field must contain a string'\n  },\n  MISSING_ID: {\n    status: 412,\n    error: 'missing_id',\n    reason: '_id is required for puts'\n  },\n  RESERVED_ID: {\n    status: 400,\n    error: 'bad_request',\n    reason: 'Only reserved document ids may start with underscore.'\n  },\n  NOT_OPEN: {\n    status: 412,\n    error: 'precondition_failed',\n    reason: 'Database not open so cannot close'\n  },\n  UNKNOWN_ERROR: {\n    status: 500,\n    error: 'unknown_error',\n    reason: 'Database encountered an unknown error'\n  },\n  INVALID_REQUEST: {\n    status: 400,\n    error: 'invalid_request',\n    reason: 'Request was invalid'\n  },\n  QUERY_PARSE_ERROR: {\n    status: 400,\n    error: 'query_parse_error',\n    reason: 'Some query parameter is invalid'\n  },\n  BAD_REQUEST: {\n    status: 400,\n    error: 'bad_request',\n    reason: 'Something wrong with the request'\n  }\n};\nPouch.error = function(error, reason){\n return extend({}, error, {reason: reason});\n};\nif (typeof module !== 'undefined' && module.exports) {\n  global.Pouch = Pouch;\n  Pouch.merge = require('./pouch.merge.js').merge;\n  Pouch.collate = require('./pouch.collate.js').collate;\n  Pouch.replicate = require('./pouch.replicate.js').replicate;\n  Pouch.utils = require('./pouch.utils.js');\n  extend = Pouch.utils.extend;\n  module.exports = Pouch;\n  var PouchAdapter = require('./pouch.adapter.js');\n  //load adapters known to work under node\n  var adapters = ['leveldb', 'http'];\n  adapters.map(function(adapter) {\n    var adapter_path = './adapters/pouch.'+adapter+'.js';\n    require(adapter_path);\n  });\n  require('./plugins/pouchdb.mapreduce.js');\n} else {\n  window.Pouch = Pouch;\n}\n\n'use strict';\n\n// a few hacks to get things in the right place for node.js\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n}\n\nvar stringCollate = function(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n};\n\nvar objectCollate = function(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = Pouch.collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = Pouch.collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n};\n\nvar arrayCollate = function(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = Pouch.collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n};\n\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\nvar collationIndex = function(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  if (id.indexOf(typeof x) !== -1) {\n    if (x === null) {\n      return 1;\n    }\n    return id.indexOf(typeof x) + 2;\n  }\n  if (Array.isArray(x)) {\n    return 4.5;\n  }\n};\n\nPouch.collate = function(a, b) {\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  if (typeof a === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'boolean') {\n    return a < b ? -1 : 1;\n  }\n  if (typeof a === 'string') {\n    return stringCollate(a, b);\n  }\n  if (Array.isArray(a)) {\n    return arrayCollate(a, b);\n  }\n  if (typeof a === 'object') {\n    return objectCollate(a, b);\n  }\n};\n/*globals rootToLeaf: false, extend: false */\n\n'use strict';\n\n// a few hacks to get things in the right place for node.js\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n  var utils = require('./pouch.utils.js');\n  for (var k in utils) {\n    global[k] = utils[k];\n  }\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\n// Turn a path as a flat array into a tree with a single branch\nfunction pathToTree(path) {\n  var doc = path.shift();\n  var root = [doc.id, doc.opts, []];\n  var leaf = root;\n  var nleaf;\n\n  while (path.length) {\n    doc = path.shift();\n    nleaf = [doc.id, doc.opts, []];\n    leaf[2].push(nleaf);\n    leaf = nleaf;\n  }\n  return root;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        tree1[2].push(tree2[2][i]);\n        tree1[2].sort();\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res, branch;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  tree.forEach(function(branch) {\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we want to\n      // merge.  If the keys match we return the longer path with the other merged\n      // After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        if (!item.ids) {\n          continue;\n        }\n        /*jshint loopfunc:true */\n        item.ids[2].forEach(function(el, idx) {\n          trees.push({ids: el, diff: item.diff-1, parent: item.ids, parentIdx: idx});\n        });\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  });\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(function(a, b) {\n    return a.pos - b.pos;\n  });\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths,\n  // we cut off the start of the path and generate a new set of flat trees\n  var stemmedPaths = rootToLeaf(tree).map(function(path) {\n    var stemmed = path.ids.slice(-depth);\n    return {\n      pos: path.pos + (path.ids.length - stemmed.length),\n      ids: pathToTree(stemmed)\n    };\n  });\n  // Then we remerge all those flat trees together, ensuring that we dont\n  // connect trees that would go beyond the depth limit\n  return stemmedPaths.reduce(function(prev, current, i, arr) {\n    return doMerge(prev, current, true).tree;\n  }, [stemmedPaths.shift()]);\n}\n\nPouch.merge = function(tree, path, depth) {\n  // Ugh, nicer way to not modify arguments in place?\n  tree = extend(true, [], tree);\n  path = extend(true, {}, path);\n  var newTree = doMerge(tree, path);\n  return {\n    tree: stem(newTree.tree, depth),\n    conflicts: newTree.conflicts\n  };\n};\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nPouch.merge.winningRev = function(metadata) {\n  var leafs = [];\n  Pouch.merge.traverseRevTree(metadata.rev_tree,\n                              function(isLeaf, pos, id, something, opts) {\n    if (isLeaf) {\n      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});\n    }\n  });\n  leafs.sort(function(a, b) {\n    if (a.deleted !== b.deleted) {\n      return a.deleted > b.deleted ? 1 : -1;\n    }\n    if (a.pos !== b.pos) {\n      return b.pos - a.pos;\n    }\n    return a.id < b.id ? 1 : -1;\n  });\n\n  return leafs[0].pos + '-' + leafs[0].id;\n};\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// Callback has signature function(isLeaf, pos, id, [context])\n// The return value from the callback will be passed as context to all\n// children of that node\nPouch.merge.traverseRevTree = function(revs, callback) {\n  var toVisit = [];\n\n  revs.forEach(function(tree) {\n    toVisit.push({pos: tree.pos, ids: tree.ids});\n  });\n  while (toVisit.length > 0) {\n    var node = toVisit.pop();\n    var pos = node.pos;\n    var tree = node.ids;\n    var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);\n    /*jshint loopfunc: true */\n    tree[2].forEach(function(branch) {\n      toVisit.push({pos: pos+1, ids: branch, ctx: newCtx});\n    });\n  }\n};\n\nPouch.merge.collectLeaves = function(revs) {\n  var leaves = [];\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.unshift({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(function(a, b) {\n    return b.pos - a.pos;\n  });\n  leaves.map(function(leaf) { delete leaf.pos; });\n  return leaves;\n};\n\n// returns all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nPouch.merge.collectConflicts = function(metadata) {\n  var win = Pouch.merge.winningRev(metadata);\n  var leaves = Pouch.merge.collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  leaves.forEach(function(leaf) {\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  });\n  return conflicts;\n};\n\n\n/*globals call: false, Crypto: false*/\n\n'use strict';\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\nvar Promise = function() {\n  this.cancelled = false;\n  this.cancel = function() {\n    this.cancelled = true;\n  };\n};\n\n// The RequestManager ensures that only one database request is active at\n// at time, it ensures we dont max out simultaneous HTTP requests and makes\n// the replication process easier to reason about\nvar RequestManager = function() {\n\n  var queue = [];\n  var api = {};\n  var processing = false;\n\n  // Add a new request to the queue, if we arent currently processing anything\n  // then process it immediately\n  api.enqueue = function(fun, args) {\n    queue.push({fun: fun, args: args});\n    if (!processing) {\n      api.process();\n    }\n  };\n\n  // Process the next request\n  api.process = function() {\n    if (processing || !queue.length) {\n      return;\n    }\n    processing = true;\n    var task = queue.shift();\n    task.fun.apply(null, task.args);\n  };\n\n  // We need to be notified whenever a request is complete to process\n  // the next request\n  api.notifyRequestComplete = function() {\n    processing = false;\n    api.process();\n  };\n\n  return api;\n};\n\n// TODO: check CouchDB's replication id generation, generate a unique id particular\n// to this replication\nvar genReplicationId = function(src, target, opts) {\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  return '_local/' + Crypto.MD5(src.id() + target.id() + filterFun);\n};\n\n// A checkpoint lets us restart replications from when they were last cancelled\nvar fetchCheckpoint = function(target, id, callback) {\n  target.get(id, function(err, doc) {\n    if (err && err.status === 404) {\n      callback(null, 0);\n    } else {\n      callback(null, doc.last_seq);\n    }\n  });\n};\n\nvar writeCheckpoint = function(target, id, checkpoint, callback) {\n  var check = {\n    _id: id,\n    last_seq: checkpoint\n  };\n  target.get(check._id, function(err, doc) {\n    if (doc && doc._rev) {\n      check._rev = doc._rev;\n    }\n    target.put(check, function(err, doc) {\n      callback();\n    });\n  });\n};\n\nfunction replicate(src, target, opts, promise) {\n\n  var requests = new RequestManager();\n  var writeQueue = [];\n  var repId = genReplicationId(src, target, opts);\n  var results = [];\n  var completed = false;\n  var pending = 0;\n  var last_seq = 0;\n  var continuous = opts.continuous || false;\n  var result = {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0\n  };\n\n  function docsWritten(err, res, len) {\n    requests.notifyRequestComplete();\n    if (opts.onChange) {\n      for (var i = 0; i < len; i++) {\n        /*jshint validthis:true */\n        opts.onChange.apply(this, [result]);\n      }\n    }\n    pending -= len;\n    result.docs_written += len;\n    isCompleted();\n  }\n\n  function writeDocs() {\n    if (!writeQueue.length) {\n      return requests.notifyRequestComplete();\n    }\n    var len = writeQueue.length;\n    target.bulkDocs({docs: writeQueue}, {new_edits: false}, function(err, res) {\n      docsWritten(err, res, len);\n    });\n    writeQueue = [];\n  }\n\n  function eachRev(id, rev) {\n    src.get(id, {revs: true, rev: rev, attachments: true}, function(err, doc) {\n      requests.notifyRequestComplete();\n      writeQueue.push(doc);\n      requests.enqueue(writeDocs);\n    });\n  }\n\n  function onRevsDiff(err, diffs) {\n    requests.notifyRequestComplete();\n    if (err) {\n      if (continuous) {\n        promise.cancel();\n      }\n      call(opts.complete, err, null);\n      return;\n    }\n\n    // We already have the full document stored\n    if (Object.keys(diffs).length === 0) {\n      pending--;\n      isCompleted();\n      return;\n    }\n\n    var _enqueuer = function (rev) {\n        requests.enqueue(eachRev, [id, rev]);\n    };\n\n    for (var id in diffs) {\n      diffs[id].missing.forEach(_enqueuer);\n    }\n  }\n\n  function fetchRevsDiff(diff) {\n    target.revsDiff(diff, onRevsDiff);\n  }\n\n  function onChange(change) {\n    last_seq = change.seq;\n    results.push(change);\n    result.docs_read++;\n    pending++;\n    var diff = {};\n    diff[change.id] = change.changes.map(function(x) { return x.rev; });\n    requests.enqueue(fetchRevsDiff, [diff]);\n  }\n\n  function complete() {\n    completed = true;\n    isCompleted();\n  }\n\n  function isCompleted() {\n    if (completed && pending === 0) {\n      result.end_time = Date.now();\n      writeCheckpoint(target, repId, last_seq, function(err, res) {\n        call(opts.complete, err, result);\n      });\n    }\n  }\n\n  fetchCheckpoint(target, repId, function(err, checkpoint) {\n\n    if (err) {\n      return call(opts.complete, err);\n    }\n\n    last_seq = checkpoint;\n\n    // Was the replication cancelled by the caller before it had a chance\n    // to start. Shouldnt we be calling complete?\n    if (promise.cancelled) {\n      return;\n    }\n\n    var repOpts = {\n      limit: 25,\n      continuous: continuous,\n      since: last_seq,\n      style: 'all_docs',\n      onChange: onChange,\n      complete: complete\n    };\n\n    if (opts.filter) {\n      repOpts.filter = opts.filter;\n    }\n\n    if (opts.query_params) {\n      repOpts.query_params = opts.query_params;\n    }\n\n    var changes = src.changes(repOpts);\n\n    if (opts.continuous) {\n      promise.cancel = changes.cancel;\n    }\n  });\n\n}\n\nfunction toPouch(db, callback) {\n  if (typeof db === 'string') {\n    return new Pouch(db, callback);\n  }\n  callback(null, db);\n}\n\nPouch.replicate = function(src, target, opts, callback) {\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  if (opts === undefined) {\n    opts = {};\n  }\n  opts.complete = callback;\n  var replicateRet = new Promise();\n  toPouch(src, function(err, src) {\n    if (err) {\n      return call(callback, err);\n    }\n    toPouch(target, function(err, target) {\n      if (err) {\n        return call(callback, err);\n      }\n      replicate(src, target, opts, replicateRet);\n    });\n  });\n  return replicateRet;\n};\n\n/*jshint strict: false */\n/*global request: true, Buffer: true, escape: true, $:true */\n/*global extend: true, Crypto: true */\n/*global chrome*/\n\n// Pretty dumb name for a function, just wraps callback calls so we dont\n// to if (callback) callback() everywhere\nvar call = function(fun) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (typeof fun === typeof Function) {\n    fun.apply(this, args);\n  }\n};\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nvar yankError = function(callback) {\n  return function(err, results) {\n    if (err || results[0].error) {\n      call(callback, err || results[0]);\n    } else {\n      call(callback, null, results[0]);\n    }\n  };\n};\n\nvar isLocalId = function(id) {\n  return (/^_local/).test(id);\n};\n\nvar isAttachmentId = function(id) {\n  return (/\\//.test(id) && !isLocalId(id) && !/^_design/.test(id));\n};\n\n// Parse document ids: docid[/attachid]\n//   - /attachid is optional, and can have slashes in it too\n//   - int ids and strings beginning with _design or _local are not split\n// returns an object: { docId: docid, attachmentId: attachid }\nvar parseDocId = function(id) {\n  var ids = (typeof id === 'string') && !(/^_(design|local)\\//.test(id)) ?\n    id.split('/') : [id];\n  return {\n    docId: ids[0],\n    attachmentId: ids.splice(1).join('/').replace(/^\\/+/, '')\n  };\n};\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\n//   - any other string value is a valid id\nvar isValidId = function(id) {\n  if (/^_/.test(id)) {\n    return (/^_(design|local)/).test(id);\n  }\n  return true;\n};\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nvar parseDoc = function(doc, newEdits) {\n  var error = null;\n\n  // check for an attachment id and add attachments as needed\n  if (doc._id) {\n    var id = parseDocId(doc._id);\n    if (id.attachmentId !== '') {\n      var attachment = btoa(JSON.stringify(doc));\n      doc = {_id: id.docId};\n      if (!doc._attachments) {\n        doc._attachments = {};\n      }\n      doc._attachments[id.attachmentId] = {\n        content_type: 'application/json',\n        data: attachment\n      };\n    }\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = Math.uuid();\n    }\n    newRevId = Math.uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      if (!revInfo) {\n        throw \"invalid value for property '_rev'\";\n      }\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], {}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = parseInt(revInfo[1], 10) + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = [{\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\n        ids: doc._revisions.ids.reduce(function(acc, x) {\n          if (acc === null) {\n            return [x, opts, []];\n          } else {\n            return [x, {}, [acc]];\n          }\n        }, null)\n      }];\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      nRevNum = parseInt(revInfo[1], 10);\n      newRevId = revInfo[2];\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], opts, []]\n      }];\n    }\n  }\n\n  if (typeof doc._id !== 'string') {\n    error = Pouch.Errors.INVALID_ID;\n  }\n  else if (!isValidId(doc._id)) {\n    error = Pouch.Errors.RESERVED_ID;\n  }\n\n  doc._id = decodeURIComponent(doc._id);\n  doc._rev = [nRevNum, newRevId].join('-');\n\n  if (error) {\n    return error;\n  }\n\n  return Object.keys(doc).reduce(function(acc, key) {\n    if (/^_/.test(key) && key !== '_attachments') {\n      acc.metadata[key.slice(1)] = doc[key];\n    } else {\n      acc.data[key] = doc[key];\n    }\n    return acc;\n  }, {metadata : {}, data : {}});\n};\n\nvar compareRevs = function(a, b) {\n  // Sort by id\n  if (a.id !== b.id) {\n    return (a.id < b.id ? -1 : 1);\n  }\n  // Then by deleted\n  if (a.deleted ^ b.deleted) {\n    return (a.deleted ? -1 : 1);\n  }\n  // Then by rev id\n  if (a.rev_tree[0].pos === b.rev_tree[0].pos) {\n    return (a.rev_tree[0].ids < b.rev_tree[0].ids ? -1 : 1);\n  }\n  // Then by depth of edits\n  return (a.rev_tree[0].start < b.rev_tree[0].start ? -1 : 1);\n};\n\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nvar computeHeight = function(revs) {\n  var height = {};\n  var edges = [];\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function(edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n};\n\n// returns first element of arr satisfying callback predicate\nvar arrayFirst = function(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n  return false;\n};\n\nvar filterChange = function(opts) {\n  return function(change) {\n    var req = {};\n    req.query = opts.query_params;\n    if (opts.filter && !opts.filter.call(this, change.doc, req)) {\n      return;\n    }\n    if (!opts.include_docs) {\n      delete change.doc;\n    }\n    call(opts.onChange, change);\n  };\n};\n\n// returns array of all branches from root to leaf in the ids form:\n// [[id, ...], ...]\nvar rootToLeaf = function(tree) {\n  var paths = [];\n  Pouch.merge.traverseRevTree(tree, function(isLeaf, pos, id, history, opts) {\n    history = history ? history.slice(0) : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      var rootPos = pos + 1 - history.length;\n      paths.unshift({pos: rootPos, ids: history});\n    }\n    return history;\n  });\n  return paths;\n};\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nvar isDeleted = function(metadata, rev) {\n  if (!rev) {\n    rev = Pouch.merge.winningRev(metadata);\n  }\n  if (rev.indexOf('-') >= 0) {\n    rev = rev.split('-')[1];\n  }\n  var deleted = false;\n  Pouch.merge.traverseRevTree(metadata.rev_tree, function(isLeaf, pos, id, acc, opts) {\n    if (id === rev) {\n      deleted = !!opts.deleted;\n    }\n  });\n\n  return deleted;\n};\n\nvar isChromeApp = function(){\n  return (typeof chrome !== \"undefined\" && typeof chrome.storage !== \"undefined\" && typeof chrome.storage.local !== \"undefined\");\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  // use node.js's crypto library instead of the Crypto object created by deps/uuid.js\n  var crypto = require('crypto');\n  var Crypto = {\n    MD5: function(str) {\n      return crypto.createHash('md5').update(str).digest('hex');\n    }\n  };\n  var extend = require('./deps/extend');\n  var ajax = require('./deps/ajax');\n\n  request = require('request');\n  _ = require('underscore');\n  $ = _;\n\n  module.exports = {\n    Crypto: Crypto,\n    call: call,\n    yankError: yankError,\n    isLocalId: isLocalId,\n    isAttachmentId: isAttachmentId,\n    parseDocId: parseDocId,\n    parseDoc: parseDoc,\n    isDeleted: isDeleted,\n    compareRevs: compareRevs,\n    computeHeight: computeHeight,\n    arrayFirst: arrayFirst,\n    filterChange: filterChange,\n    atob: function(str) {\n      return decodeURIComponent(escape(new Buffer(str, 'base64').toString('binary')));\n    },\n    btoa: function(str) {\n      return new Buffer(unescape(encodeURIComponent(str)), 'binary').toString('base64');\n    },\n    extend: extend,\n    ajax: ajax,\n    rootToLeaf: rootToLeaf,\n    isChromeApp: isChromeApp\n  };\n}\n\nvar Changes = function() {\n\n  var api = {};\n  var listeners = {};\n\n  if (isChromeApp()){\n    chrome.storage.onChanged.addListener(function(e){\n      api.notify(e.db_name.newValue);//object only has oldValue, newValue members\n    });\n  }\n  else {\n    window.addEventListener(\"storage\", function(e) {\n      api.notify(e.key);\n    });\n  }\n\n  api.addListener = function(db_name, id, db, opts) {\n    if (!listeners[db_name]) {\n      listeners[db_name] = {};\n    }\n    listeners[db_name][id] = {\n      db: db,\n      opts: opts\n    };\n  };\n\n  api.removeListener = function(db_name, id) {\n    delete listeners[db_name][id];\n  };\n\n  api.clearListeners = function(db_name) {\n    delete listeners[db_name];\n  };\n\n  api.notifyLocalWindows = function(db_name){\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (!isChromeApp()){\n      localStorage[db_name] = (localStorage[db_name] === \"a\") ? \"b\" : \"a\";\n    } else {\n      chrome.storage.local.set({db_name: db_name});\n    }\n  };\n\n  api.notify = function(db_name) {\n    if (!listeners[db_name]) { return; }\n\n    Object.keys(listeners[db_name]).forEach(function (i) {\n      var opts = listeners[db_name][i].opts;\n      listeners[db_name][i].db.changes({\n        include_docs: opts.include_docs,\n        conflicts: opts.conflicts,\n        continuous: false,\n        descending: false,\n        filter: opts.filter,\n        since: opts.since,\n        query_params: opts.query_params,\n        onChange: function(c) {\n          if (c.seq > opts.since && !opts.cancelled) {\n            opts.since = c.seq;\n            call(opts.onChange, c);\n          }\n        }\n      });\n    });\n  };\n\n  return api;\n};\n\n\n/*globals Pouch: true, yankError: false, extend: false, call: false, parseDocId: false, traverseRevTree: false */\n/*globals arrayFirst: false, rootToLeaf: false, computeHeight: false */\n\n\"use strict\";\n\n/*\n * A generic pouch adapter\n */\nvar PouchAdapter = function(opts, callback) {\n\n  var api = {};\n\n  var customApi = Pouch.adapters[opts.adapter](opts, function(err, db) {\n    if (err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n\n    for (var j in api) {\n      if (!db.hasOwnProperty(j)) {\n        db[j] = api[j];\n      }\n    }\n\n    // Don't call Pouch.open for ALL_DBS\n    // Pouch.open saves the db's name into ALL_DBS\n    if (opts.name === Pouch.ALL_DBS) {\n      callback(err, db);\n    } else {\n      Pouch.open(opts, function(err) {\n        callback(err, db);\n      });\n    }\n  });\n\n  var auto_compaction = (opts.auto_compaction === true);\n\n  // wraps a callback with a function that runs compaction after each edit\n  var autoCompact = function(callback) {\n    if (!auto_compaction) {\n      return callback;\n    }\n    return function(err, res) {\n      if (err) {\n        call(callback, err);\n      } else {\n        var count = res.length;\n        var decCount = function() {\n          count--;\n          if (!count) {\n            call(callback, null, res);\n          }\n        };\n        res.forEach(function(doc) {\n          if (doc.ok) {\n            // TODO: we need better error handling\n            compactDocument(doc.id, 1, decCount);\n          } else {\n            decCount();\n          }\n        });\n      }\n    };\n  };\n\n  api.post = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return customApi.bulkDocs({docs: [doc]}, opts,\n        autoCompact(yankError(callback)));\n  };\n\n  api.put = function(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n    return customApi.bulkDocs({docs: [doc]}, opts,\n        autoCompact(yankError(callback)));\n  };\n\n  api.putAttachment = function (id, rev, blob, type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    if (typeof type === 'undefined') {\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    id = parseDocId(id);\n\n    function createAttachment(doc) {\n      doc._attachments = doc._attachments || {};\n      doc._attachments[id.attachmentId] = {\n        content_type: type,\n        data: blob\n      };\n      api.put(doc, callback);\n    }\n\n    api.get(id.docId, function(err, doc) {\n      // create new doc\n      if (err && err.error === Pouch.Errors.MISSING_DOC.error) {\n        createAttachment({_id: id.docId});\n        return;\n      }\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (doc._rev !== rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      createAttachment(doc);\n    });\n  };\n\n  api.removeAttachment = function (id, rev, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, function(err, obj) {\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (obj._rev !== rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      obj._attachments = obj._attachments || {};\n      delete obj._attachments[id.attachmentId];\n      api.put(obj, callback);\n    });\n  };\n\n  api.remove = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (opts === undefined) {\n      opts = {};\n    }\n    opts.was_delete = true;\n    var newDoc = extend(true, {}, doc);\n    newDoc._deleted = true;\n    return customApi.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n  };\n\n  api.revsDiff = function (req, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ids = Object.keys(req);\n    var count = 0;\n    var missing = {};\n\n    function readDoc(err, doc, id) {\n      req[id].map(function(revId) {\n        var matches = function(x) { return x.rev !== revId; };\n        if (!doc || doc._revs_info.every(matches)) {\n          if (!missing[id]) {\n            missing[id] = {missing: []};\n          }\n          missing[id].missing.push(revId);\n        }\n      });\n\n      if (++count === ids.length) {\n        return call(callback, null, missing);\n      }\n    }\n\n    ids.map(function(id) {\n      api.get(id, {revs_info: true}, function(err, doc) {\n        readDoc(err, doc, id);\n      });\n    });\n  };\n\n  // compact one document and fire callback\n  // by compacting we mean removing all revisions which\n  // are further from the leaf in revision tree than max_height\n  var compactDocument = function(docId, max_height, callback) {\n    customApi._getRevisionTree(docId, function(err, rev_tree){\n      if (err) {\n        return call(callback);\n      }\n      var height = computeHeight(rev_tree);\n      var nonLeaves = [];\n      Object.keys(height).forEach(function(rev) {\n        if (height[rev] > max_height) {\n          nonLeaves.push(rev);\n        }\n      });\n      customApi._removeDocRevisions(docId, nonLeaves, callback);\n    });\n  };\n\n  // compact the whole database using single document\n  // compaction\n  api.compact = function(callback) {\n    api.allDocs(function(err, res) {\n      var count = res.rows.length;\n      if (!count) {\n        call(callback);\n        return;\n      }\n      res.rows.forEach(function(row) {\n        compactDocument(row.key, 0, function() {\n          count--;\n          if (!count) {\n            call(callback);\n          }\n        });\n      });\n    });\n  };\n\n  /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\n  api.get = function (id, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('get', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var leaves = [];\n    function finishOpenRevs() {\n      var result = [];\n      var count = leaves.length;\n      if (!count) {\n        return call(callback, null, result);\n      }\n      // order with open_revs is unspecified\n      leaves.forEach(function(leaf){\n        api.get(id, {rev: leaf, revs: opts.revs}, function(err, doc){\n          if (!err) {\n            result.push({ok: doc});\n          } else {\n            result.push({missing: leaf});\n          }\n          count--;\n          if(!count) {\n            call(callback, null, result);\n          }\n        });\n      });\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs === \"all\") {\n        customApi._getRevisionTree(id, function(err, rev_tree){\n          if (err) {\n            // if there's no such document we should treat this\n            // situation the same way as if revision tree was empty\n            rev_tree = [];\n          }\n          leaves = Pouch.merge.collectLeaves(rev_tree).map(function(leaf){\n            return leaf.rev;\n          });\n          finishOpenRevs();\n        });\n      } else {\n        if (Array.isArray(opts.open_revs)) {\n          leaves = opts.open_revs;\n          for (var i = 0; i < leaves.length; i++) {\n            var l = leaves[i];\n            // looks like it's the only thing couchdb checks\n            if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\n              return call(callback, Pouch.error(Pouch.Errors.BAD_REQUEST,\n                \"Invalid rev format\" ));\n            }\n          }\n          finishOpenRevs();\n        } else {\n          return call(callback, Pouch.error(Pouch.Errors.UNKNOWN_ERROR,\n            'function_clause'));\n        }\n      }\n      return; // open_revs does not like other options\n    }\n\n    id = parseDocId(id);\n    if (id.attachmentId !== '') {\n      return customApi.getAttachment(id, callback);\n    }\n    return customApi._get(id, opts, function(result, metadata) {\n      if ('error' in result) {\n        return call(callback, result);\n      }\n\n      var doc = result;\n      function finish() {\n        call(callback, null, doc);\n      }\n\n      if (opts.conflicts) {\n        var conflicts = Pouch.merge.collectConflicts(metadata);\n        if (conflicts.length) {\n          doc._conflicts = conflicts;\n        }\n      }\n\n      if (opts.revs || opts.revs_info) {\n        var paths = rootToLeaf(metadata.rev_tree);\n        paths.map(function(path, i) {\n          paths[i].ids = path.ids.map(function(x) { return x.id; });\n        });\n        var path = arrayFirst(paths, function(arr) {\n          return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\n        });\n        path.ids.splice(path.ids.indexOf(doc._rev.split('-')[1]) + 1);\n        path.ids.reverse();\n\n        if (opts.revs) {\n          doc._revisions = {\n            start: (path.pos + path.ids.length) - 1,\n            ids: path.ids\n          };\n        }\n        if (opts.revs_info) {\n          // TODO: it could be slow to test status like this\n          var count = path.ids.length;\n          var pos = path.pos + path.ids.length - 1;\n          doc._revs_info = [];\n\n          path.ids.forEach(function(hash) {\n            var rev = pos + '-' + hash;\n            var info = {\n              rev: rev,\n              status: \"available\"\n            };\n            pos--;\n            doc._revs_info.push(info);\n\n            api.get(id.docId, {rev: rev}, function(err, ok) {\n              if (err) {\n                info.status = \"missing\";\n              }\n              count--;\n              if (!count) {\n                finish();\n              }\n            });\n          });\n        } else {\n          finish();\n        }\n      } else {\n        finish();\n      }\n\n    });\n  };\n\n  api.getAttachment = function(id, opts, callback) {\n    if (opts instanceof Function) {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof id === 'string') {\n      id = parseDocId(id);\n    }\n\n    return customApi._getAttachment(id, opts, callback);\n  };\n\n  api.allDocs = function(opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('allDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if ('keys' in opts) {\n      if ('startkey' in opts) {\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\n          'Query parameter `start_key` is not compatible with multi-get'\n        ));\n        return;\n      }\n      if ('endkey' in opts) {\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\n          'Query parameter `end_key` is not compatible with multi-get'\n        ));\n        return;\n      }\n    }\n\n    return customApi._allDocs(opts, callback);\n  };\n\n  api.changes = function(opts) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('changes', arguments);\n      return;\n    }\n    opts = extend(true, {}, opts);\n\n    // 0 and 1 should return 1 document\n    opts.limit = opts.limit === 0 ? 1 : opts.limit;\n    return customApi._changes(opts);\n  };\n\n  api.close = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('close', arguments);\n      return;\n    }\n    return customApi._close(callback);\n  };\n\n  api.info = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('info', arguments);\n      return;\n    }\n    return customApi._info(callback);\n  };\n\n  api.id = function() {\n    return customApi._id();\n  };\n\n  api.type = function() {\n    return (typeof customApi._type === 'function') ? customApi._type() : opts.adapter;\n  };\n\n  api.bulkDocs = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('bulkDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    } else {\n      opts = extend(true, {}, opts);\n    }\n\n    if (!req || !req.docs || req.docs.length < 1) {\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\n    }\n\n    if (!Array.isArray(req.docs)) {\n      return call(callback, Pouch.Errors.QUERY_PARSE_ERROR);\n    }\n\n    req = extend(true, {}, req);\n    if (!('new_edits' in opts)) {\n      opts.new_edits = true;\n    }\n\n    return customApi._bulkDocs(req, opts, autoCompact(callback));\n  };\n\n  /* End Wrappers */\n  var taskqueue = {};\n\n  taskqueue.ready = false;\n  taskqueue.queue = [];\n\n  api.taskqueue = {};\n\n  api.taskqueue.execute = function (db) {\n    if (taskqueue.ready) {\n      taskqueue.queue.forEach(function(d) {\n        db[d.task].apply(null, d.parameters);\n      });\n    }\n  };\n\n  api.taskqueue.ready = function() {\n    if (arguments.length === 0) {\n      return taskqueue.ready;\n    }\n    taskqueue.ready = arguments[0];\n  };\n\n  api.taskqueue.addTask = function(task, parameters) {\n    taskqueue.queue.push({ task: task, parameters: parameters });\n  };\n\n  api.replicate = {};\n\n  api.replicate.from = function (url, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, customApi, opts, callback);\n  };\n\n  api.replicate.to = function (dbName, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(customApi, dbName, opts, callback);\n  };\n\n  for (var j in api) {\n    if (!customApi.hasOwnProperty(j)) {\n      customApi[j] = api[j];\n    }\n  }\n\n  // Http adapter can skip setup so we force the db to be ready and execute any jobs\n  if (opts.skipSetup) {\n    api.taskqueue.ready(true);\n    api.taskqueue.execute(api);\n  }\n\n  return customApi;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = PouchAdapter;\n}\n\n/*globals Pouch: true, call: false, ajax: true */\n/*globals require: false, console: false */\n\n\"use strict\";\n\nvar HTTP_TIMEOUT = 10000;\n\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nfunction parseUri (str) {\n  var o = parseUri.options;\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    uri[o.key[i]] = m[i] || \"\";\n  }\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) {\n      uri[o.q.name][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name) {\n  // If the given name contains \"http:\"\n  if (/http(s?):/.test(name)) {\n    // Prase the URI into all its little bits\n    var uri = parseUri(name);\n\n    // Store the fact that it is a remote URI\n    uri.remote = true;\n\n    // Store the user and password as a separate auth object\n    if (uri.user || uri.password) {\n      uri.auth = {username: uri.user, password: uri.password};\n    }\n\n    // Split the path part of the URI into parts using '/' as the delimiter\n    // after removing any leading '/' and any trailing '/'\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n    // Store the first part as the database name and remove it from the parts\n    // array\n    uri.db = parts.pop();\n\n    // Restore the path by joining all the remaining parts (all the parts\n    // except for the database name) with '/'s\n    uri.path = parts.join('/');\n\n    return uri;\n  }\n\n  // If the given name does not contain 'http:' then return a very basic object\n  // with no host, the current path, the given name as the database name and no\n  // username/password\n  return {host: '', path: '/', db: name, auth: false};\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  // If the host is remote\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // Return the URL made up of all the host's information and the given path\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\n      opts.path + pathDel + opts.db + '/' + path;\n  }\n\n  // If the host is not remote, then return the URL made up of just the\n  // database name and the given path\n  return '/' + opts.db + '/' + path;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  if (opts.remote) {\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + path;\n  }\n  return '/' + path;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nvar HttpPouch = function(opts, callback) {\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var host = getHost(opts.name);\n  if (opts.auth) {\n    host.auth = opts.auth;\n  }\n\n  // Generate the database URL based on the host\n  var db_url = genDBUrl(host, '');\n\n  // The functions that will be publically available for HttpPouch\n  var api = {};\n\n  var uuids = {\n    list: [],\n    get: function(opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {count: 10};\n      }\n      var cb = function(err, body) {\n        if (err || !('uuids' in body)) {\n          call(callback, err || Pouch.Errors.UNKNOWN_ERROR);\n        } else {\n          uuids.list = uuids.list.concat(body.uuids);\n          call(callback, null, \"OK\");\n        }\n      };\n      var params = '?count=' + opts.count;\n      ajax({\n        auth: host.auth,\n        method: 'GET',\n        url: genUrl(host, '_uuids') + params\n      }, cb);\n    }\n  };\n\n  // Create a new CouchDB database based on the given opts\n  var createDB = function(){\n    ajax({auth: host.auth, method: 'PUT', url: db_url}, function(err, ret) {\n      // If we get an \"Unauthorized\" error\n      if (err && err.status === 401) {\n        // Test if the database already exists\n        ajax({auth: host.auth, method: 'HEAD', url: db_url}, function (err, ret) {\n          // If there is still an error\n          if (err) {\n            // Give the error to the callback to deal with\n            call(callback, err);\n          } else {\n            // Continue as if there had been no errors\n            call(callback, null, api);\n          }\n        });\n        // If there were no errros or if the only error is \"Precondition Failed\"\n        // (note: \"Precondition Failed\" occurs when we try to create a database\n        // that already exists)\n      } else if (!err || err.status === 412) {\n        // Continue as if there had been no errors\n        call(callback, null, api);\n      } else {\n        call(callback, Pouch.Errors.UNKNOWN_ERROR);\n      }\n    });\n  };\n  if (!opts.skipSetup) {\n    ajax({auth: host.auth, method: 'GET', url: db_url}, function(err, ret) {\n      //check if the db exists\n      if (err) {\n        if (err.status === 404) {\n          //if it doesn't, create it\n          createDB();\n        } else {\n          call(callback, err);\n        }\n      } else {\n        //go do stuff with the db\n        call(callback, null, api);\n        }\n    });\n  }\n\n  api.type = function() {\n    return 'http';\n  };\n\n  // The HttpPouch's ID is its URL\n  api.id = function() {\n    return genDBUrl(host, '');\n  };\n\n  api.request = function(options, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('request', arguments);\n      return;\n    }\n    options.auth = host.auth;\n    options.url = genDBUrl(host, options.url);\n    ajax(options, callback);\n  };\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = function(opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('compact', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    ajax({\n      auth: host.auth,\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function() {\n      function ping() {\n        api.info(function(err, res) {\n          if (!res.compact_running) {\n            call(callback, null);\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      if (typeof callback === \"function\") {\n        ping();\n      }\n    });\n  };\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api.info = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('info', arguments);\n      return;\n    }\n    ajax({\n      auth: host.auth,\n      method:'GET',\n      url: genDBUrl(host, '')\n    }, callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = function(id, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('get', arguments);\n      return;\n    }\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // If it exists, add the opts.revs value to the list of parameters.\n    // If revs=true then the resulting JSON will include a field\n    // _revisions containing an array of the revision IDs.\n    if (opts.revs) {\n      params.push('revs=true');\n    }\n\n    // If it exists, add the opts.revs_info value to the list of parameters.\n    // If revs_info=true then the resulting JSON will include the field\n    // _revs_info containing an array of objects in which each object\n    // representing an available revision.\n    if (opts.revs_info) {\n      params.push('revs_info=true');\n    }\n\n    // If it exists, add the opts.open_revs value to the list of parameters.\n    // If open_revs=all then the resulting JSON will include all the leaf\n    // revisions. If open_revs=[\"rev1\", \"rev2\",...] then the resulting JSON\n    // will contain an array of objects containing data of all revisions\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.push('open_revs=' + opts.open_revs);\n    }\n\n    // If it exists, add the opts.attachments value to the list of parameters.\n    // If attachments=true the resulting JSON will include the base64-encoded\n    // contents in the \"data\" property of each attachment.\n    if (opts.attachments) {\n      params.push('attachments=true');\n    }\n\n    // If it exists, add the opts.rev value to the list of parameters.\n    // If rev is given a revision number then get the specified revision.\n    if (opts.rev) {\n      params.push('rev=' + opts.rev);\n    }\n\n    // If it exists, add the opts.conflicts value to the list of parameters.\n    // If conflicts=true then the resulting JSON will include the field\n    // _conflicts containing all the conflicting revisions.\n    if (opts.conflicts) {\n      params.push('conflicts=' + opts.conflicts);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // Set the options for the ajax call\n    var options = {\n      auth: host.auth,\n      method: 'GET',\n      url: genDBUrl(host, id + params)\n    };\n\n    // If the given id contains at least one '/' and the part before the '/'\n    // is NOT \"_design\" and is NOT \"_local\"\n    // OR\n    // If the given id contains at least two '/' and the part before the first\n    // '/' is \"_design\".\n    // TODO This second condition seems strange since if parts[0] === '_design'\n    // then we already know that parts[0] !== '_local'.\n    var parts = id.split('/');\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\n      // Binary is expected back from the server\n      options.binary = true;\n    }\n\n    // Get the document\n    ajax(options, function(err, doc, xhr) {\n      // If the document does not exist, send an error to the callback\n      if (err) {\n        return call(callback, err);\n      }\n\n      // Send the document to the callback\n      call(callback, null, doc, xhr);\n    });\n  };\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('remove', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Delete the document\n    ajax({\n      auth: host.auth,\n      method:'DELETE',\n      url: genDBUrl(host, doc._id) + '?rev=' + doc._rev\n    }, callback);\n  };\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('removeAttachment', arguments);\n      return;\n    }\n    ajax({\n      auth: host.auth,\n      method: 'DELETE',\n      url: genDBUrl(host, id) + '?rev=' + rev\n    }, callback);\n  };\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = function(id, rev, blob, type, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('putAttachment', arguments);\n      return;\n    }\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    if (typeof type === 'undefined') {\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    // Add the attachment\n    ajax({\n      auth: host.auth,\n      method:'PUT',\n      url: url,\n      headers: {'Content-Type': type},\n      processData: false,\n      body: blob\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This fails if the doc has no _id field.\n  api.put = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('put', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n\n    // List of parameter to add to the PUT request\n    var params = [];\n\n    // If it exists, add the opts.new_edits value to the list of parameters.\n    // If new_edits = false then the database will NOT assign this document a\n    // new revision number\n    if (opts && typeof opts.new_edits !== 'undefined') {\n      params.push('new_edits=' + opts.new_edits);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Add the document\n    ajax({\n      auth: host.auth,\n      method: 'PUT',\n      url: genDBUrl(host, doc._id) + params,\n      body: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This does not assume that doc is a new document (i.e. does not\n  // have a _id or a _rev field.\n  api.post = function(doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('post', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (! (\"_id\" in doc)) {\n      if (uuids.list.length > 0) {\n        doc._id = uuids.list.pop();\n        api.put(doc, opts, callback);\n      }else {\n        uuids.get(function(err, resp) {\n          if (err) {\n            return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n          }\n          doc._id = uuids.list.pop();\n          api.put(doc, opts, callback);\n        });\n      }\n    } else {\n      api.put(doc, opts, callback);\n    }\n  };\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api.bulkDocs = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('bulkDocs', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    }\n\n    // If opts.new_edits exists add it to the document data to be\n    // send to the database.\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    if (typeof opts.new_edits !== 'undefined') {\n      req.new_edits = opts.new_edits;\n    }\n\n    // Update/create the documents\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_bulk_docs'),\n      body: req\n    }, callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = function(opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('allDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // TODO I don't see conflicts as a valid parameter for a\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.descending is truthy add it to params\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.include_docs exists, add the include_docs value to the\n    // list of parameters.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs) {\n      params.push('include_docs=true');\n    }\n\n    // If opts.startkey exists, add the startkey value to the list of\n    // parameters.\n    // If startkey is given then the returned list of documents will\n    // start with the document whose id is startkey.\n    if (opts.startkey) {\n      params.push('startkey=' +\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n\n    // If opts.endkey exists, add the endkey value to the list of parameters.\n    // If endkey is given then the returned list of docuemnts will\n    // end with the document whose id is endkey.\n    if (opts.endkey) {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys:opts.keys});\n    }\n\n    // Get the document listing\n    ajax({\n      auth: host.auth,\n      method: method,\n      url: genDBUrl(host, '_all_docs' + params),\n      body: body\n    }, callback);\n  };\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api.changes = function(opts) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('changes', arguments);\n      return;\n    }\n\n    if (Pouch.DEBUG) {\n      console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    // Query string of all the parameters to add to the GET request\n    var params = [],\n        paramsStr;\n\n    if (opts.style) {\n      params.push('style='+opts.style);\n    }\n\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\n    // function, add the include_docs value to the query string.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.push('include_docs=true');\n    }\n\n    // If opts.continuous exists, add the feed value to the query string.\n    // If feed=longpoll then it waits for either a timeout or a change to\n    // occur before returning.\n    if (opts.continuous) {\n      params.push('feed=longpoll');\n    }\n\n    // If opts.conflicts exists, add the conflicts value to the query string.\n    // TODO I can't find documentation of what conflicts=true does. See\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    if (opts.limit || opts.limit === 0) {\n      params.push('limit=' + opts.limit);\n    }\n\n    // If opts.descending exists, add the descending value to the query string.\n    // if descending=true then the change results are returned in\n    // descending order (most recent change first).\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.filter exists and is a string then add the filter value\n    // to the query string.\n    // If filter is given a string containing the name of a filter in\n    // the design, then only documents passing through the filter will\n    // be returned.\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.push('filter=' + opts.filter);\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params.push(param_name+'='+opts.query_params[param_name]);\n        }\n      }\n    }\n\n    paramsStr = '?';\n\n    if (params.length > 0) {\n      paramsStr += params.join('&');\n    }\n\n    var xhr;\n    var last_seq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function(since, callback) {\n      // Set the options for the ajax call\n      var xhrOpts = {\n        auth: host.auth, method:'GET',\n        url: genDBUrl(host, '_changes' + paramsStr + '&since=' + since),\n        timeout: null          // _changes can take a long time to generate, especially when filtered\n      };\n      last_seq = since;\n\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      xhr = ajax(xhrOpts, callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var fetchTimeout = 10;\n    var fetchRetryCount = 0;\n    var fetched = function(err, res) {\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        // For each change\n        res.results.forEach(function(c) {\n          var hasFilter = opts.filter && typeof opts.filter === 'function';\n          var req = {};\n          req.query = opts.query_params;\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc, req])) {\n            return;\n          }\n\n          // Process the change\n          call(opts.onChange, c);\n        });\n      }\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        last_seq = res.last_seq;\n      }\n\n      if (opts.continuous) {\n        // Increase retry delay exponentially as long as errors persist\n        if (err) {\n          fetchRetryCount += 1;\n        } else {\n          fetchRetryCount = 0;\n        }\n        var timeoutMultiplier = 1 << fetchRetryCount;\n        // i.e. Math.pow(2, fetchRetryCount)\n\n        var retryWait = fetchTimeout * timeoutMultiplier;\n        var maximumWait = opts.maximumWait || 30000;\n        if (retryWait > maximumWait) {\n          call(opts.complete, err || Pouch.Errors.UNKNOWN_ERROR, null);\n        }\n\n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () {\n          fetch(last_seq, fetched);\n        }, retryWait);\n      } else {\n        // We're done, call the callback\n        call(opts.complete, null, res);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function() {\n        if (Pouch.DEBUG) {\n          console.log(db_url + ': Cancel Changes Feed');\n        }\n        opts.aborted = true;\n        xhr.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = function(req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('revsDiff', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, function(err, res) {\n      call(callback, err, res);\n    });\n  };\n\n  api.close = function(callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('close', arguments);\n      return;\n    }\n    call(callback, null);\n  };\n\n  return api;\n};\n\n// Delete the HttpPouch specified by the given name.\nHttpPouch.destroy = function(name, callback) {\n  var host = getHost(name);\n  ajax({auth: host.auth, method: 'DELETE', url: genDBUrl(host, '')}, callback);\n};\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function() {\n  return true;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  // running in node\n  var pouchdir = '../';\n  Pouch = require(pouchdir + 'pouch.js');\n  ajax = Pouch.utils.ajax;\n}\n\n// Set HttpPouch to be the adapter used with the http scheme.\nPouch.adapter('http', HttpPouch);\nPouch.adapter('https', HttpPouch);\n\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\n\n'use strict';\n\n// While most of the IDB behaviors match between implementations a\n// lot of the names still differ. This section tries to normalize the\n// different objects & methods.\nvar indexedDB = window.indexedDB ||\n  window.mozIndexedDB ||\n  window.webkitIndexedDB;\n\n// still needed for R/W transactions in Android Chrome. follow MDN example:\n// https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#transaction\n// note though that Chrome Canary fails on undefined READ_WRITE constants\n// on the native IDBTransaction object\nvar IDBTransaction = (window.IDBTransaction && window.IDBTransaction.READ_WRITE) ?\n  window.IDBTransaction :\n  (window.webkitIDBTransaction && window.webkitIDBTransaction.READ_WRITE) ?\n    window.webkitIDBTransaction :\n    { READ_WRITE: 'readwrite' };\n\nvar IDBKeyRange = window.IDBKeyRange ||\n  window.webkitIDBKeyRange;\n\nwindow.storageInfo = window.storageInfo ||\n  window.webkitStorageInfo;\n\nwindow.requestFileSystem = window.requestFileSystem ||\n    window.webkitRequestFileSystem;\n\nvar idbError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar IdbPouch = function(opts, callback) {\n\n  // IndexedDB requires a versioned database structure, this is going to make\n  // it hard to dynamically create object stores if we needed to for things\n  // like views\n  var POUCH_VERSION = 1;\n\n  // The object stores created for each database\n  // DOC_STORE stores the document meta data, its revision history and state\n  var DOC_STORE = 'document-store';\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\n  // sequence id\n  var BY_SEQ_STORE = 'by-sequence';\n  // Where we store attachments\n  var ATTACH_STORE = 'attach-store';\n  // Where we store meta data\n  var META_STORE = 'meta-store';\n  // Where we detect blob support\n  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\n\n  var name = opts.name;\n  var req = indexedDB.open(name, POUCH_VERSION);\n  var meta = {\n    id: 'meta-store',\n    updateSeq: 0\n  };\n\n  var blobSupport = null;\n\n  var instanceId = null;\n  var api = {};\n  var idb = null;\n\n  if (Pouch.DEBUG) {\n    console.log(name + ': Open Database');\n  }\n\n  req.onupgradeneeded = function(e) {\n    var db = e.target.result;\n    var currentVersion = e.oldVersion;\n    while (currentVersion !== e.newVersion) {\n      if (currentVersion === 0) {\n        createSchema(db);\n      }\n      currentVersion++;\n    }\n  };\n\n  function createSchema(db) {\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\n      .createIndex('seq', 'seq', {unique: true});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n  }\n\n  req.onsuccess = function(e) {\n\n    idb = e.target.result;\n\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],\n                              IDBTransaction.READ_WRITE);\n\n    idb.onversionchange = function() {\n      idb.close();\n    };\n\n    // polyfill the new onupgradeneeded api for chrome. can get rid of when\n    // saucelabs moves to chrome 23\n    if (idb.setVersion && Number(idb.version) !== POUCH_VERSION) {\n      var versionReq = idb.setVersion(POUCH_VERSION);\n      versionReq.onsuccess = function(evt) {\n        function setVersionComplete() {\n          req.onsuccess(e);\n        }\n        evt.target.result.oncomplete = setVersionComplete;\n        req.onupgradeneeded(e);\n      };\n      return;\n    }\n\n    var req = txn.objectStore(META_STORE).get('meta-store');\n\n    req.onsuccess = function(e) {\n      var reqDBId,\n          result;\n\n      if (e.target.result) {\n        meta = e.target.result;\n      }\n\n      if (name + '_id' in meta) {\n        instanceId = meta[name + '_id'];\n      } else {\n        instanceId = Math.uuid();\n\n        meta[name + '_id'] = instanceId;\n        reqDBId = txn.objectStore(META_STORE).put(meta);\n      }\n\n      // detect blob support\n      try {\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(new Blob(), \"key\");\n        blobSupport = true;\n      } catch (err) {\n        blobSupport = false;\n      } finally {\n        call(callback, null, api);\n      }\n    };\n  };\n\n  req.onerror = idbError(callback);\n\n  api.type = function() {\n    return 'idb';\n  };\n\n  // Each database needs a unique id so that we can store the sequence\n  // checkpoint without having other databases confuse itself.\n  api.id = function idb_id() {\n    return instanceId;\n  };\n\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function(docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return call(callback, docInfoErrors[0]);\n    }\n\n    var results = [];\n    var docs = [];\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function processDocs() {\n      if (!docs.length) {\n        return;\n      }\n      var currentDoc = docs.shift();\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\n      req.onsuccess = function process_docRead(event) {\n        var oldDoc = event.target.result;\n        if (!oldDoc) {\n          insertDoc(currentDoc);\n        } else {\n          updateDoc(oldDoc, currentDoc);\n        }\n      };\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = Pouch.merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (isLocalId(metadata.id)) {\n          return;\n        }\n\n        IdbPouch.Changes.notify(name);\n        IdbPouch.Changes.notifyLocalWindows(name);\n      });\n      call(callback, null, aresults);\n    }\n\n    function preprocessAttachment(att, callback) {\n      if (att.stub) {\n        return callback();\n      }\n      if (typeof att.data === 'string') {\n        var data = atob(att.data);\n        att.digest = 'md5-' + Crypto.MD5(data);\n        if (blobSupport) {\n          var type = att.content_type;\n          att.data = new Blob([data], {type: type});\n        }\n        return callback();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function(e) {\n        att.digest = 'md5-' + Crypto.MD5(this.result);\n        if (!blobSupport) {\n          att.data = btoa(this.result);\n        }\n        callback();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      docInfos.forEach(function(docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        var recv = 0;\n        function attachmentProcessed() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback) {\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      meta.updateSeq++;\n      var req = txn.objectStore(META_STORE).put(meta);\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      function finish() {\n        docInfo.data._doc_id_rev = docInfo.data._id + \"::\" + docInfo.data._rev;\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\n        dataReq.onsuccess = function(e) {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Wrote Document ', docInfo.metadata.id);\n          }\n          docInfo.metadata.seq = e.target.result;\n          // Current _rev is calculated from _rev_tree on read\n          delete docInfo.metadata.rev;\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\n          metaDataReq.onsuccess = function() {\n            results.push(docInfo);\n            call(callback);\n          };\n        };\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var wasPreviouslyDeleted = isDeleted(oldDoc);\n      var inConflict = (wasPreviouslyDeleted && isDeleted(docInfo.metadata)) ||\n        (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs);\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var objectStore = txn.objectStore(ATTACH_STORE);\n      var getReq = objectStore.get(digest).onsuccess = function(e) {\n        var originalRefs = e.target.result && e.target.result.refs || {};\n        var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n        var newAtt = {\n          digest: digest,\n          body: data,\n          refs: originalRefs\n        };\n        newAtt.refs[ref] = true;\n        var putReq = objectStore.put(newAtt).onsuccess = function(e) {\n          call(callback);\n        };\n      };\n    }\n\n    var txn;\n    preprocessAttachments(function() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],\n                            IDBTransaction.READ_WRITE);\n      txn.onerror = idbError(callback);\n      txn.ontimeout = idbError(callback);\n      txn.oncomplete = complete;\n\n      processDocs();\n    });\n  };\n\n  function sortByBulkSeq(a, b) {\n    return a._bulk_seq - b._bulk_seq;\n  }\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var result;\n    var metadata;\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n    txn.oncomplete = function() {\n      call(callback, result, metadata);\n    };\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      metadata = e.target.result;\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        result = Pouch.Errors.MISSING_DOC;\n        return;\n      }\n      if (isDeleted(metadata) && !opts.rev) {\n        result = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\n        return;\n      }\n\n      var rev = Pouch.merge.winningRev(metadata);\n      var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);\n      var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n\n      index.get(key).onsuccess = function(e) {\n        var doc = e.target.result;\n        if(doc && doc._doc_id_rev) {\n          delete(doc._doc_id_rev);\n        }\n        if (!doc) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n        if (opts.attachments && doc._attachments) {\n          var attachments = Object.keys(doc._attachments);\n          var recv = 0;\n\n          attachments.forEach(function(key) {\n            api.getAttachment(doc._id + '/' + key, {encode: true, txn: txn}, function(err, data) {\n              doc._attachments[key].data = data;\n\n              if (++recv === attachments.length) {\n                result = doc;\n              }\n            });\n          });\n        } else {\n          if (doc._attachments){\n            for (var key in doc._attachments) {\n              doc._attachments[key].stub = true;\n            }\n          }\n          result = doc;\n        }\n      };\n    };\n  };\n\n  api._getAttachment = function(id, opts, callback) {\n    var result;\n    var txn;\n\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      txn = opts.txn;\n    } else {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      txn.oncomplete = function() { call(callback, null, result); };\n    }\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      var metadata = e.target.result;\n      var bySeq = txn.objectStore(BY_SEQ_STORE);\n      bySeq.get(metadata.seq).onsuccess = function(e) {\n        var attachment = e.target.result._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type;\n\n        txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {\n          var data = e.target.result.body;\n          if (opts.encode) {\n            if (blobSupport) {\n              var reader = new FileReader();\n              reader.onloadend = function(e) {\n                result = btoa(this.result);\n\n                if ('txn' in opts) {\n                  call(callback, null, result);\n                }\n              };\n              reader.readAsBinaryString(data);\n            } else {\n              result = data;\n\n              if ('txn' in opts) {\n                call(callback, null, result);\n              }\n            }\n          } else {\n            if (blobSupport) {\n              result = data;\n            } else {\n              result = new Blob([atob(data)], {type: type});\n            }\n            if ('txn' in opts) {\n              call(callback, null, result);\n            }\n          }\n        };\n      };\n    };\n    return;\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var keyRange = start && end ? IDBKeyRange.bound(start, end)\n      : start ? IDBKeyRange.lowerBound(start)\n      : end ? IDBKeyRange.upperBound(end) : null;\n\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\n    transaction.oncomplete = function() {\n      if ('keys' in opts) {\n        opts.keys.forEach(function(key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      call(callback, null, {\n        total_rows: results.length,\n        rows: results\n      });\n    };\n\n    var oStore = transaction.objectStore(DOC_STORE);\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\n      : oStore.openCursor(keyRange);\n    var results = [];\n    var resultsMap = {};\n    oCursor.onsuccess = function(e) {\n      if (!e.target.result) {\n        return;\n      }\n      var cursor = e.target.result;\n      var metadata = cursor.value;\n      // If opts.keys is set we want to filter here only those docs with\n      // key in opts.keys. With no performance tests it is difficult to\n      // guess if iteration with filter is faster than many single requests\n      function allDocsInner(metadata, data) {\n        if (isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n        var doc = {\n          id: metadata.id,\n          key: metadata.id,\n          value: {\n            rev: Pouch.merge.winningRev(metadata)\n          }\n        };\n        if (opts.include_docs) {\n          doc.doc = data;\n          doc.doc._rev = Pouch.merge.winningRev(metadata);\n          if (doc.doc._doc_id_rev) {\n              delete(doc.doc._doc_id_rev);\n          }\n          if (opts.conflicts) {\n            doc.doc._conflicts = Pouch.merge.collectConflicts(metadata)\n              .map(function(x) { return x.id; });\n          }\n        }\n        if ('keys' in opts) {\n          if (opts.keys.indexOf(metadata.id) > -1) {\n            if (isDeleted(metadata)) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            }\n            resultsMap[doc.id] = doc;\n          }\n        } else {\n          if(!isDeleted(metadata)) {\n            results.push(doc);\n          }\n        }\n        cursor['continue']();\n      }\n\n      if (!opts.include_docs) {\n        allDocsInner(metadata);\n      } else {\n        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        var mainRev = Pouch.merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        index.get(key).onsuccess = function(event) {\n          allDocsInner(cursor.value, event.target.result);\n        };\n      }\n    };\n  };\n\n  // Looping through all the documents in the database is a terrible idea\n  // easiest to implement though, should probably keep a counter\n  api._info = function idb_info(callback) {\n    var count = 0;\n    var result;\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n\n    txn.oncomplete = function() {\n      callback(null, result);\n    };\n\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = function(e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          result = {\n            db_name: name,\n            doc_count: count,\n            update_seq: meta.updateSeq\n          };\n          return;\n        }\n        if (cursor.value.deleted !== true) {\n          count++;\n        }\n        cursor['continue']();\n      };\n  };\n\n  api._changes = function idb_changes(opts) {\n    if (Pouch.DEBUG) {\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    if (!opts.since) {\n      opts.since = 0;\n    }\n\n    if (opts.continuous) {\n      var id = name + ':' + Math.uuid();\n      opts.cancelled = false;\n      IdbPouch.Changes.addListener(name, id, api, opts);\n      IdbPouch.Changes.notify(name);\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Cancel Changes Feed');\n          }\n          opts.cancelled = true;\n          IdbPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var txn;\n\n    function fetchChanges() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\n      txn.oncomplete = onTxnComplete;\n\n      var req;\n\n      if (opts.limit && descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true), descending);\n      } else if (opts.limit && !descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true));\n      } else if (descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true), descending);\n      } else {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true));\n      }\n\n      req.onsuccess = onsuccess;\n      req.onerror = onerror;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        /*jshint evil: true */\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n\n    function onsuccess(event) {\n      if (!event.target.result) {\n        // Filter out null results casued by deduping\n        for (var i = 0, l = results.length; i < l; i++ ) {\n          var result = results[i];\n          if (result) {\n            dedupResults.push(result);\n          }\n        }\n        return false;\n      }\n\n      var cursor = event.target.result;\n\n      // Try to pre-emptively dedup to save us a bunch of idb calls\n      var changeId = cursor.value._id;\n      var changeIdIndex = resultIndices[changeId];\n      if (changeIdIndex !== undefined) {\n        results[changeIdIndex].seq = cursor.key;\n        // update so it has the later sequence number\n        results.push(results[changeIdIndex]);\n        results[changeIdIndex] = null;\n        resultIndices[changeId] = results.length - 1;\n        return cursor['continue']();\n      }\n\n      var index = txn.objectStore(DOC_STORE);\n      index.get(cursor.value._id).onsuccess = function(event) {\n        var metadata = event.target.result;\n        if (isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n\n        var mainRev = Pouch.merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        index.get(key).onsuccess = function(docevent) {\n          var doc = docevent.target.result;\n          var changeList = [{rev: mainRev}];\n          if (opts.style === 'all_docs') {\n            changeList = Pouch.merge.collectLeaves(metadata.rev_tree)\n              .map(function(x) { return {rev: x.rev}; });\n          }\n          var change = {\n            id: metadata.id,\n            seq: cursor.key,\n            changes: changeList,\n            doc: doc\n          };\n\n          if (isDeleted(metadata, mainRev)) {\n            change.deleted = true;\n          }\n          if (opts.conflicts) {\n            change.doc._conflicts = Pouch.merge.collectConflicts(metadata)\n              .map(function(x) { return x.id; });\n          }\n\n          // Dedupe the changes feed\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\n          if (changeIdIndex !== undefined) {\n            results[changeIdIndex] = null;\n          }\n          results.push(change);\n          resultIndices[changeId] = results.length - 1;\n          cursor['continue']();\n        };\n      };\n    }\n\n    function onTxnComplete() {\n      dedupResults.map(filterChange(opts));\n      call(opts.complete, null, {results: dedupResults});\n    }\n\n    function onerror(error) {\n      // TODO: shouldn't we pass some params here?\n      call(opts.complete);\n    }\n  };\n\n  api._close = function(callback) {\n    if (idb === null) {\n      return call(callback, Pouch.Errors.NOT_OPEN);\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    call(callback, null);\n  };\n\n  // compaction internal functions\n  api._getRevisionTree = function(docId, callback) {\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = event.target.result;\n      if (!doc) {\n        call(callback, Pouch.Errors.MISSING_DOC);\n      } else {\n        call(callback, null, doc.rev_tree);\n      }\n    };\n  };\n\n  api._removeDocRevisions = function(docId, revs, callback) {\n    var txn = idb.transaction([BY_SEQ_STORE], IDBTransaction.READ_WRITE);\n    var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n    revs.forEach(function(rev) {\n      var key = docId + \"::\" + rev;\n      index.getKey(key).onsuccess = function(e) {\n        var seq = e.target.result;\n        if (!seq) {\n          return;\n        }\n        var req = txn.objectStore(BY_SEQ_STORE)['delete'](seq);\n      };\n    });\n    txn.oncomplete = function() {\n      callback();\n    };\n  };\n  // end of compaction internal functions\n\n  return api;\n};\n\nIdbPouch.valid = function idb_valid() {\n  return !!indexedDB;\n};\n\nIdbPouch.destroy = function idb_destroy(name, callback) {\n  if (Pouch.DEBUG) {\n    console.log(name + ': Delete Database');\n  }\n  IdbPouch.Changes.clearListeners(name);\n  var req = indexedDB.deleteDatabase(name);\n\n  req.onsuccess = function() {\n    call(callback, null);\n  };\n\n  req.onerror = idbError(callback);\n};\n\nIdbPouch.Changes = new Changes();\n\nPouch.adapter('idb', IdbPouch);\n\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\n\n'use strict';\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar POUCH_VERSION = 1;\nvar POUCH_SIZE = 5 * 1024 * 1024;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE = quote('attach-store');\nvar META_STORE = quote('metadata-store');\n\nvar unknownError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar webSqlPouch = function(opts, callback) {\n\n  var api = {};\n  var update_seq = 0;\n  var instanceId = null;\n  var name = opts.name;\n\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  if (!db) {\n    return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n  }\n\n  function dbCreated() {\n    callback(null, api);\n  }\n\n  db.transaction(function (tx) {\n    var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\n      ' (update_seq, dbid)';\n    var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\n      ' (digest, json, body BLOB)';\n    var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\n      ' (id unique, seq, json, winningseq)';\n    var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\n      ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json)';\n\n    tx.executeSql(attach);\n    tx.executeSql(doc);\n    tx.executeSql(seq);\n    tx.executeSql(meta);\n\n    var updateseq = 'SELECT update_seq FROM ' + META_STORE;\n    tx.executeSql(updateseq, [], function(tx, result) {\n      if (!result.rows.length) {\n        var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\n        var newId = Math.uuid();\n        tx.executeSql(initSeq, [0]);\n        return;\n      }\n      update_seq = result.rows.item(0).update_seq;\n    });\n    var dbid = 'SELECT dbid FROM ' + META_STORE;\n    tx.executeSql(dbid, [], function(tx, result) {\n      if (!result.rows.length) {\n        var initDb = 'INSERT INTO ' + META_STORE + ' (dbid) VALUES (?)';\n        var newId = Math.uuid();\n        tx.executeSql(initDb, [newId]);\n        return;\n      }\n      instanceId = result.rows.item(0).dbid;\n    });\n  }, unknownError(callback), dbCreated);\n\n  api.type = function() {\n    return 'websql';\n  };\n\n  api.id = function() {\n    return instanceId;\n  };\n\n  api._info = function(callback) {\n    db.transaction(function(tx) {\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\n      tx.executeSql(sql, [], function(tx, result) {\n        callback(null, {\n          db_name: name,\n          doc_count: result.rows.item(0).count,\n          update_seq: update_seq\n        });\n      });\n    });\n  };\n\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\n\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function(docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return call(callback, docInfoErrors[0]);\n    }\n\n    var tx;\n    var results = [];\n    var docs = [];\n    var fetchedDocs = {};\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function sortByBulkSeq(a, b) {\n      return a._bulk_seq - b._bulk_seq;\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = Pouch.merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (isLocalId(metadata.id)) {\n          return;\n        }\n\n        update_seq++;\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\n        tx.executeSql(sql, [update_seq], function() {\n          webSqlPouch.Changes.notify(name);\n          webSqlPouch.Changes.notifyLocalWindows(name);\n        });\n      });\n      call(callback, null, aresults);\n    }\n\n    function preprocessAttachment(att, callback) {\n      if (att.stub) {\n        return callback();\n      }\n      if (typeof att.data === 'string') {\n        att.data = atob(att.data);\n        att.digest = 'md5-' + Crypto.MD5(att.data);\n        return callback();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function(e) {\n        att.data = this.result;\n        att.digest = 'md5-' + Crypto.MD5(this.result);\n        callback();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      var recv = 0;\n\n      docInfos.forEach(function(docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        function processedAttachment() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], processedAttachment);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback, isUpdate) {\n\n      function finish() {\n        var data = docInfo.data;\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (doc_id_rev, json) VALUES (?, ?);';\n        tx.executeSql(sql, [data._id + \"::\" + data._rev,\n                            JSON.stringify(data)], dataWritten);\n      }\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n\n      function dataWritten(tx, result) {\n        var seq = docInfo.metadata.seq = result.insertId;\n        delete docInfo.metadata.rev;\n\n        var mainRev = Pouch.merge.winningRev(docInfo.metadata);\n\n        var sql = isUpdate ?\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +\n          BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json) VALUES (?, ?, ?, ?);';\n        var metadataStr = JSON.stringify(docInfo.metadata);\n        var key = docInfo.metadata.id + \"::\" + mainRev;\n        var params = isUpdate ?\n          [seq, metadataStr, key, docInfo.metadata.id] :\n          [docInfo.metadata.id, seq, seq, metadataStr];\n        tx.executeSql(sql, params, function(tx, result) {\n          results.push(docInfo);\n          call(callback, null);\n        });\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs, true);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs, false);\n    }\n\n    function processDocs() {\n      if (!docs.length) {\n        return complete();\n      }\n      var currentDoc = docs.shift();\n      var id = currentDoc.metadata.id;\n      if (id in fetchedDocs) {\n        updateDoc(fetchedDocs[id], currentDoc);\n      } else {\n        // if we have newEdits=false then we can update the same\n        // document twice in a single bulk docs call\n        fetchedDocs[id] = currentDoc.metadata;\n        insertDoc(currentDoc);\n      }\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n      var newAtt = {digest: digest};\n      var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';\n      tx.executeSql(sql, [digest], function(tx, result) {\n        if (!result.rows.length) {\n          newAtt.refs = {};\n          newAtt.refs[ref] = true;\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function() {\n            call(callback, null);\n          });\n        } else {\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';\n          tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function() {\n            call(callback, null);\n          });\n        }\n      });\n    }\n\n    function metadataFetched(tx, results) {\n      for (var j=0; j<results.rows.length; j++) {\n        var row = results.rows.item(j);\n        fetchedDocs[row.id] = JSON.parse(row.json);\n      }\n      processDocs();\n    }\n\n    preprocessAttachments(function() {\n      db.transaction(function(txn) {\n        tx = txn;\n        var ids = '(' + docs.map(function(d) {\n          return quote(d.metadata.id);\n        }).join(',') + ')';\n        var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\n        tx.executeSql(sql, [], metadataFetched);\n      }, unknownError(callback));\n    });\n  };\n\n  api._get = function(id, opts, callback) {\n    var result;\n    var metadata;\n    db.transaction(function(tx) {\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\n      tx.executeSql(sql, [id.docId], function(tx, results) {\n        if (!results.rows.length) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n        metadata = JSON.parse(results.rows.item(0).json);\n        if (isDeleted(metadata) && !opts.rev) {\n          result = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\n          return;\n        }\n\n        var rev = Pouch.merge.winningRev(metadata);\n        var key = opts.rev ? opts.rev : rev;\n        key = metadata.id + '::' + key;\n        var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';\n        tx.executeSql(sql, [key], function(tx, results) {\n          if (!results.rows.length) {\n            result = Pouch.Errors.MISSING_DOC;\n            return;\n          }\n          var doc = JSON.parse(results.rows.item(0).json);\n\n          if (opts.attachments && doc._attachments) {\n            var attachments = Object.keys(doc._attachments);\n            var recv = 0;\n            attachments.forEach(function(key) {\n              api.getAttachment(doc._id + '/' + key, {encode: true, txn: tx}, function(err, data) {\n                doc._attachments[key].data = data;\n                if (++recv === attachments.length) {\n                  result = doc;\n                }\n              });\n            });\n          } else {\n            if (doc._attachments){\n              for (var key in doc._attachments) {\n                doc._attachments[key].stub = true;\n              }\n            }\n            result = doc;\n          }\n        });\n      });\n    }, unknownError(callback), function () {\n      call(callback, result, metadata);\n    });\n  };\n\n  function makeRevs(arr) {\n    return arr.map(function(x) { return {rev: x.rev}; });\n  }\n  function makeIds(arr) {\n    return arr.map(function(x) { return x.id; });\n  }\n\n  api._allDocs = function(opts, callback) {\n    var results = [];\n    var resultsMap = {};\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n      DOC_STORE + '.winningseq';\n\n    if ('keys' in opts) {\n      sql += ' WHERE ' + DOC_STORE + '.id IN (' + opts.keys.map(function(key){\n        return quote(key);\n      }).join(',') + ')';\n    } else {\n      if (start) {\n        sql += ' WHERE ' + DOC_STORE + '.id >= \"' + start + '\"';\n      }\n      if (end) {\n        sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= \"' + end + '\"';\n      }\n      sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\n    }\n\n    db.transaction(function(tx) {\n      tx.executeSql(sql, [], function(tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++ ) {\n          var doc = result.rows.item(i);\n          var metadata = JSON.parse(doc.metadata);\n          var data = JSON.parse(doc.data);\n          if (!(isLocalId(metadata.id))) {\n            doc = {\n              id: metadata.id,\n              key: metadata.id,\n              value: {rev: Pouch.merge.winningRev(metadata)}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = Pouch.merge.winningRev(metadata);\n              if (opts.conflicts) {\n                doc.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\n              }\n            }\n            if ('keys' in opts) {\n              if (opts.keys.indexOf(metadata.id) > -1) {\n                if (isDeleted(metadata)) {\n                  doc.value.deleted = true;\n                  doc.doc = null;\n                }\n                resultsMap[doc.id] = doc;\n              }\n            } else {\n              if(!isDeleted(metadata)) {\n                results.push(doc);\n              }\n            }\n          }\n        }\n      });\n    }, unknownError(callback), function() {\n      if ('keys' in opts) {\n        opts.keys.forEach(function(key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      call(callback, null, {\n        total_rows: results.length,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function idb_changes(opts) {\n\n    if (Pouch.DEBUG) {\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n    }\n\n    if (!opts.since) {\n      opts.since = 0;\n    }\n\n    if (opts.continuous) {\n      var id = name + ':' + Math.uuid();\n      opts.cancelled = false;\n      webSqlPouch.Changes.addListener(name, id, api, opts);\n      webSqlPouch.Changes.notify(name);\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG) {\n            console.log(name + ': Cancel Changes Feed');\n          }\n          opts.cancelled = true;\n          webSqlPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var txn;\n\n    function fetchChanges() {\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\n\n      if (opts.limit) {\n        sql += ' LIMIT ' + opts.limit;\n      }\n\n      db.transaction(function(tx) {\n        tx.executeSql(sql, [], function(tx, result) {\n          for (var i = 0, l = result.rows.length; i < l; i++ ) {\n            var doc = result.rows.item(i);\n            var metadata = JSON.parse(doc.metadata);\n            if (!isLocalId(metadata.id)) {\n              var change = {\n                id: metadata.id,\n                seq: doc.seq,\n                changes: makeRevs(Pouch.merge.collectLeaves(metadata.rev_tree)),\n                doc: JSON.parse(doc.data)\n              };\n              change.doc._rev = Pouch.merge.winningRev(metadata);\n              if (isDeleted(metadata, change.doc._rev)) {\n                change.deleted = true;\n              }\n              if (opts.conflicts) {\n                change.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\n              }\n              results.push(change);\n            }\n          }\n          for (i = 0, l = results.length; i < l; i++ ) {\n            result = results[i];\n            if (result) {\n              dedupResults.push(result);\n            }\n          }\n          dedupResults.map(filterChange(opts));\n\n          call(opts.complete, null, {results: dedupResults});\n        });\n      });\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        /*jshint evil: true */\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n  };\n\n  api._getAttachment = function(id, opts, callback) {\n\n    var res;\n    function fetchAttachment(tx) {\n      var sql = 'SELECT ' + BY_SEQ_STORE + '.json AS data FROM ' + DOC_STORE +\n        ' JOIN ' + BY_SEQ_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' + DOC_STORE +\n        '.seq WHERE ' + DOC_STORE + '.id = \"' + id.docId + '\"' ;\n      tx.executeSql(sql, [], function(tx, result) {\n        var doc = JSON.parse(result.rows.item(0).data);\n        var attachment = doc._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type;\n        var sql = 'SELECT body FROM ' + ATTACH_STORE + ' WHERE digest=?';\n        tx.executeSql(sql, [digest], function(tx, result) {\n          var data = result.rows.item(0).body;\n          if (opts.encode) {\n            res = btoa(data);\n          } else {\n            res = new Blob([data], {type: type});\n          }\n          if ('txn' in opts) {\n            call(callback, null, res);\n          }\n        });\n      });\n    }\n\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      fetchAttachment(opts.txn);\n    } else {\n      db.transaction(fetchAttachment, unknownError(callback), function() {\n        call(callback, null, res);\n      });\n    }\n  };\n  // comapction internal functions\n  api._getRevisionTree = function(docId, callback) {\n    db.transaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function(tx, result) {\n        if (!result.rows.length) {\n          call(callback, Pouch.Errors.MISSING_DOC);\n        } else {\n          var data = JSON.parse(result.rows.item(0).metadata);\n          call(callback, null, data.rev_tree);\n        }\n      });\n    });\n  };\n  api._removeDocRevisions = function(docId, revs, callback) {\n    db.transaction(function (tx) {\n      var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +\n        revs.map(function(rev){return quote(docId + '::' + rev);}).join(',') + ')';\n      console.log(sql);\n      tx.executeSql(sql, [], function(tx, result) {\n        callback();\n      });\n    });\n  };\n  // end of compaction internal functions\n\n  return api;\n};\n\nwebSqlPouch.valid = function() {\n  return !!window.openDatabase;\n};\n\nwebSqlPouch.destroy = function(name, callback) {\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  db.transaction(function (tx) {\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\n  }, unknownError(callback), function() {\n    call(callback, null);\n  });\n};\n\nwebSqlPouch.Changes = new Changes();\n\nPouch.adapter('websql', webSqlPouch);\n\n/*global Pouch: true */\n\n\"use strict\";\n\n// This is the first implementation of a basic plugin, we register the\n// plugin object with pouch and it is mixin'd to each database created\n// (regardless of adapter), adapters can override plugins by providing\n// their own implementation. functions on the plugin object that start\n// with _ are reserved function that are called by pouchdb for special\n// notifications.\n\n// If we wanted to store incremental views we can do it here by listening\n// to the changes feed (keeping track of our last update_seq between page loads)\n// and storing the result of the map function (possibly using the upcoming\n// extracted adapter functions)\n\nvar MapReduce = function(db) {\n\n  function viewQuery(fun, options) {\n    if (!options.complete) {\n      return;\n    }\n\n    if (!fun.reduce) {\n      options.reduce = false;\n    }\n\n    function sum(values) {\n      return values.reduce(function(a, b) { return a + b; }, 0);\n    }\n\n    var results = [];\n    var current = null;\n    var num_started= 0;\n    var completed= false;\n\n    var emit = function(key, val) {\n      var viewRow = {\n        id: current.doc._id,\n        key: key,\n        value: val\n      };\n\n      if (options.startkey && Pouch.collate(key, options.startkey) < 0) return;\n      if (options.endkey && Pouch.collate(key, options.endkey) > 0) return;\n      if (options.key && Pouch.collate(key, options.key) !== 0) return;\n\n      num_started++;\n      if (options.include_docs) {\n        //in this special case, join on _id (issue #106)\n        if (val && typeof val === 'object' && val._id){\n          db.get(val._id,\n              function(_, joined_doc){\n                if (joined_doc) {\n                  viewRow.doc = joined_doc;\n                }\n                results.push(viewRow);\n                checkComplete();\n              });\n          return;\n        } else {\n          viewRow.doc = current.doc;\n        }\n      }\n      results.push(viewRow);\n    };\n\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\n    // above emit\n    eval('fun.map = ' + fun.map.toString() + ';');\n    if (fun.reduce) {\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\n    }\n\n    //only proceed once all documents are mapped and joined\n    var checkComplete= function(){\n      if (completed && results.length == num_started){\n        results.sort(function(a, b) {\n          return Pouch.collate(a.key, b.key);\n        });\n        if (options.descending) {\n          results.reverse();\n        }\n        if (options.reduce === false) {\n          return options.complete(null, {\n            rows: results,\n            total_rows: results.length\n          });\n        }\n\n        var groups = [];\n        results.forEach(function(e) {\n          var last = groups[groups.length-1] || null;\n          if (last && Pouch.collate(last.key[0][0], e.key) === 0) {\n            last.key.push([e.key, e.id]);\n            last.value.push(e.value);\n            return;\n          }\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\n        });\n        groups.forEach(function(e) {\n          e.value = fun.reduce(e.key, e.value) || null;\n          e.key = e.key[0][0];\n        });\n        options.complete(null, {rows: groups, total_rows: groups.length});\n      }\n    }\n\n    db.changes({\n      conflicts: true,\n      include_docs: true,\n      onChange: function(doc) {\n        if (!('deleted' in doc)) {\n          current = {doc: doc.doc};\n          fun.map.call(this, doc.doc);\n        }\n      },\n      complete: function() {\n        completed= true;\n        checkComplete();\n      }\n    });\n  }\n\n  function httpQuery(fun, opts, callback) {\n\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body = undefined;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    if (typeof opts.reduce !== 'undefined') {\n      params.push('reduce=' + opts.reduce);\n    }\n    if (typeof opts.include_docs !== 'undefined') {\n      params.push('include_docs=' + opts.include_docs);\n    }\n    if (typeof opts.limit !== 'undefined') {\n      params.push('limit=' + opts.limit);\n    }\n    if (typeof opts.descending !== 'undefined') {\n      params.push('descending=' + opts.descending);\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n    if (typeof opts.key !== 'undefined') {\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys:opts.keys});\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = fun.split('/');\n      db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }, callback);\n      return;\n    }\n\n    // We are using a temporary view, terrible for performance but good for testing\n    var queryObject = JSON.parse(JSON.stringify(fun, function(key, val) {\n      if (typeof val === 'function') {\n        return val + ''; // implicitly `toString` it\n      }\n      return val;\n    }));\n\n    db.request({\n      method:'POST',\n      url: '_temp_view' + params,\n      body: queryObject\n    }, callback);\n  }\n\n  function query(fun, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    if (db.type() === 'http') {\n\t  if (typeof fun === 'function'){\n\t    return httpQuery({map: fun}, opts, callback);\n\t  }\n\t  return httpQuery(fun, opts, callback);\n    }\n\n    if (typeof fun === 'object') {\n      return viewQuery(fun, opts);\n    }\n\n    if (typeof fun === 'function') {\n      return viewQuery({map: fun}, opts);\n    }\n\n    var parts = fun.split('/');\n    db.get('_design/' + parts[0], function(err, doc) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      viewQuery({\n        map: doc.views[parts[1]].map,\n        reduce: doc.views[parts[1]].reduce\n      }, opts);\n    });\n  }\n\n  return {'query': query};\n};\n\n// Deletion is a noop since we dont store the results of the view\nMapReduce._delete = function() { };\n\nPouch.plugin('mapreduce', MapReduce);\n"],[1,"\r\n(function() {\r\n // BEGIN Math.uuid.js\r\n\r\n/*!\r\nMath.uuid.js (v1.4)\r\nhttp://www.broofa.com\r\nmailto:robert@broofa.com\r\n\r\nCopyright (c) 2010 Robert Kieffer\r\nDual licensed under the MIT and GPL licenses.\r\n*/\r\n\r\n/*\r\n * Generate a random uuid.\r\n *\r\n * USAGE: Math.uuid(length, radix)\r\n *   length - the desired number of characters\r\n *   radix  - the number of allowable values for each character.\r\n *\r\n * EXAMPLES:\r\n *   // No arguments  - returns RFC4122, version 4 ID\r\n *   >>> Math.uuid()\r\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\r\n *\r\n *   // One argument - returns ID of the specified length\r\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\r\n *   \"VcydxgltxrVZSTV\"\r\n *\r\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\r\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\r\n *   \"01001010\"\r\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\r\n *   \"47473046\"\r\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\r\n *   \"098F4D35\"\r\n */\r\n(function() {\r\n  // Private array of chars to use\r\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\r\n\r\n  Math.uuid = function (len, radix) {\r\n    var chars = CHARS, uuid = [];\r\n    radix = radix || chars.length;\r\n\r\n    if (len) {\r\n      // Compact form\r\n      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\r\n    } else {\r\n      // rfc4122, version 4 form\r\n      var r;\r\n\r\n      // rfc4122 requires these characters\r\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\r\n      uuid[14] = '4';\r\n\r\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\r\n      // per rfc4122, sec. 4.1.5\r\n      for (var i = 0; i < 36; i++) {\r\n        if (!uuid[i]) {\r\n          r = 0 | Math.random()*16;\r\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n        }\r\n      }\r\n    }\r\n\r\n    return uuid.join('');\r\n  };\r\n\r\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\r\n  // by minimizing calls to random()\r\n  Math.uuidFast = function() {\r\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\r\n    for (var i = 0; i < 36; i++) {\r\n      if (i==8 || i==13 ||  i==18 || i==23) {\r\n        uuid[i] = '-';\r\n      } else if (i==14) {\r\n        uuid[i] = '4';\r\n      } else {\r\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\r\n        r = rnd & 0xf;\r\n        rnd = rnd >> 4;\r\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n      }\r\n    }\r\n    return uuid.join('');\r\n  };\r\n\r\n  // A more compact, but less performant, RFC4122v4 solution:\r\n  Math.uuidCompact = function() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\r\n      return v.toString(16);\r\n    }).toUpperCase();\r\n  };\r\n})();\r\n\r\n// END Math.uuid.js\r\n\r\n/**\r\n*\r\n*  MD5 (Message-Digest Algorithm)\r\n*\r\n*  For original source see http://www.webtoolkit.info/\r\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\r\n*\r\n*  Licensed under CC-BY 2.0 License\r\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\r\n*\r\n**/\r\n\r\nvar Crypto = {};\r\n(function() {\r\n  Crypto.MD5 = function(string) {\r\n\r\n    function RotateLeft(lValue, iShiftBits) {\r\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\r\n    }\r\n\r\n    function AddUnsigned(lX,lY) {\r\n      var lX4,lY4,lX8,lY8,lResult;\r\n      lX8 = (lX & 0x80000000);\r\n      lY8 = (lY & 0x80000000);\r\n      lX4 = (lX & 0x40000000);\r\n      lY4 = (lY & 0x40000000);\r\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\r\n      if (lX4 & lY4) {\r\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\r\n      }\r\n      if (lX4 | lY4) {\r\n        if (lResult & 0x40000000) {\r\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\r\n        } else {\r\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\r\n        }\r\n      } else {\r\n        return (lResult ^ lX8 ^ lY8);\r\n      }\r\n    }\r\n\r\n    function F(x,y,z) { return (x & y) | ((~x) & z); }\r\n    function G(x,y,z) { return (x & z) | (y & (~z)); }\r\n    function H(x,y,z) { return (x ^ y ^ z); }\r\n    function I(x,y,z) { return (y ^ (x | (~z))); }\r\n\r\n    function FF(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function GG(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function HH(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function II(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function ConvertToWordArray(string) {\r\n      var lWordCount;\r\n      var lMessageLength = string.length;\r\n      var lNumberOfWords_temp1=lMessageLength + 8;\r\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\r\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\r\n      var lWordArray=Array(lNumberOfWords-1);\r\n      var lBytePosition = 0;\r\n      var lByteCount = 0;\r\n      while ( lByteCount < lMessageLength ) {\r\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\r\n        lBytePosition = (lByteCount % 4)*8;\r\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\r\n        lByteCount++;\r\n      }\r\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\r\n      lBytePosition = (lByteCount % 4)*8;\r\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\r\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\r\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\r\n      return lWordArray;\r\n    };\r\n\r\n    function WordToHex(lValue) {\r\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\r\n      for (lCount = 0;lCount<=3;lCount++) {\r\n        lByte = (lValue>>>(lCount*8)) & 255;\r\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\r\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\r\n      }\r\n      return WordToHexValue;\r\n    };\r\n\r\n    //**\tfunction Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\r\n\r\n    var x=Array();\r\n    var k,AA,BB,CC,DD,a,b,c,d;\r\n    var S11=7, S12=12, S13=17, S14=22;\r\n    var S21=5, S22=9 , S23=14, S24=20;\r\n    var S31=4, S32=11, S33=16, S34=23;\r\n    var S41=6, S42=10, S43=15, S44=21;\r\n\r\n    //\tstring = Utf8Encode(string); #function call removed\r\n\r\n    x = ConvertToWordArray(string);\r\n\r\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\r\n\r\n    for (k=0;k<x.length;k+=16) {\r\n      AA=a; BB=b; CC=c; DD=d;\r\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\r\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\r\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\r\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\r\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\r\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\r\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\r\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\r\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\r\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\r\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\r\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\r\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\r\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\r\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\r\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\r\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\r\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\r\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\r\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\r\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\r\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\r\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\r\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\r\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\r\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\r\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\r\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\r\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\r\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\r\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\r\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\r\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\r\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\r\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\r\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\r\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\r\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\r\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\r\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\r\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\r\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\r\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\r\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\r\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\r\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\r\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\r\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\r\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\r\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\r\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\r\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\r\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\r\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\r\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\r\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\r\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\r\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\r\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\r\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\r\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\r\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\r\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\r\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\r\n      a=AddUnsigned(a,AA);\r\n      b=AddUnsigned(b,BB);\r\n      c=AddUnsigned(c,CC);\r\n      d=AddUnsigned(d,DD);\r\n    }\r\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\r\n    return temp.toLowerCase();\r\n  }\r\n})();\r\n\r\n// END Crypto.md5.js\r\n\r\n//----------------------------------------------------------------------\r\n//\r\n// ECMAScript 5 Polyfills\r\n//  from www.calocomrmen./polyfill/\r\n//\r\n//----------------------------------------------------------------------\r\n\r\n//----------------------------------------------------------------------\r\n// ES5 15.2 Object Objects\r\n//----------------------------------------------------------------------\r\n\r\n\r\n\r\n// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )\r\n// Partial support for most common case - getters, setters, and values\r\n(function() {\r\n  if (!Object.defineProperty ||\r\n      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {\r\n    var orig = Object.defineProperty;\r\n    Object.defineProperty = function (o, prop, desc) {\r\n      \"use strict\";\r\n\r\n      // In IE8 try built-in implementation for defining properties on DOM prototypes.\r\n      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }\r\n\r\n      if (o !== Object(o)) { throw new TypeError(\"Object.defineProperty called on non-object\"); }\r\n      if (Object.prototype.__defineGetter__ && ('get' in desc)) {\r\n        Object.prototype.__defineGetter__.call(o, prop, desc.get);\r\n      }\r\n      if (Object.prototype.__defineSetter__ && ('set' in desc)) {\r\n        Object.prototype.__defineSetter__.call(o, prop, desc.set);\r\n      }\r\n      if ('value' in desc) {\r\n        o[prop] = desc.value;\r\n      }\r\n      return o;\r\n    };\r\n  }\r\n}());\r\n\r\n\r\n\r\n// ES5 15.2.3.14 Object.keys ( O )\r\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\r\nif (!Object.keys) {\r\n  Object.keys = function (o) {\r\n    if (o !== Object(o)) { throw new TypeError('Object.keys called on non-object'); }\r\n    var ret = [], p;\r\n    for (p in o) {\r\n      if (Object.prototype.hasOwnProperty.call(o, p)) {\r\n        ret.push(p);\r\n      }\r\n    }\r\n    return ret;\r\n  };\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// ES5 15.4 Array Objects\r\n//----------------------------------------------------------------------\r\n\r\n\r\n\r\n// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\r\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\r\nif (!Array.prototype.forEach) {\r\n  Array.prototype.forEach = function (fun /*, thisp */) {\r\n    \"use strict\";\r\n\r\n    if (this === void 0 || this === null) { throw new TypeError(); }\r\n\r\n    var t = Object(this);\r\n    var len = t.length >>> 0;\r\n    if (typeof fun !== \"function\") { throw new TypeError(); }\r\n\r\n    var thisp = arguments[1], i;\r\n    for (i = 0; i < len; i++) {\r\n      if (i in t) {\r\n        fun.call(thisp, t[i], i, t);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n\r\n// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )\r\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\r\nif (!Array.prototype.map) {\r\n  Array.prototype.map = function (fun /*, thisp */) {\r\n    \"use strict\";\r\n\r\n    if (this === void 0 || this === null) { throw new TypeError(); }\r\n\r\n    var t = Object(this);\r\n    var len = t.length >>> 0;\r\n    if (typeof fun !== \"function\") { throw new TypeError(); }\r\n\r\n    var res = []; res.length = len;\r\n    var thisp = arguments[1], i;\r\n    for (i = 0; i < len; i++) {\r\n      if (i in t) {\r\n        res[i] = fun.call(thisp, t[i], i, t);\r\n      }\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\n\r\n\r\n// Extends method\r\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\r\n// Populate the class2type map\r\nvar class2type = {};\r\n\r\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\r\nfor (var i = 0; i < types.length; i++) {\r\n  var typename = types[i];\r\n  class2type[ \"[object \" + typename + \"]\" ] = typename.toLowerCase();\r\n}\r\n\r\nvar core_toString = class2type.toString;\r\nvar core_hasOwn = class2type.hasOwnProperty;\r\n\r\nvar type = function(obj) {\r\n  if (obj === null) {\r\n    return String( obj );\r\n  }\r\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\r\n    class2type[core_toString.call(obj)] || \"object\" :\r\n    typeof obj;\r\n};\r\n\r\nvar isWindow = function(obj) {\r\n  return obj !== null && obj === obj.window;\r\n};\r\n\r\nvar isPlainObject = function( obj ) {\r\n  // Must be an Object.\r\n  // Because of IE, we also have to check the presence of the constructor property.\r\n  // Make sure that DOM nodes and window objects don't pass through, as well\r\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // Not own constructor property must be Object\r\n    if ( obj.constructor &&\r\n      !core_hasOwn.call(obj, \"constructor\") &&\r\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\r\n      return false;\r\n    }\r\n  } catch ( e ) {\r\n    // IE8,9 Will throw exceptions on certain host objects #9897\r\n    return false;\r\n  }\r\n\r\n  // Own properties are enumerated firstly, so to speed up,\r\n  // if last one is own, then all properties are own.\r\n\r\n  var key;\r\n  for ( key in obj ) {}\r\n\r\n  return key === undefined || core_hasOwn.call( obj, key );\r\n};\r\n\r\nvar isFunction = function(obj) {\r\n  return type(obj) === \"function\";\r\n};\r\n\r\nvar isArray = Array.isArray || function(obj) {\r\n  return type(obj) === \"array\";\r\n};\r\n\r\nvar extend = function() {\r\n  var options, name, src, copy, copyIsArray, clone,\r\n    target = arguments[0] || {},\r\n    i = 1,\r\n    length = arguments.length,\r\n    deep = false;\r\n\r\n  // Handle a deep copy situation\r\n  if ( typeof target === \"boolean\" ) {\r\n    deep = target;\r\n    target = arguments[1] || {};\r\n    // skip the boolean and the target\r\n    i = 2;\r\n  }\r\n\r\n  // Handle case when target is a string or something (possible in deep copy)\r\n  if ( typeof target !== \"object\" && !isFunction(target) ) {\r\n    target = {};\r\n  }\r\n\r\n  // extend jQuery itself if only one argument is passed\r\n  if ( length === i ) {\r\n    target = this;\r\n    --i;\r\n  }\r\n\r\n  for ( ; i < length; i++ ) {\r\n    // Only deal with non-null/undefined values\r\n    if ((options = arguments[ i ]) != null) {\r\n      // Extend the base object\r\n      for ( name in options ) {\r\n        src = target[ name ];\r\n        copy = options[ name ];\r\n\r\n        // Prevent never-ending loop\r\n        if ( target === copy ) {\r\n          continue;\r\n        }\r\n\r\n        // Recurse if we're merging plain objects or arrays\r\n        if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = isArray(copy)) ) ) {\r\n          if ( copyIsArray ) {\r\n            copyIsArray = false;\r\n            clone = src && isArray(src) ? src : [];\r\n\r\n          } else {\r\n            clone = src && isPlainObject(src) ? src : {};\r\n          }\r\n\r\n          // Never move original objects, clone them\r\n          target[ name ] = extend( deep, clone, copy );\r\n\r\n        // Don't bring in undefined values\r\n        } else if ( copy !== undefined ) {\r\n          target[ name ] = copy;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return the modified object\r\n  return target;\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = extend;\r\n}\r\n\r\nvar ajax = function ajax(options, callback) {\r\n  if (typeof options === \"function\") {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  var call = function(fun) {\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    if (typeof fun === typeof Function) {\r\n      fun.apply(this, args);\r\n    }\r\n  }; \r\n  var defaultOptions = {\r\n    method : \"GET\",\r\n    headers: {},\r\n    json: true,\r\n    processData: true,\r\n    timeout: 10000\r\n  };\r\n  options = extend(true, defaultOptions, options);\r\n  if (options.auth) {\r\n      var token = btoa(options.auth.username + ':' + options.auth.password);\r\n      options.headers.Authorization = 'Basic ' + token;\r\n  }\r\n  var onSuccess = function(obj, resp, cb){\r\n    if (!options.binary && !options.json && options.processData && typeof obj !== 'string') {\r\n      obj = JSON.stringify(obj);\r\n    } else if (!options.binary && options.json && typeof obj === 'string') {\r\n      try {\r\n        obj = JSON.parse(obj);\r\n      } catch (e) {\r\n        // Probably a malformed JSON from server\r\n        call(cb, e);\r\n        return;\r\n      }\r\n    }\r\n    call(cb, null, obj, resp);\r\n  };\r\n  var onError = function(err, cb){\r\n    var errParsed;\r\n    var errObj = {status: err.status};\r\n    try{\r\n      errParsed = JSON.parse(err.responseText); //would prefer not to have a try/catch clause\r\n      errObj = extend(true, {}, errObj, errParsed);\r\n    } catch(e){}\r\n    call(cb, errObj);\r\n  };\r\n  if (typeof window !== 'undefined' && window.XMLHttpRequest) {\r\n    var timer,timedout  = false;\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(options.method, options.url);\r\n    if (options.json) {\r\n      options.headers.Accept = 'application/json';\r\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\r\n      if (options.body && options.processData && typeof options.body !== \"string\") {\r\n        options.body = JSON.stringify(options.body);\r\n      }\r\n    }\r\n    if (options.binary) {\r\n      xhr.responseType = 'arraybuffer';\r\n    }\r\n    for (var key in options.headers){\r\n      xhr.setRequestHeader(key, options.headers[key]);\r\n    }\r\n    if (!(\"body\" in options)) {\r\n      options.body = null;\r\n    }\r\n\r\n    var abortReq = function() {\r\n        timedout=true;\r\n        xhr.abort();\r\n        call(onError, xhr, callback);\r\n    };\r\n    xhr.onreadystatechange = function() {\r\n      if (xhr.readyState !== 4 || timedout) {\r\n        return;\r\n      }\r\n      clearTimeout(timer);\r\n      if (xhr.status >= 200 && xhr.status < 300) {\r\n        var data;\r\n        if (options.binary) {\r\n          data = new Blob([xhr.response || ''], {type: xhr.getResponseHeader('Content-Type')});\r\n        } else {\r\n          data = xhr.responseText;\r\n        }\r\n        call(onSuccess, data, xhr, callback);\r\n      } else {\r\n         call(onError, xhr, callback);\r\n      }\r\n    };\r\n    if (options.timeout > 0) {\r\n      timer = setTimeout(abortReq, options.timeout);\r\n    }\r\n    xhr.send(options.body);\r\n    return {abort:abortReq};\r\n  } else {\r\n    if (options.json) {\r\n      if (!options.binary) {\r\n        options.headers.Accept = 'application/json';\r\n      }\r\n      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\r\n    }\r\n    if (options.binary) {\r\n      options.encoding = null;\r\n      options.json = false;\r\n    }\r\n    if (!options.processData) {\r\n      options.json = false;\r\n    }\r\n    return request(options, function(err, response, body) {\r\n      if (err) {\r\n        err.status = response ? response.statusCode : 400;\r\n        return call(onError, err, callback);\r\n      }\r\n\r\n      var content_type = response.headers['content-type'];\r\n      var data = (body || '');\r\n\r\n      // CouchDB doesn't always return the right content-type for JSON data, so\r\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\r\n      if (!options.binary && (options.json || !options.processData) && typeof data !== 'object' &&\r\n          (/json/.test(content_type) ||\r\n           (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\r\n        data = JSON.parse(data);\r\n      }\r\n\r\n      if (response.statusCode >= 200 && response.statusCode < 300) {\r\n        call(onSuccess, data, response, callback);\r\n      }\r\n      else {\r\n        if (options.binary) {\r\n          var data = JSON.parse(data.toString());\r\n        }\r\n        data.status = response.statusCode;\r\n        call(callback, data);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = ajax;\r\n}\r\n\r\n/*globals PouchAdapter: true, extend: true */\r\n\r\n\"use strict\";\r\n\r\nvar Pouch = function Pouch(name, opts, callback) {\r\n\r\n  if (!(this instanceof Pouch)) {\r\n    return new Pouch(name, opts, callback);\r\n  }\r\n\r\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  if (typeof name === 'object') {\r\n    opts = name;\r\n    name = undefined;\r\n  }\r\n\r\n  if (typeof callback === 'undefined') {\r\n    callback = function() {};\r\n  }\r\n\r\n  var backend = Pouch.parseAdapter(opts.name || name);\r\n  opts.originalName = name;\r\n  opts.name = opts.name || backend.name;\r\n  opts.adapter = opts.adapter || backend.adapter;\r\n\r\n  if (!Pouch.adapters[opts.adapter]) {\r\n    throw 'Adapter is missing';\r\n  }\r\n\r\n  if (!Pouch.adapters[opts.adapter].valid()) {\r\n    throw 'Invalid Adapter';\r\n  }\r\n\r\n  var adapter = new PouchAdapter(opts, function(err, db) {\r\n    if (err) {\r\n      if (callback) {\r\n        callback(err);\r\n      }\r\n      return;\r\n    }\r\n\r\n    for (var plugin in Pouch.plugins) {\r\n      // In future these will likely need to be async to allow the plugin\r\n      // to initialise\r\n      var pluginObj = Pouch.plugins[plugin](db);\r\n      for (var api in pluginObj) {\r\n        // We let things like the http adapter use its own implementation\r\n        // as it shares a lot of code\r\n        if (!(api in db)) {\r\n          db[api] = pluginObj[api];\r\n        }\r\n      }\r\n    }\r\n    db.taskqueue.ready(true);\r\n    db.taskqueue.execute(db);\r\n    callback(null, db);\r\n  });\r\n  for (var j in adapter) {\r\n    this[j] = adapter[j];\r\n  }\r\n  for (var plugin in Pouch.plugins) {\r\n    // In future these will likely need to be async to allow the plugin\r\n    // to initialise\r\n    var pluginObj = Pouch.plugins[plugin](this);\r\n    for (var api in pluginObj) {\r\n      // We let things like the http adapter use its own implementation\r\n      // as it shares a lot of code\r\n      if (!(api in this)) {\r\n        this[api] = pluginObj[api];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nPouch.DEBUG = false;\r\n\r\nPouch.adapters = {};\r\nPouch.plugins = {};\r\n\r\nPouch.prefix = '_pouch_';\r\n\r\nPouch.parseAdapter = function(name) {\r\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\r\n  var adapter;\r\n  if (match) {\r\n    // the http adapter expects the fully qualified name\r\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\r\n    adapter = match[1];\r\n    if (!Pouch.adapters[adapter].valid()) {\r\n      throw 'Invalid adapter';\r\n    }\r\n    return {name: name, adapter: match[1]};\r\n  }\r\n\r\n  var preferredAdapters = ['idb', 'leveldb', 'websql'];\r\n  for (var i = 0; i < preferredAdapters.length; ++i) {\r\n    if (preferredAdapters[i] in Pouch.adapters) {\r\n      adapter = Pouch.adapters[preferredAdapters[i]];\r\n      var use_prefix = 'use_prefix' in adapter ? adapter.use_prefix : true;\r\n\r\n      return {\r\n        name: use_prefix ? Pouch.prefix + name : name,\r\n        adapter: preferredAdapters[i]\r\n      };\r\n    }\r\n  }\r\n\r\n  throw 'No valid adapter found';\r\n};\r\n\r\nPouch.destroy = function(name, callback) {\r\n  var opts = Pouch.parseAdapter(name);\r\n  var cb = function(err, response) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    for (var plugin in Pouch.plugins) {\r\n      Pouch.plugins[plugin]._delete(name);\r\n    }\r\n    if (Pouch.DEBUG) {\r\n      console.log(name + ': Delete Database');\r\n    }\r\n\r\n    // call destroy method of the particular adaptor\r\n    Pouch.adapters[opts.adapter].destroy(opts.name, callback);\r\n  };\r\n\r\n  // remove Pouch from allDBs\r\n  Pouch.removeFromAllDbs(opts, cb);\r\n};\r\n\r\nPouch.removeFromAllDbs = function(opts, callback) {\r\n  // Only execute function if flag is enabled\r\n  if (!Pouch.enableAllDbs) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  // skip http and https adaptors for allDbs\r\n  var adapter = opts.adapter;\r\n  if (adapter === \"http\" || adapter === \"https\") {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  // remove db from Pouch.ALL_DBS\r\n  new Pouch(Pouch.allDBName(opts.adapter), function(err, db) {\r\n    if (err) {\r\n      // don't fail when allDbs fail\r\n      console.error(err);\r\n      callback();\r\n      return;\r\n    }\r\n    // check if db has been registered in Pouch.ALL_DBS\r\n    var dbname = Pouch.dbName(opts.adapter, opts.name);\r\n    db.get(dbname, function(err, doc) {\r\n      if (err) {\r\n        callback();\r\n      } else {\r\n        db.remove(doc, function(err, response) {\r\n          if (err) {\r\n            console.error(err);\r\n          }\r\n          callback();\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\n};\r\n\r\nPouch.adapter = function (id, obj) {\r\n  if (obj.valid()) {\r\n    Pouch.adapters[id] = obj;\r\n  }\r\n};\r\n\r\nPouch.plugin = function(id, obj) {\r\n  Pouch.plugins[id] = obj;\r\n};\r\n\r\n// flag to toggle allDbs (off by default)\r\nPouch.enableAllDbs = false;\r\n\r\n// name of database used to keep track of databases\r\nPouch.ALL_DBS = \"_allDbs\";\r\nPouch.dbName = function(adapter, name) {\r\n  return [adapter, \"-\", name].join('');\r\n};\r\nPouch.realDBName = function(adapter, name) {\r\n  return [adapter, \"://\", name].join('');\r\n};\r\nPouch.allDBName = function(adapter) {\r\n  return [adapter, \"://\", Pouch.prefix + Pouch.ALL_DBS].join('');\r\n};\r\n\r\nPouch.open = function(opts, callback) {\r\n  // Only register pouch with allDbs if flag is enabled\r\n  if (!Pouch.enableAllDbs) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  var adapter = opts.adapter;\r\n  // skip http and https adaptors for allDbs\r\n  if (adapter === \"http\" || adapter === \"https\") {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  new Pouch(Pouch.allDBName(adapter), function(err, db) {\r\n    if (err) {\r\n      // don't fail when allDb registration fails\r\n      console.error(err);\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    // check if db has been registered in Pouch.ALL_DBS\r\n    var dbname = Pouch.dbName(adapter, opts.name);\r\n    db.get(dbname, function(err, response) {\r\n      if (err && err.status === 404) {\r\n        db.put({\r\n          _id: dbname,\r\n          dbname: opts.originalName\r\n        }, function(err) {\r\n            if (err) {\r\n                console.error(err);\r\n            }\r\n\r\n            callback();\r\n        });\r\n      } else {\r\n        callback();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nPouch.allDbs = function(callback) {\r\n  var accumulate = function(adapters, all_dbs) {\r\n    if (adapters.length === 0) {\r\n      // remove duplicates\r\n      var result = [];\r\n      all_dbs.forEach(function(doc) {\r\n        var exists = result.some(function(db) {\r\n          return db.id === doc.id;\r\n        });\r\n\r\n        if (!exists) {\r\n          result.push(doc);\r\n        }\r\n      });\r\n\r\n      // return an array of dbname\r\n      callback(null, result.map(function(row) {\r\n          return row.doc.dbname;\r\n      }));\r\n      return;\r\n    }\r\n\r\n    var adapter = adapters.shift();\r\n\r\n    // skip http and https adaptors for allDbs\r\n    if (adapter === \"http\" || adapter === \"https\") {\r\n      accumulate(adapters, all_dbs);\r\n      return;\r\n    }\r\n\r\n    new Pouch(Pouch.allDBName(adapter), function(err, db) {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n      db.allDocs({include_docs: true}, function(err, response) {\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        // append from current adapter rows\r\n        all_dbs.unshift.apply(all_dbs, response.rows);\r\n\r\n        // code to clear allDbs.\r\n        // response.rows.forEach(function(row) {\r\n        //   db.remove(row.doc, function() {\r\n        //     console.log(arguments);\r\n        //   });\r\n        // });\r\n\r\n        // recurse\r\n        accumulate(adapters, all_dbs);\r\n      });\r\n    });\r\n  };\r\n  var adapters = Object.keys(Pouch.adapters);\r\n  accumulate(adapters, []);\r\n};\r\n\r\n// Enumerate errors, add the status code so we can reflect the HTTP api\r\n// in future\r\nPouch.Errors = {\r\n  MISSING_BULK_DOCS: {\r\n    status: 400,\r\n    error: 'bad_request',\r\n    reason: \"Missing JSON list of 'docs'\"\r\n  },\r\n  MISSING_DOC: {\r\n    status: 404,\r\n    error: 'not_found',\r\n    reason: 'missing'\r\n  },\r\n  REV_CONFLICT: {\r\n    status: 409,\r\n    error: 'conflict',\r\n    reason: 'Document update conflict'\r\n  },\r\n  INVALID_ID: {\r\n    status: 400,\r\n    error: 'invalid_id',\r\n    reason: '_id field must contain a string'\r\n  },\r\n  MISSING_ID: {\r\n    status: 412,\r\n    error: 'missing_id',\r\n    reason: '_id is required for puts'\r\n  },\r\n  RESERVED_ID: {\r\n    status: 400,\r\n    error: 'bad_request',\r\n    reason: 'Only reserved document ids may start with underscore.'\r\n  },\r\n  NOT_OPEN: {\r\n    status: 412,\r\n    error: 'precondition_failed',\r\n    reason: 'Database not open so cannot close'\r\n  },\r\n  UNKNOWN_ERROR: {\r\n    status: 500,\r\n    error: 'unknown_error',\r\n    reason: 'Database encountered an unknown error'\r\n  },\r\n  BAD_ARG: {\r\n    status: 500,\r\n    error: 'badarg',\r\n    reason: 'Some query argument is invalid'\r\n  },\r\n  INVALID_REQUEST: {\r\n    status: 400,\r\n    error: 'invalid_request',\r\n    reason: 'Request was invalid'\r\n  },\r\n  QUERY_PARSE_ERROR: {\r\n    status: 400,\r\n    error: 'query_parse_error',\r\n    reason: 'Some query parameter is invalid'\r\n  },\r\n  BAD_REQUEST: {\r\n    status: 400,\r\n    error: 'bad_request',\r\n    reason: 'Something wrong with the request'\r\n  }\r\n};\r\nPouch.error = function(error, reason){\r\n return extend({}, error, {reason: reason});\r\n};\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  global.Pouch = Pouch;\r\n  Pouch.merge = require('./pouch.merge.js').merge;\r\n  Pouch.collate = require('./pouch.collate.js').collate;\r\n  Pouch.replicate = require('./pouch.replicate.js').replicate;\r\n  Pouch.utils = require('./pouch.utils.js');\r\n  extend = Pouch.utils.extend;\r\n  module.exports = Pouch;\r\n  var PouchAdapter = require('./pouch.adapter.js');\r\n  //load adapters known to work under node\r\n  var adapters = ['leveldb', 'http'];\r\n  adapters.map(function(adapter) {\r\n    var adapter_path = './adapters/pouch.'+adapter+'.js';\r\n    require(adapter_path);\r\n  });\r\n  require('./plugins/pouchdb.mapreduce.js');\r\n} else {\r\n  window.Pouch = Pouch;\r\n}\r\n\r\n'use strict';\r\n\r\n// a few hacks to get things in the right place for node.js\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Pouch;\r\n}\r\n\r\nvar stringCollate = function(a, b) {\r\n  // See: https://github.com/daleharvey/pouchdb/issues/40\r\n  // This is incompatible with the CouchDB implementation, but its the\r\n  // best we can do for now\r\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\r\n};\r\n\r\nvar objectCollate = function(a, b) {\r\n  var ak = Object.keys(a), bk = Object.keys(b);\r\n  var len = Math.min(ak.length, bk.length);\r\n  for (var i = 0; i < len; i++) {\r\n    // First sort the keys\r\n    var sort = Pouch.collate(ak[i], bk[i]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n    // if the keys are equal sort the values\r\n    sort = Pouch.collate(a[ak[i]], b[bk[i]]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n\r\n  }\r\n  return (ak.length === bk.length) ? 0 :\r\n    (ak.length > bk.length) ? 1 : -1;\r\n};\r\n\r\nvar arrayCollate = function(a, b) {\r\n  var len = Math.min(a.length, b.length);\r\n  for (var i = 0; i < len; i++) {\r\n    var sort = Pouch.collate(a[i], b[i]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n  }\r\n  return (a.length === b.length) ? 0 :\r\n    (a.length > b.length) ? 1 : -1;\r\n};\r\n\r\n// The collation is defined by erlangs ordered terms\r\n// the atoms null, true, false come first, then numbers, strings,\r\n// arrays, then objects\r\nvar collationIndex = function(x) {\r\n  var id = ['boolean', 'number', 'string', 'object'];\r\n  if (id.indexOf(typeof x) !== -1) {\r\n    if (x === null) {\r\n      return 1;\r\n    }\r\n    return id.indexOf(typeof x) + 2;\r\n  }\r\n  if (Array.isArray(x)) {\r\n    return 4.5;\r\n  }\r\n};\r\n\r\nPouch.collate = function(a, b) {\r\n  var ai = collationIndex(a);\r\n  var bi = collationIndex(b);\r\n  if ((ai - bi) !== 0) {\r\n    return ai - bi;\r\n  }\r\n  if (a === null) {\r\n    return 0;\r\n  }\r\n  if (typeof a === 'number') {\r\n    return a - b;\r\n  }\r\n  if (typeof a === 'boolean') {\r\n    return a < b ? -1 : 1;\r\n  }\r\n  if (typeof a === 'string') {\r\n    return stringCollate(a, b);\r\n  }\r\n  if (Array.isArray(a)) {\r\n    return arrayCollate(a, b);\r\n  }\r\n  if (typeof a === 'object') {\r\n    return objectCollate(a, b);\r\n  }\r\n};\r\n/*globals rootToLeaf: false, extend: false */\r\n\r\n'use strict';\r\n\r\n// a few hacks to get things in the right place for node.js\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Pouch;\r\n  var utils = require('./pouch.utils.js');\r\n  for (var k in utils) {\r\n    global[k] = utils[k];\r\n  }\r\n}\r\n\r\n// for a better overview of what this is doing, read:\r\n// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\r\n//\r\n// But for a quick intro, CouchDB uses a revision tree to store a documents\r\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\r\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\r\n//\r\n// KeyTree = [Path ... ]\r\n// Path = {pos: position_from_root, ids: Tree}\r\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\r\n\r\n// Turn a path as a flat array into a tree with a single branch\r\nfunction pathToTree(path) {\r\n  var doc = path.shift();\r\n  var root = [doc.id, doc.opts, []];\r\n  var leaf = root;\r\n  var nleaf;\r\n\r\n  while (path.length) {\r\n    doc = path.shift();\r\n    nleaf = [doc.id, doc.opts, []];\r\n    leaf[2].push(nleaf);\r\n    leaf = nleaf;\r\n  }\r\n  return root;\r\n}\r\n\r\n// Merge two trees together\r\n// The roots of tree1 and tree2 must be the same revision\r\nfunction mergeTree(in_tree1, in_tree2) {\r\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\r\n  var conflicts = false;\r\n  while (queue.length > 0) {\r\n    var item = queue.pop();\r\n    var tree1 = item.tree1;\r\n    var tree2 = item.tree2;\r\n\r\n    if (tree1[1].status || tree2[1].status) {\r\n      tree1[1].status = (tree1[1].status ===  'available' || \r\n                         tree2[1].status === 'available') ? 'available' : 'missing';\r\n    }\r\n\r\n    for (var i = 0; i < tree2[2].length; i++) {\r\n      if (!tree1[2][0]) {\r\n        conflicts = 'new_leaf';\r\n        tree1[2][0] = tree2[2][i];\r\n        continue;\r\n      }\r\n\r\n      var merged = false;\r\n      for (var j = 0; j < tree1[2].length; j++) {\r\n        if (tree1[2][j][0] === tree2[2][i][0]) {\r\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\r\n          merged = true;\r\n        }\r\n      }\r\n      if (!merged) {\r\n        conflicts = 'new_branch';\r\n        tree1[2].push(tree2[2][i]);\r\n        tree1[2].sort();\r\n      }\r\n    }\r\n  }\r\n  return {conflicts: conflicts, tree: in_tree1};\r\n}\r\n\r\nfunction doMerge(tree, path, dontExpand) {\r\n  var restree = [];\r\n  var conflicts = false;\r\n  var merged = false;\r\n  var res, branch;\r\n\r\n  if (!tree.length) {\r\n    return {tree: [path], conflicts: 'new_leaf'};\r\n  }\r\n\r\n  tree.forEach(function(branch) {\r\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\r\n      // Paths start at the same position and have the same root, so they need\r\n      // merged\r\n      res = mergeTree(branch.ids, path.ids);\r\n      restree.push({pos: branch.pos, ids: res.tree});\r\n      conflicts = conflicts || res.conflicts;\r\n      merged = true;\r\n    } else if (dontExpand !== true) {\r\n      // The paths start at a different position, take the earliest path and\r\n      // traverse up until it as at the same point from root as the path we want to\r\n      // merge.  If the keys match we return the longer path with the other merged\r\n      // After stemming we dont want to expand the trees\r\n\r\n      var t1 = branch.pos < path.pos ? branch : path;\r\n      var t2 = branch.pos < path.pos ? path : branch;\r\n      var diff = t2.pos - t1.pos;\r\n\r\n      var candidateParents = [];\r\n\r\n      var trees = [];\r\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\r\n      while (trees.length > 0) {\r\n        var item = trees.pop();\r\n        if (item.diff === 0) {\r\n          if (item.ids[0] === t2.ids[0]) {\r\n            candidateParents.push(item);\r\n          }\r\n          continue;\r\n        }\r\n        if (!item.ids) {\r\n          continue;\r\n        }\r\n        /*jshint loopfunc:true */\r\n        item.ids[2].forEach(function(el, idx) {\r\n          trees.push({ids: el, diff: item.diff-1, parent: item.ids, parentIdx: idx});\r\n        });\r\n      }\r\n\r\n      var el = candidateParents[0];\r\n\r\n      if (!el) {\r\n        restree.push(branch);\r\n      } else {\r\n        res = mergeTree(el.ids, t2.ids);\r\n        el.parent[2][el.parentIdx] = res.tree;\r\n        restree.push({pos: t1.pos, ids: t1.ids});\r\n        conflicts = conflicts || res.conflicts;\r\n        merged = true;\r\n      }\r\n    } else {\r\n      restree.push(branch);\r\n    }\r\n  });\r\n\r\n  // We didnt find\r\n  if (!merged) {\r\n    restree.push(path);\r\n  }\r\n\r\n  restree.sort(function(a, b) {\r\n    return a.pos - b.pos;\r\n  });\r\n\r\n  return {\r\n    tree: restree,\r\n    conflicts: conflicts || 'internal_node'\r\n  };\r\n}\r\n\r\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\r\nfunction stem(tree, depth) {\r\n  // First we break out the tree into a complete list of root to leaf paths,\r\n  // we cut off the start of the path and generate a new set of flat trees\r\n  var stemmedPaths = rootToLeaf(tree).map(function(path) {\r\n    var stemmed = path.ids.slice(-depth);\r\n    return {\r\n      pos: path.pos + (path.ids.length - stemmed.length),\r\n      ids: pathToTree(stemmed)\r\n    };\r\n  });\r\n  // Then we remerge all those flat trees together, ensuring that we dont\r\n  // connect trees that would go beyond the depth limit\r\n  return stemmedPaths.reduce(function(prev, current, i, arr) {\r\n    return doMerge(prev, current, true).tree;\r\n  }, [stemmedPaths.shift()]);\r\n}\r\n\r\nPouch.merge = function(tree, path, depth) {\r\n  // Ugh, nicer way to not modify arguments in place?\r\n  tree = extend(true, [], tree);\r\n  path = extend(true, {}, path);\r\n  var newTree = doMerge(tree, path);\r\n  return {\r\n    tree: stem(newTree.tree, depth),\r\n    conflicts: newTree.conflicts\r\n  };\r\n};\r\n\r\n// We fetch all leafs of the revision tree, and sort them based on tree length\r\n// and whether they were deleted, undeleted documents with the longest revision\r\n// tree (most edits) win\r\n// The final sort algorithm is slightly documented in a sidebar here:\r\n// http://guide.couchdb.org/draft/conflicts.html\r\nPouch.merge.winningRev = function(metadata) {\r\n  var leafs = [];\r\n  Pouch.merge.traverseRevTree(metadata.rev_tree,\r\n                              function(isLeaf, pos, id, something, opts) {\r\n    if (isLeaf) {\r\n      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});\r\n    }\r\n  });\r\n  leafs.sort(function(a, b) {\r\n    if (a.deleted !== b.deleted) {\r\n      return a.deleted > b.deleted ? 1 : -1;\r\n    }\r\n    if (a.pos !== b.pos) {\r\n      return b.pos - a.pos;\r\n    }\r\n    return a.id < b.id ? 1 : -1;\r\n  });\r\n\r\n  return leafs[0].pos + '-' + leafs[0].id;\r\n};\r\n\r\n// Pretty much all below can be combined into a higher order function to\r\n// traverse revisions\r\n// Callback has signature function(isLeaf, pos, id, [context])\r\n// The return value from the callback will be passed as context to all\r\n// children of that node\r\nPouch.merge.traverseRevTree = function(revs, callback) {\r\n  var toVisit = [];\r\n\r\n  revs.forEach(function(tree) {\r\n    toVisit.push({pos: tree.pos, ids: tree.ids});\r\n  });\r\n  while (toVisit.length > 0) {\r\n    var node = toVisit.pop();\r\n    var pos = node.pos;\r\n    var tree = node.ids;\r\n    var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);\r\n    /*jshint loopfunc: true */\r\n    tree[2].forEach(function(branch) {\r\n      toVisit.push({pos: pos+1, ids: branch, ctx: newCtx});\r\n    });\r\n  }\r\n};\r\n\r\nPouch.merge.collectLeaves = function(revs) {\r\n  var leaves = [];\r\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, acc, opts) {\r\n    if (isLeaf) {\r\n      leaves.unshift({rev: pos + \"-\" + id, pos: pos, opts: opts});\r\n    }\r\n  });\r\n  leaves.sort(function(a, b) {\r\n    return b.pos - a.pos;\r\n  });\r\n  leaves.map(function(leaf) { delete leaf.pos; });\r\n  return leaves;\r\n};\r\n\r\n// returns all conflicts that is leaves such that\r\n// 1. are not deleted and\r\n// 2. are different than winning revision\r\nPouch.merge.collectConflicts = function(metadata) {\r\n  var win = Pouch.merge.winningRev(metadata);\r\n  var leaves = Pouch.merge.collectLeaves(metadata.rev_tree);\r\n  var conflicts = [];\r\n  leaves.forEach(function(leaf) {\r\n    if (leaf.rev !== win && !leaf.opts.deleted) {\r\n      conflicts.push(leaf.rev);\r\n    }\r\n  });\r\n  return conflicts;\r\n};\r\n\r\n\r\n/*globals call: false, Crypto: false*/\r\n\r\n'use strict';\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Pouch;\r\n}\r\n\r\n// We create a basic promise so the caller can cancel the replication possibly\r\n// before we have actually started listening to changes etc\r\nvar Promise = function() {\r\n  this.cancelled = false;\r\n  this.cancel = function() {\r\n    this.cancelled = true;\r\n  };\r\n};\r\n\r\n// The RequestManager ensures that only one database request is active at\r\n// at time, it ensures we dont max out simultaneous HTTP requests and makes\r\n// the replication process easier to reason about\r\nvar RequestManager = function() {\r\n\r\n  var queue = [];\r\n  var api = {};\r\n  var processing = false;\r\n\r\n  // Add a new request to the queue, if we arent currently processing anything\r\n  // then process it immediately\r\n  api.enqueue = function(fun, args) {\r\n    queue.push({fun: fun, args: args});\r\n    if (!processing) {\r\n      api.process();\r\n    }\r\n  };\r\n\r\n  // Process the next request\r\n  api.process = function() {\r\n    if (processing || !queue.length) {\r\n      return;\r\n    }\r\n    processing = true;\r\n    var task = queue.shift();\r\n    task.fun.apply(null, task.args);\r\n  };\r\n\r\n  // We need to be notified whenever a request is complete to process\r\n  // the next request\r\n  api.notifyRequestComplete = function() {\r\n    processing = false;\r\n    api.process();\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\n// TODO: check CouchDB's replication id generation, generate a unique id particular\r\n// to this replication\r\nvar genReplicationId = function(src, target, opts) {\r\n  var filterFun = opts.filter ? opts.filter.toString() : '';\r\n  return '_local/' + Crypto.MD5(src.id() + target.id() + filterFun);\r\n};\r\n\r\n// A checkpoint lets us restart replications from when they were last cancelled\r\nvar fetchCheckpoint = function(target, id, callback) {\r\n  target.get(id, function(err, doc) {\r\n    if (err && err.status === 404) {\r\n      callback(null, 0);\r\n    } else {\r\n      callback(null, doc.last_seq);\r\n    }\r\n  });\r\n};\r\n\r\nvar writeCheckpoint = function(target, id, checkpoint, callback) {\r\n  var check = {\r\n    _id: id,\r\n    last_seq: checkpoint\r\n  };\r\n  target.get(check._id, function(err, doc) {\r\n    if (doc && doc._rev) {\r\n      check._rev = doc._rev;\r\n    }\r\n    target.put(check, function(err, doc) {\r\n      callback();\r\n    });\r\n  });\r\n};\r\n\r\nfunction replicate(src, target, opts, promise) {\r\n\r\n  var requests = new RequestManager();\r\n  var writeQueue = [];\r\n  var repId = genReplicationId(src, target, opts);\r\n  var results = [];\r\n  var completed = false;\r\n  var pending = 0;\r\n  var last_seq = 0;\r\n  var continuous = opts.continuous || false;\r\n  var doc_ids = opts.doc_ids;\r\n  var result = {\r\n    ok: true,\r\n    start_time: new Date(),\r\n    docs_read: 0,\r\n    docs_written: 0\r\n  };\r\n\r\n  function docsWritten(err, res, len) {\r\n    requests.notifyRequestComplete();\r\n    if (opts.onChange) {\r\n      for (var i = 0; i < len; i++) {\r\n        /*jshint validthis:true */\r\n        opts.onChange.apply(this, [result]);\r\n      }\r\n    }\r\n    pending -= len;\r\n    result.docs_written += len;\r\n    isCompleted();\r\n  }\r\n\r\n  function writeDocs() {\r\n    if (!writeQueue.length) {\r\n      return requests.notifyRequestComplete();\r\n    }\r\n    var len = writeQueue.length;\r\n    target.bulkDocs({docs: writeQueue}, {new_edits: false}, function(err, res) {\r\n      docsWritten(err, res, len);\r\n    });\r\n    writeQueue = [];\r\n  }\r\n\r\n  function eachRev(id, rev) {\r\n    src.get(id, {revs: true, rev: rev, attachments: true}, function(err, doc) {\r\n      requests.notifyRequestComplete();\r\n      writeQueue.push(doc);\r\n      requests.enqueue(writeDocs);\r\n    });\r\n  }\r\n\r\n  function onRevsDiff(err, diffs) {\r\n    requests.notifyRequestComplete();\r\n    if (err) {\r\n      if (continuous) {\r\n        promise.cancel();\r\n      }\r\n      call(opts.complete, err, null);\r\n      return;\r\n    }\r\n\r\n    // We already have the full document stored\r\n    if (Object.keys(diffs).length === 0) {\r\n      pending--;\r\n      isCompleted();\r\n      return;\r\n    }\r\n\r\n    var _enqueuer = function (rev) {\r\n        requests.enqueue(eachRev, [id, rev]);\r\n    };\r\n\r\n    for (var id in diffs) {\r\n      diffs[id].missing.forEach(_enqueuer);\r\n    }\r\n  }\r\n\r\n  function fetchRevsDiff(diff) {\r\n    target.revsDiff(diff, onRevsDiff);\r\n  }\r\n\r\n  function onChange(change) {\r\n    last_seq = change.seq;\r\n    results.push(change);\r\n    result.docs_read++;\r\n    pending++;\r\n    var diff = {};\r\n    diff[change.id] = change.changes.map(function(x) { return x.rev; });\r\n    requests.enqueue(fetchRevsDiff, [diff]);\r\n  }\r\n\r\n  function complete() {\r\n    completed = true;\r\n    isCompleted();\r\n  }\r\n\r\n  function isCompleted() {\r\n    if (completed && pending === 0) {\r\n      result.end_time = Date.now();\r\n      writeCheckpoint(target, repId, last_seq, function(err, res) {\r\n        call(opts.complete, err, result);\r\n      });\r\n    }\r\n  }\r\n\r\n  fetchCheckpoint(target, repId, function(err, checkpoint) {\r\n\r\n    if (err) {\r\n      return call(opts.complete, err);\r\n    }\r\n\r\n    last_seq = checkpoint;\r\n\r\n    // Was the replication cancelled by the caller before it had a chance\r\n    // to start. Shouldnt we be calling complete?\r\n    if (promise.cancelled) {\r\n      return;\r\n    }\r\n\r\n    var repOpts = {\r\n      limit: 25,\r\n      continuous: continuous,\r\n      since: last_seq,\r\n      style: 'all_docs',\r\n      onChange: onChange,\r\n      complete: complete,\r\n      doc_ids: doc_ids\r\n    };\r\n\r\n    if (opts.filter) {\r\n      repOpts.filter = opts.filter;\r\n    }\r\n\r\n    if (opts.query_params) {\r\n      repOpts.query_params = opts.query_params;\r\n    }\r\n\r\n    var changes = src.changes(repOpts);\r\n\r\n    if (opts.continuous) {\r\n      promise.cancel = changes.cancel;\r\n    }\r\n  });\r\n\r\n}\r\n\r\nfunction toPouch(db, callback) {\r\n  if (typeof db === 'string') {\r\n    return new Pouch(db, callback);\r\n  }\r\n  callback(null, db);\r\n}\r\n\r\nPouch.replicate = function(src, target, opts, callback) {\r\n  if (opts instanceof Function) {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (opts === undefined) {\r\n    opts = {};\r\n  }\r\n  opts.complete = callback;\r\n  var replicateRet = new Promise();\r\n  toPouch(src, function(err, src) {\r\n    if (err) {\r\n      return call(callback, err);\r\n    }\r\n    toPouch(target, function(err, target) {\r\n      if (err) {\r\n        return call(callback, err);\r\n      }\r\n      replicate(src, target, opts, replicateRet);\r\n    });\r\n  });\r\n  return replicateRet;\r\n};\r\n\r\n/*jshint strict: false */\r\n/*global request: true, Buffer: true, escape: true, $:true */\r\n/*global extend: true, Crypto: true */\r\n/*global chrome*/\r\n\r\n// Pretty dumb name for a function, just wraps callback calls so we dont\r\n// to if (callback) callback() everywhere\r\nvar call = function(fun) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  if (typeof fun === typeof Function) {\r\n    fun.apply(this, args);\r\n  }\r\n};\r\n\r\n// Wrapper for functions that call the bulkdocs api with a single doc,\r\n// if the first result is an error, return an error\r\nvar yankError = function(callback) {\r\n  return function(err, results) {\r\n    if (err || results[0].error) {\r\n      call(callback, err || results[0]);\r\n    } else {\r\n      call(callback, null, results[0]);\r\n    }\r\n  };\r\n};\r\n\r\nvar isLocalId = function(id) {\r\n  return (/^_local/).test(id);\r\n};\r\n\r\nvar isAttachmentId = function(id) {\r\n  return (/\\//.test(id) && !isLocalId(id) && !/^_design/.test(id));\r\n};\r\n\r\n// Parse document ids: docid[/attachid]\r\n//   - /attachid is optional, and can have slashes in it too\r\n//   - int ids and strings beginning with _design or _local are not split\r\n// returns an object: { docId: docid, attachmentId: attachid }\r\nvar parseDocId = function(id) {\r\n  var ids = (typeof id === 'string') && !(/^_(design|local)\\//.test(id)) ?\r\n    id.split('/') : [id];\r\n  return {\r\n    docId: ids[0],\r\n    attachmentId: ids.splice(1).join('/').replace(/^\\/+/, '')\r\n  };\r\n};\r\n\r\n// Determine id an ID is valid\r\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\r\n//   - any other string value is a valid id\r\nvar isValidId = function(id) {\r\n  if (/^_/.test(id)) {\r\n    return (/^_(design|local)/).test(id);\r\n  }\r\n  return true;\r\n};\r\n\r\n// Preprocess documents, parse their revisions, assign an id and a\r\n// revision for new writes that are missing them, etc\r\nvar parseDoc = function(doc, newEdits) {\r\n  var error = null;\r\n\r\n  // check for an attachment id and add attachments as needed\r\n  if (doc._id) {\r\n    var id = parseDocId(doc._id);\r\n    if (id.attachmentId !== '') {\r\n      var attachment = btoa(JSON.stringify(doc));\r\n      doc = {_id: id.docId};\r\n      if (!doc._attachments) {\r\n        doc._attachments = {};\r\n      }\r\n      doc._attachments[id.attachmentId] = {\r\n        content_type: 'application/json',\r\n        data: attachment\r\n      };\r\n    }\r\n  }\r\n\r\n  var nRevNum;\r\n  var newRevId;\r\n  var revInfo;\r\n  var opts = {status: 'available'};\r\n  if (doc._deleted) {\r\n    opts.deleted = true;\r\n  }\r\n\r\n  if (newEdits) {\r\n    if (!doc._id) {\r\n      doc._id = Math.uuid();\r\n    }\r\n    newRevId = Math.uuid(32, 16).toLowerCase();\r\n    if (doc._rev) {\r\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      if (!revInfo) {\r\n        throw \"invalid value for property '_rev'\";\r\n      }\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], {status: 'missing'}, [[newRevId, opts, []]]]\r\n      }];\r\n      nRevNum = parseInt(revInfo[1], 10) + 1;\r\n    } else {\r\n      doc._rev_tree = [{\r\n        pos: 1,\r\n        ids : [newRevId, opts, []]\r\n      }];\r\n      nRevNum = 1;\r\n    }\r\n  } else {\r\n    if (doc._revisions) {\r\n      doc._rev_tree = [{\r\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\r\n        ids: doc._revisions.ids.reduce(function(acc, x) {\r\n          if (acc === null) {\r\n            return [x, opts, []];\r\n          } else {\r\n            return [x, {status: 'missing'}, [acc]];\r\n          }\r\n        }, null)\r\n      }];\r\n      nRevNum = doc._revisions.start;\r\n      newRevId = doc._revisions.ids[0];\r\n    }\r\n    if (!doc._rev_tree) {\r\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      nRevNum = parseInt(revInfo[1], 10);\r\n      newRevId = revInfo[2];\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], opts, []]\r\n      }];\r\n    }\r\n  }\r\n\r\n  if (typeof doc._id !== 'string') {\r\n    error = Pouch.Errors.INVALID_ID;\r\n  }\r\n  else if (!isValidId(doc._id)) {\r\n    error = Pouch.Errors.RESERVED_ID;\r\n  }\r\n\r\n  doc._id = decodeURIComponent(doc._id);\r\n  doc._rev = [nRevNum, newRevId].join('-');\r\n\r\n  if (error) {\r\n    return error;\r\n  }\r\n\r\n  return Object.keys(doc).reduce(function(acc, key) {\r\n    if (/^_/.test(key) && key !== '_attachments') {\r\n      acc.metadata[key.slice(1)] = doc[key];\r\n    } else {\r\n      acc.data[key] = doc[key];\r\n    }\r\n    return acc;\r\n  }, {metadata : {}, data : {}});\r\n};\r\n\r\nvar compareRevs = function(a, b) {\r\n  // Sort by id\r\n  if (a.id !== b.id) {\r\n    return (a.id < b.id ? -1 : 1);\r\n  }\r\n  // Then by deleted\r\n  if (a.deleted ^ b.deleted) {\r\n    return (a.deleted ? -1 : 1);\r\n  }\r\n  // Then by rev id\r\n  if (a.rev_tree[0].pos === b.rev_tree[0].pos) {\r\n    return (a.rev_tree[0].ids < b.rev_tree[0].ids ? -1 : 1);\r\n  }\r\n  // Then by depth of edits\r\n  return (a.rev_tree[0].start < b.rev_tree[0].start ? -1 : 1);\r\n};\r\n\r\n\r\n// for every node in a revision tree computes its distance from the closest\r\n// leaf\r\nvar computeHeight = function(revs) {\r\n  var height = {};\r\n  var edges = [];\r\n  Pouch.merge.traverseRevTree(revs, function(isLeaf, pos, id, prnt) {\r\n    var rev = pos + \"-\" + id;\r\n    if (isLeaf) {\r\n      height[rev] = 0;\r\n    }\r\n    if (prnt !== undefined) {\r\n      edges.push({from: prnt, to: rev});\r\n    }\r\n    return rev;\r\n  });\r\n\r\n  edges.reverse();\r\n  edges.forEach(function(edge) {\r\n    if (height[edge.from] === undefined) {\r\n      height[edge.from] = 1 + height[edge.to];\r\n    } else {\r\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\r\n    }\r\n  });\r\n  return height;\r\n};\r\n\r\n// returns first element of arr satisfying callback predicate\r\nvar arrayFirst = function(arr, callback) {\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (callback(arr[i], i) === true) {\r\n      return arr[i];\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nvar filterChange = function(opts) {\r\n  return function(change) {\r\n    var req = {};\r\n    req.query = opts.query_params;\r\n    if (opts.filter && !opts.filter.call(this, change.doc, req)) {\r\n      return false;\r\n    }\r\n    if (opts.doc_ids && opts.doc_ids.indexOf(change.id) !== -1) {\r\n      return false;\r\n    }\r\n    if (!opts.include_docs) {\r\n      delete change.doc;\r\n    }\r\n    call(opts.onChange, change);\r\n    return true;\r\n  };\r\n};\r\n\r\n// returns array of all branches from root to leaf in the ids form:\r\n// [[id, ...], ...]\r\nvar rootToLeaf = function(tree) {\r\n  var paths = [];\r\n  Pouch.merge.traverseRevTree(tree, function(isLeaf, pos, id, history, opts) {\r\n    history = history ? history.slice(0) : [];\r\n    history.push({id: id, opts: opts});\r\n    if (isLeaf) {\r\n      var rootPos = pos + 1 - history.length;\r\n      paths.unshift({pos: rootPos, ids: history});\r\n    }\r\n    return history;\r\n  });\r\n  return paths;\r\n};\r\n\r\n// check if a specific revision of a doc has been deleted\r\n//  - metadata: the metadata object from the doc store\r\n//  - rev: (optional) the revision to check. defaults to winning revision\r\nvar isDeleted = function(metadata, rev) {\r\n  if (!rev) {\r\n    rev = Pouch.merge.winningRev(metadata);\r\n  }\r\n  if (rev.indexOf('-') >= 0) {\r\n    rev = rev.split('-')[1];\r\n  }\r\n  var deleted = false;\r\n  Pouch.merge.traverseRevTree(metadata.rev_tree, function(isLeaf, pos, id, acc, opts) {\r\n    if (id === rev) {\r\n      deleted = !!opts.deleted;\r\n    }\r\n  });\r\n\r\n  return deleted;\r\n};\r\n\r\nvar isChromeApp = function(){\r\n  return (typeof chrome !== \"undefined\" && typeof chrome.storage !== \"undefined\" && typeof chrome.storage.local !== \"undefined\");\r\n};\r\n\r\nvar isCordova = function(){\r\n  return (typeof cordova !== \"undefined\" || typeof PhoneGap !== \"undefined\" || typeof phonegap !== \"undefined\");\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  // use node.js's crypto library instead of the Crypto object created by deps/uuid.js\r\n  var crypto = require('crypto');\r\n  var Crypto = {\r\n    MD5: function(str) {\r\n      return crypto.createHash('md5').update(str).digest('hex');\r\n    }\r\n  };\r\n  var extend = require('./deps/extend');\r\n  var ajax = require('./deps/ajax');\r\n\r\n  request = require('request');\r\n  _ = require('underscore');\r\n  $ = _;\r\n\r\n  module.exports = {\r\n    Crypto: Crypto,\r\n    call: call,\r\n    yankError: yankError,\r\n    isLocalId: isLocalId,\r\n    isAttachmentId: isAttachmentId,\r\n    parseDocId: parseDocId,\r\n    parseDoc: parseDoc,\r\n    isDeleted: isDeleted,\r\n    compareRevs: compareRevs,\r\n    computeHeight: computeHeight,\r\n    arrayFirst: arrayFirst,\r\n    filterChange: filterChange,\r\n    atob: function(str) {\r\n      var base64 = new Buffer(str, 'base64');\r\n      // Node.js will just skip the characters it can't encode instead of\r\n      // throwing and exception\r\n      if (base64.toString('base64') !== str) {\r\n        throw(\"Cannot base64 encode full string\");\r\n      }\r\n      return base64.toString('binary');\r\n    },\r\n    btoa: function(str) {\r\n      return new Buffer(str, 'binary').toString('base64');\r\n    },\r\n    extend: extend,\r\n    ajax: ajax,\r\n    rootToLeaf: rootToLeaf,\r\n    isChromeApp: isChromeApp,\r\n    isCordova: isCordova\r\n  };\r\n}\r\n\r\nvar Changes = function() {\r\n\r\n  var api = {};\r\n  var listeners = {};\r\n\r\n  if (isChromeApp()){\r\n    chrome.storage.onChanged.addListener(function(e){\r\n      api.notify(e.db_name.newValue);//object only has oldValue, newValue members\r\n    });\r\n  }\r\n  else {\r\n    window.addEventListener(\"storage\", function(e) {\r\n      api.notify(e.key);\r\n    });\r\n  }\r\n\r\n  api.addListener = function(db_name, id, db, opts) {\r\n    if (!listeners[db_name]) {\r\n      listeners[db_name] = {};\r\n    }\r\n    listeners[db_name][id] = {\r\n      db: db,\r\n      opts: opts\r\n    };\r\n  };\r\n\r\n  api.removeListener = function(db_name, id) {\r\n    delete listeners[db_name][id];\r\n  };\r\n\r\n  api.clearListeners = function(db_name) {\r\n    delete listeners[db_name];\r\n  };\r\n\r\n  api.notifyLocalWindows = function(db_name){\r\n    //do a useless change on a storage thing\r\n    //in order to get other windows's listeners to activate\r\n    if (!isChromeApp()){\r\n      localStorage[db_name] = (localStorage[db_name] === \"a\") ? \"b\" : \"a\";\r\n    } else {\r\n      chrome.storage.local.set({db_name: db_name});\r\n    }\r\n  };\r\n\r\n  api.notify = function(db_name) {\r\n    if (!listeners[db_name]) { return; }\r\n\r\n    Object.keys(listeners[db_name]).forEach(function (i) {\r\n      var opts = listeners[db_name][i].opts;\r\n      listeners[db_name][i].db.changes({\r\n        include_docs: opts.include_docs,\r\n        conflicts: opts.conflicts,\r\n        continuous: false,\r\n        descending: false,\r\n        filter: opts.filter,\r\n        since: opts.since,\r\n        query_params: opts.query_params,\r\n        onChange: function(c) {\r\n          if (c.seq > opts.since && !opts.cancelled) {\r\n            opts.since = c.seq;\r\n            call(opts.onChange, c);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\n\r\n/*globals Pouch: true, yankError: false, extend: false, call: false, parseDocId: false, traverseRevTree: false */\r\n/*globals arrayFirst: false, rootToLeaf: false, computeHeight: false */\r\n/*globals cordova, isCordova */\r\n\r\n\"use strict\";\r\n\r\n/*\r\n * A generic pouch adapter\r\n */\r\nvar PouchAdapter = function(opts, callback) {\r\n\r\n  var api = {};\r\n\r\n  var customApi = Pouch.adapters[opts.adapter](opts, function(err, db) {\r\n    if (err) {\r\n      if (callback) {\r\n        callback(err);\r\n      }\r\n      return;\r\n    }\r\n\r\n    for (var j in api) {\r\n      if (!db.hasOwnProperty(j)) {\r\n        db[j] = api[j];\r\n      }\r\n    }\r\n\r\n    // Don't call Pouch.open for ALL_DBS\r\n    // Pouch.open saves the db's name into ALL_DBS\r\n    if (opts.name === Pouch.prefix + Pouch.ALL_DBS) {\r\n      callback(err, db);\r\n    } else {\r\n      Pouch.open(opts, function(err) {\r\n        callback(err, db);\r\n      });\r\n    }\r\n  });\r\n\r\n  var auto_compaction = (opts.auto_compaction === true);\r\n\r\n  // wraps a callback with a function that runs compaction after each edit\r\n  var autoCompact = function(callback) {\r\n    if (!auto_compaction) {\r\n      return callback;\r\n    }\r\n    return function(err, res) {\r\n      if (err) {\r\n        call(callback, err);\r\n      } else {\r\n        var count = res.length;\r\n        var decCount = function() {\r\n          count--;\r\n          if (!count) {\r\n            call(callback, null, res);\r\n          }\r\n        };\r\n        res.forEach(function(doc) {\r\n          if (doc.ok) {\r\n            // TODO: we need better error handling\r\n            compactDocument(doc.id, 1, decCount);\r\n          } else {\r\n            decCount();\r\n          }\r\n        });\r\n      }\r\n    };\r\n  };\r\n\r\n  api.post = function (doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return customApi.bulkDocs({docs: [doc]}, opts,\r\n        autoCompact(yankError(callback)));\r\n  };\r\n\r\n  api.put = function(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (!doc || !('_id' in doc)) {\r\n      return call(callback, Pouch.Errors.MISSING_ID);\r\n    }\r\n    return customApi.bulkDocs({docs: [doc]}, opts,\r\n        autoCompact(yankError(callback)));\r\n  };\r\n\r\n  api.putAttachment = function (id, rev, blob, type, callback) {\r\n    if (typeof type === 'function') {\r\n      callback = type;\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    if (typeof type === 'undefined') {\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    id = parseDocId(id);\r\n\r\n    function createAttachment(doc) {\r\n      doc._attachments = doc._attachments || {};\r\n      doc._attachments[id.attachmentId] = {\r\n        content_type: type,\r\n        data: blob\r\n      };\r\n      api.put(doc, callback);\r\n    }\r\n\r\n    api.get(id.docId, function(err, doc) {\r\n      // create new doc\r\n      if (err && err.error === Pouch.Errors.MISSING_DOC.error) {\r\n        createAttachment({_id: id.docId});\r\n        return;\r\n      }\r\n      if (err) {\r\n        call(callback, err);\r\n        return;\r\n      }\r\n\r\n      if (doc._rev !== rev) {\r\n        call(callback, Pouch.Errors.REV_CONFLICT);\r\n        return;\r\n      }\r\n\r\n      createAttachment(doc);\r\n    });\r\n  };\r\n\r\n  api.removeAttachment = function (id, rev, callback) {\r\n    id = parseDocId(id);\r\n    api.get(id.docId, function(err, obj) {\r\n      if (err) {\r\n        call(callback, err);\r\n        return;\r\n      }\r\n\r\n      if (obj._rev !== rev) {\r\n        call(callback, Pouch.Errors.REV_CONFLICT);\r\n        return;\r\n      }\r\n\r\n      obj._attachments = obj._attachments || {};\r\n      delete obj._attachments[id.attachmentId];\r\n      api.put(obj, callback);\r\n    });\r\n  };\r\n\r\n  api.remove = function (doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (opts === undefined) {\r\n      opts = {};\r\n    }\r\n    opts.was_delete = true;\r\n    var newDoc = {_id: doc._id, _rev: doc._rev};\r\n    newDoc._deleted = true;\r\n    return customApi.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.revsDiff = function (req, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    var ids = Object.keys(req);\r\n    var count = 0;\r\n    var missing = {};\r\n\r\n    function readDoc(err, doc, id) {\r\n      req[id].map(function(revId) {\r\n        var matches = function(x) { return x.rev !== revId; };\r\n        if (!doc || doc._revs_info.every(matches)) {\r\n          if (!missing[id]) {\r\n            missing[id] = {missing: []};\r\n          }\r\n          missing[id].missing.push(revId);\r\n        }\r\n      });\r\n\r\n      if (++count === ids.length) {\r\n        return call(callback, null, missing);\r\n      }\r\n    }\r\n\r\n    ids.map(function(id) {\r\n      api.get(id, {revs_info: true}, function(err, doc) {\r\n        readDoc(err, doc, id);\r\n      });\r\n    });\r\n  };\r\n\r\n  // compact one document and fire callback\r\n  // by compacting we mean removing all revisions which\r\n  // are further from the leaf in revision tree than max_height\r\n  var compactDocument = function(docId, max_height, callback) {\r\n    customApi._getRevisionTree(docId, function(err, rev_tree){\r\n      if (err) {\r\n        return call(callback);\r\n      }\r\n      var height = computeHeight(rev_tree);\r\n      var candidates = [];\r\n      var revs = [];\r\n      Object.keys(height).forEach(function(rev) {\r\n        if (height[rev] > max_height) {\r\n          candidates.push(rev);\r\n        }\r\n      });\r\n\r\n      Pouch.merge.traverseRevTree(rev_tree, function(isLeaf, pos, revHash, ctx, opts) {\r\n        var rev = pos + '-' + revHash;\r\n        if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\r\n          opts.status = 'missing';\r\n          revs.push(rev);\r\n        }\r\n      });\r\n      customApi._doCompaction(docId, rev_tree, revs, callback);\r\n    });\r\n  };\r\n\r\n  // compact the whole database using single document\r\n  // compaction\r\n  api.compact = function(callback) {\r\n    api.changes({complete: function(err, res) {\r\n      if (err) {\r\n        call(callback); // TODO: silently fail\r\n        return;\r\n      }\r\n      var count = res.results.length;\r\n      if (!count) {\r\n        call(callback);\r\n        return;\r\n      }\r\n      res.results.forEach(function(row) {\r\n        compactDocument(row.id, 0, function() {\r\n          count--;\r\n          if (!count) {\r\n            call(callback);\r\n          }\r\n        });\r\n      });\r\n    }});\r\n  };\r\n\r\n  /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\r\n  api.get = function (id, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('get', arguments);\r\n      return;\r\n    }\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    var leaves = [];\r\n    function finishOpenRevs() {\r\n      var result = [];\r\n      var count = leaves.length;\r\n      if (!count) {\r\n        return call(callback, null, result);\r\n      }\r\n      // order with open_revs is unspecified\r\n      leaves.forEach(function(leaf){\r\n        api.get(id, {rev: leaf, revs: opts.revs}, function(err, doc){\r\n          if (!err) {\r\n            result.push({ok: doc});\r\n          } else {\r\n            result.push({missing: leaf});\r\n          }\r\n          count--;\r\n          if(!count) {\r\n            call(callback, null, result);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    if (opts.open_revs) {\r\n      if (opts.open_revs === \"all\") {\r\n        customApi._getRevisionTree(id, function(err, rev_tree){\r\n          if (err) {\r\n            // if there's no such document we should treat this\r\n            // situation the same way as if revision tree was empty\r\n            rev_tree = [];\r\n          }\r\n          leaves = Pouch.merge.collectLeaves(rev_tree).map(function(leaf){\r\n            return leaf.rev;\r\n          });\r\n          finishOpenRevs();\r\n        });\r\n      } else {\r\n        if (Array.isArray(opts.open_revs)) {\r\n          leaves = opts.open_revs;\r\n          for (var i = 0; i < leaves.length; i++) {\r\n            var l = leaves[i];\r\n            // looks like it's the only thing couchdb checks\r\n            if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\r\n              return call(callback, Pouch.error(Pouch.Errors.BAD_REQUEST,\r\n                \"Invalid rev format\" ));\r\n            }\r\n          }\r\n          finishOpenRevs();\r\n        } else {\r\n          return call(callback, Pouch.error(Pouch.Errors.UNKNOWN_ERROR,\r\n            'function_clause'));\r\n        }\r\n      }\r\n      return; // open_revs does not like other options\r\n    }\r\n\r\n    id = parseDocId(id);\r\n    if (id.attachmentId !== '') {\r\n      return customApi._get(id, opts, function(err, result){\r\n        if (err) {\r\n          return call(callback, err);\r\n        }\r\n        if (result.doc._attachments && result.doc._attachments[id.attachmentId]) {\r\n          customApi._getAttachment(result.doc._attachments[id.attachmentId],\r\n                                   {encode: false, ctx: result.ctx}, function(err, data) {\r\n            return call(callback, null, data);\r\n          });\r\n        } else {\r\n          return call(callback, Pouch.Errors.MISSING_DOC);\r\n        }\r\n      });\r\n    }\r\n\r\n    return customApi._get(id, opts, function(err, result) {\r\n      if (err) {\r\n        return call(callback, err);\r\n      }\r\n\r\n      var doc = result.doc;\r\n      var metadata = result.metadata;\r\n      var ctx = result.ctx;\r\n\r\n      if (opts.conflicts) {\r\n        var conflicts = Pouch.merge.collectConflicts(metadata);\r\n        if (conflicts.length) {\r\n          doc._conflicts = conflicts;\r\n        }\r\n      }\r\n\r\n      if (opts.revs || opts.revs_info) {\r\n        var paths = rootToLeaf(metadata.rev_tree);\r\n        var path = arrayFirst(paths, function(arr) {\r\n          return arr.ids.map(function(x) { return x.id; })\r\n            .indexOf(doc._rev.split('-')[1]) !== -1;\r\n        });\r\n\r\n        path.ids.splice(path.ids.map(function(x) {return x.id;})\r\n                        .indexOf(doc._rev.split('-')[1]) + 1);\r\n        path.ids.reverse();\r\n\r\n        if (opts.revs) {\r\n          doc._revisions = {\r\n            start: (path.pos + path.ids.length) - 1,\r\n            ids: path.ids.map(function(rev) {\r\n              return rev.id;\r\n            })\r\n          };\r\n        }\r\n        if (opts.revs_info) {\r\n          var pos =  path.pos + path.ids.length;\r\n          doc._revs_info = path.ids.map(function(rev) {\r\n            pos--;\r\n            return {\r\n              rev: pos + '-' + rev.id,\r\n              status: rev.opts.status\r\n            };\r\n          });\r\n        }\r\n      }\r\n\r\n      if (opts.attachments && doc._attachments) {\r\n        var attachments = doc._attachments;\r\n        var count = Object.keys(attachments).length;\r\n        Object.keys(attachments).forEach(function(key) {\r\n          customApi._getAttachment(attachments[key], {encode: true, ctx: ctx}, function(err, data) {\r\n            doc._attachments[key].data = data;\r\n            if (!--count){\r\n              call(callback, null, doc);\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        if (doc._attachments){\r\n          for (var key in doc._attachments) {\r\n            doc._attachments[key].stub = true;\r\n          }\r\n        }\r\n        call(callback, null, doc);\r\n      }\r\n    });\r\n  };\r\n\r\n  api.getAttachment = function(id, opts, callback) {\r\n    if (opts instanceof Function) {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    customApi.get(id, function(err, res) {\r\n      callback(err, res);\r\n    });\r\n  };\r\n\r\n  api.allDocs = function(opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('allDocs', arguments);\r\n      return;\r\n    }\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if ('keys' in opts) {\r\n      if ('startkey' in opts) {\r\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\r\n          'Query parameter `start_key` is not compatible with multi-get'\r\n        ));\r\n        return;\r\n      }\r\n      if ('endkey' in opts) {\r\n        call(callback, Pouch.error(Pouch.Errors.QUERY_PARSE_ERROR,\r\n          'Query parameter `end_key` is not compatible with multi-get'\r\n        ));\r\n        return;\r\n      }\r\n    }\r\n\r\n    return customApi._allDocs(opts, callback);\r\n  };\r\n\r\n  api.changes = function(opts) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('changes', arguments);\r\n      return;\r\n    }\r\n    opts = extend(true, {}, opts);\r\n\r\n    // 0 and 1 should return 1 document\r\n    opts.limit = opts.limit === 0 ? 1 : opts.limit;\r\n    return customApi._changes(opts);\r\n  };\r\n\r\n  api.close = function(callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('close', arguments);\r\n      return;\r\n    }\r\n    return customApi._close(callback);\r\n  };\r\n\r\n  api.info = function(callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('info', arguments);\r\n      return;\r\n    }\r\n    return customApi._info(callback);\r\n  };\r\n\r\n  api.id = function() {\r\n    return customApi._id();\r\n  };\r\n\r\n  api.type = function() {\r\n    return (typeof customApi._type === 'function') ? customApi._type() : opts.adapter;\r\n  };\r\n\r\n  api.bulkDocs = function(req, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('bulkDocs', arguments);\r\n      return;\r\n    }\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {};\r\n    } else {\r\n      opts = extend(true, {}, opts);\r\n    }\r\n\r\n    if (!req || !req.docs || req.docs.length < 1) {\r\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\r\n    }\r\n\r\n    if (!Array.isArray(req.docs)) {\r\n      return call(callback, Pouch.Errors.QUERY_PARSE_ERROR);\r\n    }\r\n\r\n    req = extend(true, {}, req);\r\n    if (!('new_edits' in opts)) {\r\n      opts.new_edits = true;\r\n    }\r\n\r\n    return customApi._bulkDocs(req, opts, autoCompact(callback));\r\n  };\r\n\r\n  /* End Wrappers */\r\n  var taskqueue = {};\r\n\r\n  taskqueue.ready = false;\r\n  taskqueue.queue = [];\r\n\r\n  api.taskqueue = {};\r\n\r\n  api.taskqueue.execute = function (db) {\r\n    if (taskqueue.ready) {\r\n      taskqueue.queue.forEach(function(d) {\r\n        db[d.task].apply(null, d.parameters);\r\n      });\r\n    }\r\n  };\r\n\r\n  api.taskqueue.ready = function() {\r\n    if (arguments.length === 0) {\r\n      return taskqueue.ready;\r\n    }\r\n    taskqueue.ready = arguments[0];\r\n  };\r\n\r\n  api.taskqueue.addTask = function(task, parameters) {\r\n    taskqueue.queue.push({ task: task, parameters: parameters });\r\n  };\r\n\r\n  api.replicate = {};\r\n\r\n  api.replicate.from = function (url, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(url, customApi, opts, callback);\r\n  };\r\n\r\n  api.replicate.to = function (dbName, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(customApi, dbName, opts, callback);\r\n  };\r\n\r\n  for (var j in api) {\r\n    if (!customApi.hasOwnProperty(j)) {\r\n      customApi[j] = api[j];\r\n    }\r\n  }\r\n\r\n  // Http adapter can skip setup so we force the db to be ready and execute any jobs\r\n  if (opts.skipSetup) {\r\n    api.taskqueue.ready(true);\r\n    api.taskqueue.execute(api);\r\n  }\r\n\r\n  if (isCordova()){\r\n    //to inform websql adapter that we can use api\r\n    cordova.fireWindowEvent(opts.name + \"_pouch\", {});\r\n  }\r\n  return customApi;\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = PouchAdapter;\r\n}\r\n\r\n/*globals Pouch: true, call: false, ajax: true */\r\n/*globals require: false, console: false */\r\n\r\n\"use strict\";\r\n\r\nvar HTTP_TIMEOUT = 10000;\r\n\r\n// parseUri 1.2.2\r\n// (c) Steven Levithan <stevenlevithan.com>\r\n// MIT License\r\nfunction parseUri (str) {\r\n  var o = parseUri.options;\r\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\r\n  var uri = {};\r\n  var i = 14;\r\n\r\n  while (i--) {\r\n    uri[o.key[i]] = m[i] || \"\";\r\n  }\r\n\r\n  uri[o.q.name] = {};\r\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n    if ($1) {\r\n      uri[o.q.name][$1] = $2;\r\n    }\r\n  });\r\n\r\n  return uri;\r\n}\r\n\r\nparseUri.options = {\r\n  strictMode: false,\r\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\r\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\r\n  q:   {\r\n    name:   \"queryKey\",\r\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n  },\r\n  parser: {\r\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n  }\r\n};\r\n\r\n// Get all the information you possibly can about the URI given by name and\r\n// return it as a suitable object.\r\nfunction getHost(name) {\r\n  // If the given name contains \"http:\"\r\n  if (/http(s?):/.test(name)) {\r\n    // Prase the URI into all its little bits\r\n    var uri = parseUri(name);\r\n\r\n    // Store the fact that it is a remote URI\r\n    uri.remote = true;\r\n\r\n    // Store the user and password as a separate auth object\r\n    if (uri.user || uri.password) {\r\n      uri.auth = {username: uri.user, password: uri.password};\r\n    }\r\n\r\n    // Split the path part of the URI into parts using '/' as the delimiter\r\n    // after removing any leading '/' and any trailing '/'\r\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\r\n\r\n    // Store the first part as the database name and remove it from the parts\r\n    // array\r\n    uri.db = parts.pop();\r\n\r\n    // Restore the path by joining all the remaining parts (all the parts\r\n    // except for the database name) with '/'s\r\n    uri.path = parts.join('/');\r\n\r\n    return uri;\r\n  }\r\n\r\n  // If the given name does not contain 'http:' then return a very basic object\r\n  // with no host, the current path, the given name as the database name and no\r\n  // username/password\r\n  return {host: '', path: '/', db: name, auth: false};\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genDBUrl(opts, path) {\r\n  // If the host is remote\r\n  if (opts.remote) {\r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    var pathDel = !opts.path ? '' : '/';\r\n\r\n    // Return the URL made up of all the host's information and the given path\r\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\r\n      opts.path + pathDel + opts.db + '/' + path;\r\n  }\r\n\r\n  // If the host is not remote, then return the URL made up of just the\r\n  // database name and the given path\r\n  return '/' + opts.db + '/' + path;\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genUrl(opts, path) {\r\n  if (opts.remote) {\r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    var pathDel = !opts.path ? '' : '/';\r\n    \r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + opts.path + pathDel + path;\r\n  }\r\n  \r\n  return '/' + path;\r\n}\r\n\r\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\r\nvar HttpPouch = function(opts, callback) {\r\n\r\n  // Parse the URI given by opts.name into an easy-to-use object\r\n  var host = getHost(opts.name);\r\n  if (opts.auth) {\r\n    host.auth = opts.auth;\r\n  }\r\n\r\n  // Generate the database URL based on the host\r\n  var db_url = genDBUrl(host, '');\r\n\r\n  // The functions that will be publically available for HttpPouch\r\n  var api = {};\r\n\r\n  var uuids = {\r\n    list: [],\r\n    get: function(opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {count: 10};\r\n      }\r\n      var cb = function(err, body) {\r\n        if (err || !('uuids' in body)) {\r\n          call(callback, err || Pouch.Errors.UNKNOWN_ERROR);\r\n        } else {\r\n          uuids.list = uuids.list.concat(body.uuids);\r\n          call(callback, null, \"OK\");\r\n        }\r\n      };\r\n      var params = '?count=' + opts.count;\r\n      ajax({\r\n        auth: host.auth,\r\n        method: 'GET',\r\n        url: genUrl(host, '_uuids') + params\r\n      }, cb);\r\n    }\r\n  };\r\n\r\n  // Create a new CouchDB database based on the given opts\r\n  var createDB = function(){\r\n    ajax({auth: host.auth, method: 'PUT', url: db_url}, function(err, ret) {\r\n      // If we get an \"Unauthorized\" error\r\n      if (err && err.status === 401) {\r\n        // Test if the database already exists\r\n        ajax({auth: host.auth, method: 'HEAD', url: db_url}, function (err, ret) {\r\n          // If there is still an error\r\n          if (err) {\r\n            // Give the error to the callback to deal with\r\n            call(callback, err);\r\n          } else {\r\n            // Continue as if there had been no errors\r\n            call(callback, null, api);\r\n          }\r\n        });\r\n        // If there were no errros or if the only error is \"Precondition Failed\"\r\n        // (note: \"Precondition Failed\" occurs when we try to create a database\r\n        // that already exists)\r\n      } else if (!err || err.status === 412) {\r\n        // Continue as if there had been no errors\r\n        call(callback, null, api);\r\n      } else {\r\n        call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n      }\r\n    });\r\n  };\r\n  if (!opts.skipSetup) {\r\n    ajax({auth: host.auth, method: 'GET', url: db_url}, function(err, ret) {\r\n      //check if the db exists\r\n      if (err) {\r\n        if (err.status === 404) {\r\n          //if it doesn't, create it\r\n          createDB();\r\n        } else {\r\n          call(callback, err);\r\n        }\r\n      } else {\r\n        //go do stuff with the db\r\n        call(callback, null, api);\r\n        }\r\n    });\r\n  }\r\n\r\n  api.type = function() {\r\n    return 'http';\r\n  };\r\n\r\n  // The HttpPouch's ID is its URL\r\n  api.id = function() {\r\n    return genDBUrl(host, '');\r\n  };\r\n\r\n  api.request = function(options, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('request', arguments);\r\n      return;\r\n    }\r\n    options.auth = host.auth;\r\n    options.url = genDBUrl(host, options.url);\r\n    ajax(options, callback);\r\n  };\r\n\r\n  // Sends a POST request to the host calling the couchdb _compact function\r\n  //    version: The version of CouchDB it is running\r\n  api.compact = function(opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('compact', arguments);\r\n      return;\r\n    }\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    ajax({\r\n      auth: host.auth,\r\n      url: genDBUrl(host, '_compact'),\r\n      method: 'POST'\r\n    }, function() {\r\n      function ping() {\r\n        api.info(function(err, res) {\r\n          if (!res.compact_running) {\r\n            call(callback, null);\r\n          } else {\r\n            setTimeout(ping, opts.interval || 200);\r\n          }\r\n        });\r\n      }\r\n      // Ping the http if it's finished compaction\r\n      if (typeof callback === \"function\") {\r\n        ping();\r\n      }\r\n    });\r\n  };\r\n\r\n  // Calls GET on the host, which gets back a JSON string containing\r\n  //    couchdb: A welcome string\r\n  //    version: The version of CouchDB it is running\r\n  api.info = function(callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('info', arguments);\r\n      return;\r\n    }\r\n    ajax({\r\n      auth: host.auth,\r\n      method:'GET',\r\n      url: genDBUrl(host, '')\r\n    }, callback);\r\n  };\r\n\r\n  // Get the document with the given id from the database given by host.\r\n  // The id could be solely the _id in the database, or it may be a\r\n  // _design/ID or _local/ID path\r\n  api.get = function(id, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('get', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.revs value to the list of parameters.\r\n    // If revs=true then the resulting JSON will include a field\r\n    // _revisions containing an array of the revision IDs.\r\n    if (opts.revs) {\r\n      params.push('revs=true');\r\n    }\r\n\r\n    // If it exists, add the opts.revs_info value to the list of parameters.\r\n    // If revs_info=true then the resulting JSON will include the field\r\n    // _revs_info containing an array of objects in which each object\r\n    // representing an available revision.\r\n    if (opts.revs_info) {\r\n      params.push('revs_info=true');\r\n    }\r\n\r\n    // If it exists, add the opts.open_revs value to the list of parameters.\r\n    // If open_revs=all then the resulting JSON will include all the leaf\r\n    // revisions. If open_revs=[\"rev1\", \"rev2\",...] then the resulting JSON\r\n    // will contain an array of objects containing data of all revisions\r\n    if (opts.open_revs) {\r\n      if (opts.open_revs !== \"all\") {\r\n        opts.open_revs = JSON.stringify(opts.open_revs);\r\n      }\r\n      params.push('open_revs=' + opts.open_revs);\r\n    }\r\n\r\n    // If it exists, add the opts.attachments value to the list of parameters.\r\n    // If attachments=true the resulting JSON will include the base64-encoded\r\n    // contents in the \"data\" property of each attachment.\r\n    if (opts.attachments) {\r\n      params.push('attachments=true');\r\n    }\r\n\r\n    // If it exists, add the opts.rev value to the list of parameters.\r\n    // If rev is given a revision number then get the specified revision.\r\n    if (opts.rev) {\r\n      params.push('rev=' + opts.rev);\r\n    }\r\n\r\n    // If it exists, add the opts.conflicts value to the list of parameters.\r\n    // If conflicts=true then the resulting JSON will include the field\r\n    // _conflicts containing all the conflicting revisions.\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=' + opts.conflicts);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    params = params === '' ? '' : '?' + params;\r\n\r\n    // Set the options for the ajax call\r\n    var options = {\r\n      auth: host.auth,\r\n      method: 'GET',\r\n      url: genDBUrl(host, id + params)\r\n    };\r\n\r\n    // If the given id contains at least one '/' and the part before the '/'\r\n    // is NOT \"_design\" and is NOT \"_local\"\r\n    // OR\r\n    // If the given id contains at least two '/' and the part before the first\r\n    // '/' is \"_design\".\r\n    // TODO This second condition seems strange since if parts[0] === '_design'\r\n    // then we already know that parts[0] !== '_local'.\r\n    var parts = id.split('/');\r\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\r\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\r\n      // Binary is expected back from the server\r\n      options.binary = true;\r\n    }\r\n\r\n    // Get the document\r\n    ajax(options, function(err, doc, xhr) {\r\n      // If the document does not exist, send an error to the callback\r\n      if (err) {\r\n        return call(callback, err);\r\n      }\r\n\r\n      // Send the document to the callback\r\n      call(callback, null, doc, xhr);\r\n    });\r\n  };\r\n\r\n  // Delete the document given by doc from the database given by host.\r\n  api.remove = function(doc, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('remove', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Delete the document\r\n    ajax({\r\n      auth: host.auth,\r\n      method:'DELETE',\r\n      url: genDBUrl(host, doc._id) + '?rev=' + doc._rev\r\n    }, callback);\r\n  };\r\n\r\n  // Remove the attachment given by the id and rev\r\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('removeAttachment', arguments);\r\n      return;\r\n    }\r\n    ajax({\r\n      auth: host.auth,\r\n      method: 'DELETE',\r\n      url: genDBUrl(host, id) + '?rev=' + rev\r\n    }, callback);\r\n  };\r\n\r\n  // Add the attachment given by blob and its contentType property\r\n  // to the document with the given id, the revision given by rev, and\r\n  // add it to the database given by host.\r\n  api.putAttachment = function(id, rev, blob, type, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('putAttachment', arguments);\r\n      return;\r\n    }\r\n    if (typeof type === 'function') {\r\n      callback = type;\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    if (typeof type === 'undefined') {\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    var url = genDBUrl(host, id);\r\n    if (rev) {\r\n      url += '?rev=' + rev;\r\n    }\r\n\r\n    // Add the attachment\r\n    ajax({\r\n      auth: host.auth,\r\n      method:'PUT',\r\n      url: url,\r\n      headers: {'Content-Type': type},\r\n      processData: false,\r\n      body: blob\r\n    }, callback);\r\n  };\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This fails if the doc has no _id field.\r\n  api.put = function(doc, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('put', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (!doc || !('_id' in doc)) {\r\n      return call(callback, Pouch.Errors.MISSING_ID);\r\n    }\r\n\r\n    // List of parameter to add to the PUT request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.new_edits value to the list of parameters.\r\n    // If new_edits = false then the database will NOT assign this document a\r\n    // new revision number\r\n    if (opts && typeof opts.new_edits !== 'undefined') {\r\n      params.push('new_edits=' + opts.new_edits);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    // Add the document\r\n    ajax({\r\n      auth: host.auth,\r\n      method: 'PUT',\r\n      url: genDBUrl(host, doc._id) + params,\r\n      body: doc\r\n    }, callback);\r\n  };\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This does not assume that doc is a new document (i.e. does not\r\n  // have a _id or a _rev field.\r\n  api.post = function(doc, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('post', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (! (\"_id\" in doc)) {\r\n      if (uuids.list.length > 0) {\r\n        doc._id = uuids.list.pop();\r\n        api.put(doc, opts, callback);\r\n      }else {\r\n        uuids.get(function(err, resp) {\r\n          if (err) {\r\n            return call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n          }\r\n          doc._id = uuids.list.pop();\r\n          api.put(doc, opts, callback);\r\n        });\r\n      }\r\n    } else {\r\n      api.put(doc, opts, callback);\r\n    }\r\n  };\r\n\r\n  // Update/create multiple documents given by req in the database\r\n  // given by host.\r\n  api.bulkDocs = function(req, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('bulkDocs', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {};\r\n    }\r\n\r\n    // If opts.new_edits exists add it to the document data to be\r\n    // send to the database.\r\n    // If new_edits=false then it prevents the database from creating\r\n    // new revision numbers for the documents. Instead it just uses\r\n    // the old ones. This is used in database replication.\r\n    if (typeof opts.new_edits !== 'undefined') {\r\n      req.new_edits = opts.new_edits;\r\n    }\r\n\r\n    // Update/create the documents\r\n    ajax({\r\n      auth: host.auth,\r\n      method:'POST',\r\n      url: genDBUrl(host, '_bulk_docs'),\r\n      body: req\r\n    }, callback);\r\n  };\r\n\r\n  // Get a listing of the documents in the database given\r\n  // by host and ordered by increasing id.\r\n  api.allDocs = function(opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('allDocs', arguments);\r\n      return;\r\n    }\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n    var body;\r\n    var method = 'GET';\r\n\r\n    // TODO I don't see conflicts as a valid parameter for a\r\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=true');\r\n    }\r\n\r\n    // If opts.descending is truthy add it to params\r\n    if (opts.descending) {\r\n      params.push('descending=true');\r\n    }\r\n\r\n    // If opts.include_docs exists, add the include_docs value to the\r\n    // list of parameters.\r\n    // If include_docs=true then include the associated document with each\r\n    // result.\r\n    if (opts.include_docs) {\r\n      params.push('include_docs=true');\r\n    }\r\n\r\n    // If opts.startkey exists, add the startkey value to the list of\r\n    // parameters.\r\n    // If startkey is given then the returned list of documents will\r\n    // start with the document whose id is startkey.\r\n    if (opts.startkey) {\r\n      params.push('startkey=' +\r\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\r\n    }\r\n\r\n    // If opts.endkey exists, add the endkey value to the list of parameters.\r\n    // If endkey is given then the returned list of docuemnts will\r\n    // end with the document whose id is endkey.\r\n    if (opts.endkey) {\r\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\r\n    }\r\n\r\n    // If opts.limit exists, add the limit value to the parameter list.\r\n    if (opts.limit) {\r\n      params.push('limit=' + opts.limit);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\r\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\r\n    if (typeof opts.keys !== 'undefined') {\r\n      method = 'POST';\r\n      body = JSON.stringify({keys:opts.keys});\r\n    }\r\n\r\n    // Get the document listing\r\n    ajax({\r\n      auth: host.auth,\r\n      method: method,\r\n      url: genDBUrl(host, '_all_docs' + params),\r\n      body: body\r\n    }, callback);\r\n  };\r\n  // Get a list of changes made to documents in the database given by host.\r\n  // TODO According to the README, there should be two other methods here,\r\n  // api.changes.addListener and api.changes.removeListener.\r\n  api.changes = function(opts) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('changes', arguments);\r\n      return;\r\n    }\r\n\r\n    if (Pouch.DEBUG) {\r\n      console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\r\n    }\r\n\r\n    // Query string of all the parameters to add to the GET request\r\n    var params = [],\r\n        paramsStr;\r\n\r\n    if (opts.style) {\r\n      params.push('style='+opts.style);\r\n    }\r\n\r\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\r\n    // function, add the include_docs value to the query string.\r\n    // If include_docs=true then include the associated document with each\r\n    // result.\r\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\r\n      params.push('include_docs=true');\r\n    }\r\n\r\n    // If opts.continuous exists, add the feed value to the query string.\r\n    // If feed=longpoll then it waits for either a timeout or a change to\r\n    // occur before returning.\r\n    if (opts.continuous) {\r\n      params.push('feed=longpoll');\r\n    }\r\n\r\n    // If opts.conflicts exists, add the conflicts value to the query string.\r\n    // TODO I can't find documentation of what conflicts=true does. See\r\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=true');\r\n    }\r\n\r\n    if (opts.limit || opts.limit === 0) {\r\n      params.push('limit=' + opts.limit);\r\n    }\r\n\r\n    // If opts.descending exists, add the descending value to the query string.\r\n    // if descending=true then the change results are returned in\r\n    // descending order (most recent change first).\r\n    if (opts.descending) {\r\n      params.push('descending=true');\r\n    }\r\n\r\n    // If opts.filter exists and is a string then add the filter value\r\n    // to the query string.\r\n    // If filter is given a string containing the name of a filter in\r\n    // the design, then only documents passing through the filter will\r\n    // be returned.\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      params.push('filter=' + opts.filter);\r\n    }\r\n\r\n    // If opts.query_params exists, pass it through to the changes request.\r\n    // These parameters may be used by the filter on the source database.\r\n    if (opts.query_params && typeof opts.query_params === 'object') {\r\n      for (var param_name in opts.query_params) {\r\n        if (opts.query_params.hasOwnProperty(param_name)) {\r\n          params.push(param_name+'='+opts.query_params[param_name]);\r\n        }\r\n      }\r\n    }\r\n\r\n    paramsStr = '?';\r\n\r\n    if (params.length > 0) {\r\n      paramsStr += params.join('&');\r\n    }\r\n\r\n    var xhr;\r\n    var last_seq;\r\n\r\n    // Get all the changes starting wtih the one immediately after the\r\n    // sequence number given by since.\r\n    var fetch = function(since, callback) {\r\n      // Set the options for the ajax call\r\n      var xhrOpts = {\r\n        auth: host.auth, method:'GET',\r\n        url: genDBUrl(host, '_changes' + paramsStr + '&since=' + since),\r\n        timeout: null          // _changes can take a long time to generate, especially when filtered\r\n      };\r\n      last_seq = since;\r\n\r\n      if (opts.aborted) {\r\n        return;\r\n      }\r\n\r\n      // Get the changes\r\n      xhr = ajax(xhrOpts, callback);\r\n    };\r\n\r\n    // If opts.since exists, get all the changes from the sequence\r\n    // number given by opts.since. Otherwise, get all the changes\r\n    // from the sequence number 0.\r\n    var fetchTimeout = 10;\r\n    var fetchRetryCount = 0;\r\n    var fetched = function(err, res) {\r\n      // If the result of the ajax call (res) contains changes (res.results)\r\n      if (res && res.results) {\r\n        // For each change\r\n        var hasFilter = opts.filter && typeof opts.filter === 'function';\r\n        var req = {};\r\n        req.query = opts.query_params;\r\n        res.results = res.results.filter(function(c) {\r\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc, req])) {\r\n            return false;\r\n          }\r\n          if (opts.doc_ids && opts.doc_ids.indexOf(c.id) !== -1) {\r\n            return false;\r\n          }\r\n          // Process the change\r\n          call(opts.onChange, c);\r\n          return true;\r\n        });\r\n      }\r\n      // The changes feed may have timed out with no results\r\n      // if so reuse last update sequence\r\n      if (res && res.last_seq) {\r\n        last_seq = res.last_seq;\r\n      }\r\n\r\n      if (opts.continuous) {\r\n        // Increase retry delay exponentially as long as errors persist\r\n        if (err) {\r\n          fetchRetryCount += 1;\r\n        } else {\r\n          fetchRetryCount = 0;\r\n        }\r\n        var timeoutMultiplier = 1 << fetchRetryCount;\r\n        // i.e. Math.pow(2, fetchRetryCount)\r\n\r\n        var retryWait = fetchTimeout * timeoutMultiplier;\r\n        var maximumWait = opts.maximumWait || 30000;\r\n        if (retryWait > maximumWait) {\r\n          call(opts.complete, err || Pouch.Errors.UNKNOWN_ERROR, null);\r\n        }\r\n\r\n        // Queue a call to fetch again with the newest sequence number\r\n        setTimeout(function () {\r\n          fetch(last_seq, fetched);\r\n        }, retryWait);\r\n      } else {\r\n        // We're done, call the callback\r\n        call(opts.complete, null, res);\r\n      }\r\n    };\r\n\r\n    fetch(opts.since || 0, fetched);\r\n\r\n    // Return a method to cancel this method from processing any more\r\n    return {\r\n      cancel: function() {\r\n        if (Pouch.DEBUG) {\r\n          console.log(db_url + ': Cancel Changes Feed');\r\n        }\r\n        opts.aborted = true;\r\n        xhr.abort();\r\n      }\r\n    };\r\n  };\r\n\r\n  // Given a set of document/revision IDs (given by req), tets the subset of\r\n  // those that do NOT correspond to revisions stored in the database.\r\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\r\n  api.revsDiff = function(req, opts, callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('revsDiff', arguments);\r\n      return;\r\n    }\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Get the missing document/revision IDs\r\n    ajax({\r\n      auth: host.auth,\r\n      method:'POST',\r\n      url: genDBUrl(host, '_revs_diff'),\r\n      body: req\r\n    }, function(err, res) {\r\n      call(callback, err, res);\r\n    });\r\n  };\r\n\r\n  api.close = function(callback) {\r\n    if (!api.taskqueue.ready()) {\r\n      api.taskqueue.addTask('close', arguments);\r\n      return;\r\n    }\r\n    call(callback, null);\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\n// Delete the HttpPouch specified by the given name.\r\nHttpPouch.destroy = function(name, callback) {\r\n  var host = getHost(name);\r\n  ajax({auth: host.auth, method: 'DELETE', url: genDBUrl(host, '')}, callback);\r\n};\r\n\r\n// HttpPouch is a valid adapter.\r\nHttpPouch.valid = function() {\r\n  return true;\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  // running in node\r\n  var pouchdir = '../';\r\n  Pouch = require(pouchdir + 'pouch.js');\r\n  ajax = Pouch.utils.ajax;\r\n}\r\n\r\n// Set HttpPouch to be the adapter used with the http scheme.\r\nPouch.adapter('http', HttpPouch);\r\nPouch.adapter('https', HttpPouch);\r\n\r\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\r\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\r\n\r\n'use strict';\r\n\r\n// While most of the IDB behaviors match between implementations a\r\n// lot of the names still differ. This section tries to normalize the\r\n// different objects & methods.\r\nvar indexedDB = window.indexedDB ||\r\n  window.mozIndexedDB ||\r\n  window.webkitIndexedDB;\r\n\r\n// still needed for R/W transactions in Android Chrome. follow MDN example:\r\n// https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#transaction\r\n// note though that Chrome Canary fails on undefined READ_WRITE constants\r\n// on the native IDBTransaction object\r\nvar IDBTransaction = (window.IDBTransaction && window.IDBTransaction.READ_WRITE) ?\r\n  window.IDBTransaction :\r\n  (window.webkitIDBTransaction && window.webkitIDBTransaction.READ_WRITE) ?\r\n    window.webkitIDBTransaction :\r\n    { READ_WRITE: 'readwrite' };\r\n\r\nvar IDBKeyRange = window.IDBKeyRange ||\r\n  window.webkitIDBKeyRange;\r\n\r\nvar idbError = function(callback) {\r\n  return function(event) {\r\n    call(callback, {\r\n      status: 500,\r\n      error: event.type,\r\n      reason: event.target\r\n    });\r\n  };\r\n};\r\n\r\nvar IdbPouch = function(opts, callback) {\r\n\r\n  // IndexedDB requires a versioned database structure, this is going to make\r\n  // it hard to dynamically create object stores if we needed to for things\r\n  // like views\r\n  var POUCH_VERSION = 1;\r\n\r\n  // The object stores created for each database\r\n  // DOC_STORE stores the document meta data, its revision history and state\r\n  var DOC_STORE = 'document-store';\r\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n  // sequence id\r\n  var BY_SEQ_STORE = 'by-sequence';\r\n  // Where we store attachments\r\n  var ATTACH_STORE = 'attach-store';\r\n  // Where we store meta data\r\n  var META_STORE = 'meta-store';\r\n  // Where we detect blob support\r\n  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\r\n\r\n\r\n  var name = opts.name;\r\n  var req = indexedDB.open(name, POUCH_VERSION);\r\n  var meta = {\r\n    id: 'meta-store',\r\n    updateSeq: 0\r\n  };\r\n\r\n  var blobSupport = null;\r\n\r\n  var instanceId = null;\r\n  var api = {};\r\n  var idb = null;\r\n\r\n  if (Pouch.DEBUG) {\r\n    console.log(name + ': Open Database');\r\n  }\r\n\r\n  req.onupgradeneeded = function(e) {\r\n    var db = e.target.result;\r\n    var currentVersion = e.oldVersion;\r\n    while (currentVersion !== e.newVersion) {\r\n      if (currentVersion === 0) {\r\n        createSchema(db);\r\n      }\r\n      currentVersion++;\r\n    }\r\n  };\r\n\r\n  function createSchema(db) {\r\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\r\n      .createIndex('seq', 'seq', {unique: true});\r\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\r\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\r\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\r\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\r\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\r\n  }\r\n\r\n  // From http://stackoverflow.com/questions/14967647/encode-decode-image-with-base64-breaks-image (2013-04-21)\r\n  function fixBinary(bin) {\r\n    var length = bin.length;\r\n    var buf = new ArrayBuffer(length);\r\n    var arr = new Uint8Array(buf);\r\n    for (var i = 0; i < length; i++) {\r\n      arr[i] = bin.charCodeAt(i);\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  req.onsuccess = function(e) {\r\n\r\n    idb = e.target.result;\r\n\r\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],\r\n                              IDBTransaction.READ_WRITE);\r\n\r\n    idb.onversionchange = function() {\r\n      idb.close();\r\n    };\r\n\r\n    // polyfill the new onupgradeneeded api for chrome. can get rid of when\r\n    // saucelabs moves to chrome 23\r\n    if (idb.setVersion && Number(idb.version) !== POUCH_VERSION) {\r\n      var versionReq = idb.setVersion(POUCH_VERSION);\r\n      versionReq.onsuccess = function(evt) {\r\n        function setVersionComplete() {\r\n          req.onsuccess(e);\r\n        }\r\n        evt.target.result.oncomplete = setVersionComplete;\r\n        req.onupgradeneeded(e);\r\n      };\r\n      return;\r\n    }\r\n\r\n    var req = txn.objectStore(META_STORE).get('meta-store');\r\n\r\n    req.onsuccess = function(e) {\r\n      var reqDBId,\r\n          result;\r\n\r\n      if (e.target.result) {\r\n        meta = e.target.result;\r\n      }\r\n\r\n      if (name + '_id' in meta) {\r\n        instanceId = meta[name + '_id'];\r\n      } else {\r\n        instanceId = Math.uuid();\r\n\r\n        meta[name + '_id'] = instanceId;\r\n        reqDBId = txn.objectStore(META_STORE).put(meta);\r\n      }\r\n\r\n      // detect blob support\r\n      try {\r\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(new Blob(), \"key\");\r\n        blobSupport = true;\r\n      } catch (err) {\r\n        blobSupport = false;\r\n      } finally {\r\n        call(callback, null, api);\r\n      }\r\n    };\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n\r\n  api.type = function() {\r\n    return 'idb';\r\n  };\r\n\r\n  // Each database needs a unique id so that we can store the sequence\r\n  // checkpoint without having other databases confuse itself.\r\n  api.id = function idb_id() {\r\n    return instanceId;\r\n  };\r\n\r\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\r\n    var newEdits = opts.new_edits;\r\n    var userDocs = req.docs;\r\n\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function(doc, i) {\r\n      var newDoc = parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      return newDoc;\r\n    });\r\n\r\n    var docInfoErrors = docInfos.filter(function(docInfo) {\r\n      return docInfo.error;\r\n    });\r\n    if (docInfoErrors.length) {\r\n      return call(callback, docInfoErrors[0]);\r\n    }\r\n\r\n    var results = [];\r\n    var docs = [];\r\n\r\n    // Group multiple edits to the same document\r\n    docInfos.forEach(function(docInfo) {\r\n      if (docInfo.error) {\r\n        return results.push(docInfo);\r\n      }\r\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\r\n        return docs.unshift(docInfo);\r\n      }\r\n      // We mark subsequent bulk docs with a duplicate id as conflicts\r\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n    });\r\n\r\n    function processDocs() {\r\n      if (!docs.length) {\r\n        return;\r\n      }\r\n      var currentDoc = docs.shift();\r\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\r\n      req.onsuccess = function process_docRead(event) {\r\n        var oldDoc = event.target.result;\r\n        if (!oldDoc) {\r\n          insertDoc(currentDoc);\r\n        } else {\r\n          updateDoc(oldDoc, currentDoc);\r\n        }\r\n      };\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function(result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = Pouch.merge.winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (isLocalId(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        IdbPouch.Changes.notify(name);\r\n        IdbPouch.Changes.notifyLocalWindows(name);\r\n      });\r\n      call(callback, null, aresults);\r\n    }\r\n\r\n    function preprocessAttachment(att, finish) {\r\n      if (att.stub) {\r\n        return finish();\r\n      }\r\n      if (typeof att.data === 'string') {\r\n        var data;\r\n        try {\r\n          data = atob(att.data);\r\n        } catch(e) {\r\n          return call(callback, Pouch.error(Pouch.Errors.BAD_ARG, \"Attachments need to be base64 encoded\"));\r\n        }\r\n        att.digest = 'md5-' + Crypto.MD5(data);\r\n        if (blobSupport) {\r\n          var type = att.content_type;\r\n          data = fixBinary(data);\r\n          att.data = new Blob([data], {type: type});\r\n        }\r\n        return finish();\r\n      }\r\n      var reader = new FileReader();\r\n      reader.onloadend = function(e) {\r\n        att.digest = 'md5-' + Crypto.MD5(this.result);\r\n        if (!blobSupport) {\r\n          att.data = btoa(this.result);\r\n        }\r\n        finish();\r\n      };\r\n      reader.readAsBinaryString(att.data);\r\n    }\r\n\r\n    function preprocessAttachments(callback) {\r\n      if (!docInfos.length) {\r\n        return callback();\r\n      }\r\n\r\n      var docv = 0;\r\n      docInfos.forEach(function(docInfo) {\r\n        var attachments = docInfo.data && docInfo.data._attachments ?\r\n          Object.keys(docInfo.data._attachments) : [];\r\n\r\n        if (!attachments.length) {\r\n          return done();\r\n        }\r\n\r\n        var recv = 0;\r\n        function attachmentProcessed() {\r\n          recv++;\r\n          if (recv === attachments.length) {\r\n            done();\r\n          }\r\n        }\r\n\r\n        for (var key in docInfo.data._attachments) {\r\n          preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);\r\n        }\r\n      });\r\n\r\n      function done() {\r\n        docv++;\r\n        if (docInfos.length === docv) {\r\n          callback();\r\n        }\r\n      }\r\n    }\r\n\r\n    function writeDoc(docInfo, callback) {\r\n      var err = null;\r\n      var recv = 0;\r\n\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      meta.updateSeq++;\r\n      var req = txn.objectStore(META_STORE).put(meta);\r\n\r\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            call(callback, err);\r\n          } else if (recv === attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      function attachmentSaved(err) {\r\n        recv++;\r\n        collectResults(err);\r\n      }\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          delete docInfo.data._attachments[key].data;\r\n          var digest = docInfo.data._attachments[key].digest;\r\n          saveAttachment(docInfo, digest, data, attachmentSaved);\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      function finish() {\r\n        docInfo.data._doc_id_rev = docInfo.data._id + \"::\" + docInfo.data._rev;\r\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\r\n        dataReq.onsuccess = function(e) {\r\n          if (Pouch.DEBUG) {\r\n            console.log(name + ': Wrote Document ', docInfo.metadata.id);\r\n          }\r\n          docInfo.metadata.seq = e.target.result;\r\n          // Current _rev is calculated from _rev_tree on read\r\n          delete docInfo.metadata.rev;\r\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\r\n          metaDataReq.onsuccess = function() {\r\n            results.push(docInfo);\r\n            call(callback);\r\n          };\r\n        };\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n      var wasPreviouslyDeleted = isDeleted(oldDoc);\r\n      var inConflict = (wasPreviouslyDeleted && isDeleted(docInfo.metadata)) ||\r\n        (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\r\n        results.push(Pouch.Errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      var objectStore = txn.objectStore(ATTACH_STORE);\r\n      var getReq = objectStore.get(digest).onsuccess = function(e) {\r\n        var originalRefs = e.target.result && e.target.result.refs || {};\r\n        var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n        var newAtt = {\r\n          digest: digest,\r\n          body: data,\r\n          refs: originalRefs\r\n        };\r\n        newAtt.refs[ref] = true;\r\n        var putReq = objectStore.put(newAtt).onsuccess = function(e) {\r\n          call(callback);\r\n        };\r\n      };\r\n    }\r\n\r\n    var txn;\r\n    preprocessAttachments(function() {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],\r\n                            IDBTransaction.READ_WRITE);\r\n      txn.onerror = idbError(callback);\r\n      txn.ontimeout = idbError(callback);\r\n      txn.oncomplete = complete;\r\n\r\n      processDocs();\r\n    });\r\n  };\r\n\r\n  function sortByBulkSeq(a, b) {\r\n    return a._bulk_seq - b._bulk_seq;\r\n  }\r\n\r\n  // First we look up the metadata in the ids database, then we fetch the\r\n  // current revision(s) from the by sequence store\r\n  api._get = function idb_get(id, opts, callback) {\r\n    var doc;\r\n    var metadata;\r\n    var err;\r\n    var txn;\r\n    if (opts.ctx) {\r\n      txn = opts.ctx;\r\n    } else {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\r\n    }\r\n\r\n    function finish(){\r\n      call(callback, err, {doc: doc, metadata: metadata, ctx: txn});\r\n    }\r\n\r\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\r\n      metadata = e.target.result;\r\n      // we can determine the result here if:\r\n      // 1. there is no such document\r\n      // 2. the document is deleted and we don't ask about specific rev\r\n      // When we ask with opts.rev we expect the answer to be either\r\n      // doc (possibly with _deleted=true) or missing error\r\n      if (!metadata) {\r\n        err = Pouch.Errors.MISSING_DOC;\r\n        return finish();\r\n      }\r\n      if (isDeleted(metadata) && !opts.rev) {\r\n        err = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\r\n        return finish();\r\n      }\r\n\r\n      var rev = Pouch.merge.winningRev(metadata);\r\n      var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);\r\n      var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n\r\n      index.get(key).onsuccess = function(e) {\r\n        doc = e.target.result;\r\n        if(doc && doc._doc_id_rev) {\r\n          delete(doc._doc_id_rev);\r\n        }\r\n        if (!doc) {\r\n          err = Pouch.Errors.MISSING_DOC;\r\n          return finish();\r\n        }\r\n        finish();\r\n      };\r\n    };\r\n  };\r\n\r\n  api._getAttachment = function(attachment, opts, callback) {\r\n    var result;\r\n    var txn = opts.ctx;\r\n    var digest = attachment.digest;\r\n    var type = attachment.content_type;\r\n\r\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {\r\n      var data = e.target.result.body;\r\n      if (opts.encode) {\r\n        if (blobSupport) {\r\n          var reader = new FileReader();\r\n          reader.onloadend = function(e) {\r\n            result = btoa(this.result);\r\n            call(callback, null, result);\r\n          };\r\n          reader.readAsBinaryString(data);\r\n        } else {\r\n          result = data;\r\n          call(callback, null, result);\r\n        }\r\n      } else {\r\n        if (blobSupport) {\r\n          result = data;\r\n        } else {\r\n          data = fixBinary(atob(data));\r\n          result = new Blob([data], {type: type});\r\n        }\r\n        call(callback, null, result);\r\n      }\r\n    };\r\n  };\r\n\r\n  api._allDocs = function idb_allDocs(opts, callback) {\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    var keyRange = start && end ? IDBKeyRange.bound(start, end)\r\n      : start ? IDBKeyRange.lowerBound(start)\r\n      : end ? IDBKeyRange.upperBound(end) : null;\r\n\r\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\r\n    transaction.oncomplete = function() {\r\n      if ('keys' in opts) {\r\n        opts.keys.forEach(function(key) {\r\n          if (key in resultsMap) {\r\n            results.push(resultsMap[key]);\r\n          } else {\r\n            results.push({\"key\": key, \"error\": \"not_found\"});\r\n          }\r\n        });\r\n        if (opts.descending) {\r\n          results.reverse();\r\n        }\r\n      }\r\n      call(callback, null, {\r\n        total_rows: results.length,\r\n        rows: ('limit' in opts) ? results.slice(0, opts.limit) : results\r\n      });\r\n    };\r\n\r\n    var oStore = transaction.objectStore(DOC_STORE);\r\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\r\n      : oStore.openCursor(keyRange);\r\n    var results = [];\r\n    var resultsMap = {};\r\n    oCursor.onsuccess = function(e) {\r\n      if (!e.target.result) {\r\n        return;\r\n      }\r\n      var cursor = e.target.result;\r\n      var metadata = cursor.value;\r\n      // If opts.keys is set we want to filter here only those docs with\r\n      // key in opts.keys. With no performance tests it is difficult to\r\n      // guess if iteration with filter is faster than many single requests\r\n      function allDocsInner(metadata, data) {\r\n        if (isLocalId(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n        var doc = {\r\n          id: metadata.id,\r\n          key: metadata.id,\r\n          value: {\r\n            rev: Pouch.merge.winningRev(metadata)\r\n          }\r\n        };\r\n        if (opts.include_docs) {\r\n          doc.doc = data;\r\n          doc.doc._rev = Pouch.merge.winningRev(metadata);\r\n          if (doc.doc._doc_id_rev) {\r\n              delete(doc.doc._doc_id_rev);\r\n          }\r\n          if (opts.conflicts) {\r\n            doc.doc._conflicts = Pouch.merge.collectConflicts(metadata)\r\n              .map(function(x) { return x.id; });\r\n          }\r\n        }\r\n        if ('keys' in opts) {\r\n          if (opts.keys.indexOf(metadata.id) > -1) {\r\n            if (isDeleted(metadata)) {\r\n              doc.value.deleted = true;\r\n              doc.doc = null;\r\n            }\r\n            resultsMap[doc.id] = doc;\r\n          }\r\n        } else {\r\n          if(!isDeleted(metadata)) {\r\n            results.push(doc);\r\n          }\r\n        }\r\n        cursor['continue']();\r\n      }\r\n\r\n      if (!opts.include_docs) {\r\n        allDocsInner(metadata);\r\n      } else {\r\n        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        var mainRev = Pouch.merge.winningRev(metadata);\r\n        var key = metadata.id + \"::\" + mainRev;\r\n        index.get(key).onsuccess = function(event) {\r\n          allDocsInner(cursor.value, event.target.result);\r\n        };\r\n      }\r\n    };\r\n  };\r\n\r\n  // Looping through all the documents in the database is a terrible idea\r\n  // easiest to implement though, should probably keep a counter\r\n  api._info = function idb_info(callback) {\r\n    var count = 0;\r\n    var result;\r\n    var txn = idb.transaction([DOC_STORE], 'readonly');\r\n\r\n    txn.oncomplete = function() {\r\n      callback(null, result);\r\n    };\r\n\r\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = function(e) {\r\n        var cursor = e.target.result;\r\n        if (!cursor) {\r\n          result = {\r\n            db_name: name,\r\n            doc_count: count,\r\n            update_seq: meta.updateSeq\r\n          };\r\n          return;\r\n        }\r\n        if (cursor.value.deleted !== true) {\r\n          count++;\r\n        }\r\n        cursor['continue']();\r\n      };\r\n  };\r\n\r\n  api._changes = function idb_changes(opts) {\r\n    if (Pouch.DEBUG) {\r\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\r\n    }\r\n\r\n    if (!opts.since) {\r\n      opts.since = 0;\r\n    }\r\n\r\n    if (opts.continuous) {\r\n      var id = name + ':' + Math.uuid();\r\n      opts.cancelled = false;\r\n      IdbPouch.Changes.addListener(name, id, api, opts);\r\n      IdbPouch.Changes.notify(name);\r\n      return {\r\n        cancel: function() {\r\n          if (Pouch.DEBUG) {\r\n            console.log(name + ': Cancel Changes Feed');\r\n          }\r\n          opts.cancelled = true;\r\n          IdbPouch.Changes.removeListener(name, id);\r\n        }\r\n      };\r\n    }\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    // Ignore the `since` parameter when `descending` is true\r\n    opts.since = opts.since && !descending ? opts.since : 0;\r\n\r\n    var results = [], resultIndices = {}, dedupResults = [];\r\n    var txn;\r\n\r\n    function fetchChanges() {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\r\n      txn.oncomplete = onTxnComplete;\r\n\r\n      var req;\r\n\r\n      if (opts.limit && descending) {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true), descending);\r\n      } else if (opts.limit && !descending) {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(IDBKeyRange.bound(opts.since, opts.since + opts.limit, true));\r\n      } else if (descending) {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true), descending);\r\n      } else {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(IDBKeyRange.lowerBound(opts.since, true));\r\n      }\r\n\r\n      req.onsuccess = onsuccess;\r\n      req.onerror = onerror;\r\n    }\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      var filterName = opts.filter.split('/');\r\n      api.get('_design/' + filterName[0], function(err, ddoc) {\r\n        /*jshint evil: true */\r\n        var filter = eval('(function() { return ' +\r\n                          ddoc.filters[filterName[1]] + ' })()');\r\n        opts.filter = filter;\r\n        fetchChanges();\r\n      });\r\n    } else {\r\n      fetchChanges();\r\n    }\r\n\r\n    function onsuccess(event) {\r\n      if (!event.target.result) {\r\n        // Filter out null results casued by deduping\r\n        for (var i = 0, l = results.length; i < l; i++ ) {\r\n          var result = results[i];\r\n          if (result) {\r\n            dedupResults.push(result);\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n\r\n      var cursor = event.target.result;\r\n\r\n      // Try to pre-emptively dedup to save us a bunch of idb calls\r\n      var changeId = cursor.value._id;\r\n      var changeIdIndex = resultIndices[changeId];\r\n      if (changeIdIndex !== undefined) {\r\n        results[changeIdIndex].seq = cursor.key;\r\n        // update so it has the later sequence number\r\n        results.push(results[changeIdIndex]);\r\n        results[changeIdIndex] = null;\r\n        resultIndices[changeId] = results.length - 1;\r\n        return cursor['continue']();\r\n      }\r\n\r\n      var index = txn.objectStore(DOC_STORE);\r\n      index.get(cursor.value._id).onsuccess = function(event) {\r\n        var metadata = event.target.result;\r\n        if (isLocalId(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n\r\n        var mainRev = Pouch.merge.winningRev(metadata);\r\n        var key = metadata.id + \"::\" + mainRev;\r\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        index.get(key).onsuccess = function(docevent) {\r\n          var doc = docevent.target.result;\r\n          var changeList = [{rev: mainRev}];\r\n          if (opts.style === 'all_docs') {\r\n            changeList = Pouch.merge.collectLeaves(metadata.rev_tree)\r\n              .map(function(x) { return {rev: x.rev}; });\r\n          }\r\n          var change = {\r\n            id: metadata.id,\r\n            seq: cursor.key,\r\n            changes: changeList,\r\n            doc: doc\r\n          };\r\n\r\n          if (isDeleted(metadata, mainRev)) {\r\n            change.deleted = true;\r\n          }\r\n          if (opts.conflicts) {\r\n            change.doc._conflicts = Pouch.merge.collectConflicts(metadata)\r\n              .map(function(x) { return x.id; });\r\n          }\r\n\r\n          // Dedupe the changes feed\r\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\r\n          if (changeIdIndex !== undefined) {\r\n            results[changeIdIndex] = null;\r\n          }\r\n          results.push(change);\r\n          resultIndices[changeId] = results.length - 1;\r\n          cursor['continue']();\r\n        };\r\n      };\r\n    }\r\n\r\n    function onTxnComplete() {\r\n      dedupResults = dedupResults.filter(filterChange(opts));\r\n      call(opts.complete, null, {results: dedupResults});\r\n    }\r\n\r\n    function onerror(error) {\r\n      // TODO: shouldn't we pass some params here?\r\n      call(opts.complete);\r\n    }\r\n  };\r\n\r\n  api._close = function(callback) {\r\n    if (idb === null) {\r\n      return call(callback, Pouch.Errors.NOT_OPEN);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\r\n    // \"Returns immediately and closes the connection in a separate thread...\"\r\n    idb.close();\r\n    call(callback, null);\r\n  };\r\n\r\n  api._getRevisionTree = function(docId, callback) {\r\n    var txn = idb.transaction([DOC_STORE], 'readonly');\r\n    var req = txn.objectStore(DOC_STORE).get(docId);\r\n    req.onsuccess = function (event) {\r\n      var doc = event.target.result;\r\n      if (!doc) {\r\n        call(callback, Pouch.Errors.MISSING_DOC);\r\n      } else {\r\n        call(callback, null, doc.rev_tree);\r\n      }\r\n    };\r\n  };\r\n\r\n  // This function removes revisions of document docId\r\n  // which are listed in revs and sets this document\r\n  // revision to to rev_tree\r\n  api._doCompaction = function(docId, rev_tree, revs, callback) {\r\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE], IDBTransaction.READ_WRITE);\r\n\r\n    var index = txn.objectStore(DOC_STORE);\r\n    index.get(docId).onsuccess = function(event) {\r\n      var metadata = event.target.result;\r\n      metadata.rev_tree = rev_tree;\r\n\r\n      var count = revs.length;\r\n      revs.forEach(function(rev) {\r\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        var key = docId + \"::\" + rev;\r\n        index.getKey(key).onsuccess = function(e) {\r\n          var seq = e.target.result;\r\n          if (!seq) {\r\n            return;\r\n          }\r\n          var req = txn.objectStore(BY_SEQ_STORE)['delete'](seq);\r\n\r\n          count--;\r\n          if (!count) {\r\n            txn.objectStore(DOC_STORE).put(metadata);\r\n          }\r\n        };\r\n      });\r\n    };\r\n    txn.oncomplete = function() {\r\n      call(callback);\r\n    };\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\nIdbPouch.valid = function idb_valid() {\r\n  return !!indexedDB;\r\n};\r\n\r\nIdbPouch.destroy = function idb_destroy(name, callback) {\r\n  if (Pouch.DEBUG) {\r\n    console.log(name + ': Delete Database');\r\n  }\r\n  IdbPouch.Changes.clearListeners(name);\r\n  var req = indexedDB.deleteDatabase(name);\r\n\r\n  req.onsuccess = function() {\r\n    call(callback, null);\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n};\r\n\r\nIdbPouch.Changes = new Changes();\r\n\r\nPouch.adapter('idb', IdbPouch);\r\n\r\n/*globals call: false, extend: false, parseDoc: false, Crypto: false */\r\n/*globals isLocalId: false, isDeleted: false, Changes: false, filterChange: false */\r\n/*global isCordova*/\r\n\r\n'use strict';\r\n\r\nfunction quote(str) {\r\n  return \"'\" + str + \"'\";\r\n}\r\n\r\nvar POUCH_VERSION = 1;\r\nvar POUCH_SIZE = 5 * 1024 * 1024;\r\n\r\n// The object stores created for each database\r\n// DOC_STORE stores the document meta data, its revision history and state\r\nvar DOC_STORE = quote('document-store');\r\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n// sequence id\r\nvar BY_SEQ_STORE = quote('by-sequence');\r\n// Where we store attachments\r\nvar ATTACH_STORE = quote('attach-store');\r\nvar META_STORE = quote('metadata-store');\r\n\r\nvar unknownError = function(callback) {\r\n  return function(event) {\r\n    call(callback, {\r\n      status: 500,\r\n      error: event.type,\r\n      reason: event.target\r\n    });\r\n  };\r\n};\r\n\r\nvar webSqlPouch = function(opts, callback) {\r\n\r\n  var api = {};\r\n  var update_seq = 0;\r\n  var instanceId = null;\r\n  var name = opts.name;\r\n\r\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  if (!db) {\r\n    return call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n  }\r\n\r\n  function dbCreated() {\r\n    callback(null, api);\r\n  }\r\n\r\n  function setup(){\r\n    db.transaction(function (tx) {\r\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\r\n        ' (update_seq, dbid)';\r\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\r\n        ' (digest, json, body BLOB)';\r\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\r\n        ' (id unique, seq, json, winningseq)';\r\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\r\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json)';\r\n\r\n      tx.executeSql(attach);\r\n      tx.executeSql(doc);\r\n      tx.executeSql(seq);\r\n      tx.executeSql(meta);\r\n\r\n      var updateseq = 'SELECT update_seq FROM ' + META_STORE;\r\n      tx.executeSql(updateseq, [], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\r\n          var newId = Math.uuid();\r\n          tx.executeSql(initSeq, [0]);\r\n          return;\r\n        }\r\n        update_seq = result.rows.item(0).update_seq;\r\n      });\r\n      var dbid = 'SELECT dbid FROM ' + META_STORE;\r\n      tx.executeSql(dbid, [], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          var initDb = 'INSERT INTO ' + META_STORE + ' (dbid) VALUES (?)';\r\n          var newId = Math.uuid();\r\n          tx.executeSql(initDb, [newId]);\r\n          return;\r\n        }\r\n        instanceId = result.rows.item(0).dbid;\r\n      });\r\n    }, unknownError(callback), dbCreated);\r\n  }\r\n  if (isCordova()){\r\n    //to wait until custom api is made in pouch.adapters before doing setup\r\n    window.addEventListener(name + \"_pouch\", setup, false);\r\n  } else {\r\n    setup();\r\n  }\r\n\r\n\r\n  api.type = function() {\r\n    return 'websql';\r\n  };\r\n\r\n  api.id = function() {\r\n    return instanceId;\r\n  };\r\n\r\n  api._info = function(callback) {\r\n    db.transaction(function(tx) {\r\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\r\n      tx.executeSql(sql, [], function(tx, result) {\r\n        callback(null, {\r\n          db_name: name,\r\n          doc_count: result.rows.item(0).count,\r\n          update_seq: update_seq\r\n        });\r\n      });\r\n    });\r\n  };\r\n\r\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\r\n\r\n    var newEdits = opts.new_edits;\r\n    var userDocs = req.docs;\r\n\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function(doc, i) {\r\n      var newDoc = parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      return newDoc;\r\n    });\r\n\r\n    var docInfoErrors = docInfos.filter(function(docInfo) {\r\n      return docInfo.error;\r\n    });\r\n    if (docInfoErrors.length) {\r\n      return call(callback, docInfoErrors[0]);\r\n    }\r\n\r\n    var tx;\r\n    var results = [];\r\n    var docs = [];\r\n    var fetchedDocs = {};\r\n\r\n    // Group multiple edits to the same document\r\n    docInfos.forEach(function(docInfo) {\r\n      if (docInfo.error) {\r\n        return results.push(docInfo);\r\n      }\r\n      if (!docs.length || !newEdits || docInfo.metadata.id !== docs[0].metadata.id) {\r\n        return docs.unshift(docInfo);\r\n      }\r\n      // We mark subsequent bulk docs with a duplicate id as conflicts\r\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n    });\r\n\r\n    function sortByBulkSeq(a, b) {\r\n      return a._bulk_seq - b._bulk_seq;\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function(result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = Pouch.merge.winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (isLocalId(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        update_seq++;\r\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\r\n        tx.executeSql(sql, [update_seq], function() {\r\n          webSqlPouch.Changes.notify(name);\r\n          webSqlPouch.Changes.notifyLocalWindows(name);\r\n        });\r\n      });\r\n      call(callback, null, aresults);\r\n    }\r\n\r\n    function preprocessAttachment(att, finish) {\r\n      if (att.stub) {\r\n        return finish();\r\n      }\r\n      if (typeof att.data === 'string') {\r\n        try {\r\n          att.data = atob(att.data);\r\n        } catch(e) {\r\n          return call(callback, Pouch.error(Pouch.Errors.BAD_ARG, \"Attachments need to be base64 encoded\"));\r\n        }\r\n        att.digest = 'md5-' + Crypto.MD5(att.data);\r\n        return finish();\r\n      }\r\n      var reader = new FileReader();\r\n      reader.onloadend = function(e) {\r\n        att.data = this.result;\r\n        att.digest = 'md5-' + Crypto.MD5(this.result);\r\n        finish();\r\n      };\r\n      reader.readAsBinaryString(att.data);\r\n    }\r\n\r\n    function preprocessAttachments(callback) {\r\n      if (!docInfos.length) {\r\n        return callback();\r\n      }\r\n\r\n      var docv = 0;\r\n      var recv = 0;\r\n\r\n      docInfos.forEach(function(docInfo) {\r\n        var attachments = docInfo.data && docInfo.data._attachments ?\r\n          Object.keys(docInfo.data._attachments) : [];\r\n\r\n        if (!attachments.length) {\r\n          return done();\r\n        }\r\n\r\n        function processedAttachment() {\r\n          recv++;\r\n          if (recv === attachments.length) {\r\n            done();\r\n          }\r\n        }\r\n\r\n        for (var key in docInfo.data._attachments) {\r\n          preprocessAttachment(docInfo.data._attachments[key], processedAttachment);\r\n        }\r\n      });\r\n\r\n      function done() {\r\n        docv++;\r\n        if (docInfos.length === docv) {\r\n          callback();\r\n        }\r\n      }\r\n    }\r\n\r\n    function writeDoc(docInfo, callback, isUpdate) {\r\n\r\n      function finish() {\r\n        var data = docInfo.data;\r\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (doc_id_rev, json) VALUES (?, ?);';\r\n        tx.executeSql(sql, [data._id + \"::\" + data._rev,\r\n                            JSON.stringify(data)], dataWritten);\r\n      }\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            call(callback, err);\r\n          } else if (recv === attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      var err = null;\r\n      var recv = 0;\r\n\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      function attachmentSaved(err) {\r\n        recv++;\r\n        collectResults(err);\r\n      }\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          delete docInfo.data._attachments[key].data;\r\n          var digest = docInfo.data._attachments[key].digest;\r\n          saveAttachment(docInfo, digest, data, attachmentSaved);\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n\r\n      function dataWritten(tx, result) {\r\n        var seq = docInfo.metadata.seq = result.insertId;\r\n        delete docInfo.metadata.rev;\r\n\r\n        var mainRev = Pouch.merge.winningRev(docInfo.metadata);\r\n\r\n        var sql = isUpdate ?\r\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +\r\n          BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :\r\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json) VALUES (?, ?, ?, ?);';\r\n        var metadataStr = JSON.stringify(docInfo.metadata);\r\n        var key = docInfo.metadata.id + \"::\" + mainRev;\r\n        var params = isUpdate ?\r\n          [seq, metadataStr, key, docInfo.metadata.id] :\r\n          [docInfo.metadata.id, seq, seq, metadataStr];\r\n        tx.executeSql(sql, params, function(tx, result) {\r\n          results.push(docInfo);\r\n          call(callback, null);\r\n        });\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\r\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs, true);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\r\n        results.push(Pouch.Errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs, false);\r\n    }\r\n\r\n    function processDocs() {\r\n      if (!docs.length) {\r\n        return complete();\r\n      }\r\n      var currentDoc = docs.shift();\r\n      var id = currentDoc.metadata.id;\r\n      if (id in fetchedDocs) {\r\n        updateDoc(fetchedDocs[id], currentDoc);\r\n      } else {\r\n        // if we have newEdits=false then we can update the same\r\n        // document twice in a single bulk docs call\r\n        fetchedDocs[id] = currentDoc.metadata;\r\n        insertDoc(currentDoc);\r\n      }\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n      var newAtt = {digest: digest};\r\n      var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n      tx.executeSql(sql, [digest], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          newAtt.refs = {};\r\n          newAtt.refs[ref] = true;\r\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';\r\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function() {\r\n            call(callback, null);\r\n          });\r\n        } else {\r\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\r\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';\r\n          tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function() {\r\n            call(callback, null);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    function metadataFetched(tx, results) {\r\n      for (var j=0; j<results.rows.length; j++) {\r\n        var row = results.rows.item(j);\r\n        fetchedDocs[row.id] = JSON.parse(row.json);\r\n      }\r\n      processDocs();\r\n    }\r\n\r\n    preprocessAttachments(function() {\r\n      db.transaction(function(txn) {\r\n        tx = txn;\r\n        var ids = '(' + docs.map(function(d) {\r\n          return quote(d.metadata.id);\r\n        }).join(',') + ')';\r\n        var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\r\n        tx.executeSql(sql, [], metadataFetched);\r\n      }, unknownError(callback));\r\n    });\r\n  };\r\n\r\n  api._get = function(id, opts, callback) {\r\n    var doc;\r\n    var metadata;\r\n    var err;\r\n    if (!opts.ctx) {\r\n      db.transaction(function(txn) {\r\n        opts.ctx = txn;\r\n        api._get(id, opts, callback);\r\n      });\r\n      return;\r\n    }\r\n    var tx = opts.ctx;\r\n\r\n    function finish() {\r\n      call(callback, err, {doc: doc, metadata: metadata, ctx: tx});\r\n    }\r\n\r\n    var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\r\n    tx.executeSql(sql, [id.docId], function(a, results) {\r\n      if (!results.rows.length) {\r\n        err = Pouch.Errors.MISSING_DOC;\r\n        return finish();\r\n      }\r\n      metadata = JSON.parse(results.rows.item(0).json);\r\n      if (isDeleted(metadata) && !opts.rev) {\r\n        err = Pouch.error(Pouch.Errors.MISSING_DOC, \"deleted\");\r\n        return finish();\r\n      }\r\n\r\n      var rev = Pouch.merge.winningRev(metadata);\r\n      var key = opts.rev ? opts.rev : rev;\r\n      key = metadata.id + '::' + key;\r\n      var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';\r\n      tx.executeSql(sql, [key], function(tx, results) {\r\n        if (!results.rows.length) {\r\n          err = Pouch.Errors.MISSING_DOC;\r\n          return finish();\r\n        }\r\n        doc = JSON.parse(results.rows.item(0).json);\r\n\r\n        finish();\r\n      });\r\n    });\r\n  };\r\n\r\n  function makeRevs(arr) {\r\n    return arr.map(function(x) { return {rev: x.rev}; });\r\n  }\r\n  function makeIds(arr) {\r\n    return arr.map(function(x) { return x.id; });\r\n  }\r\n\r\n  api._allDocs = function(opts, callback) {\r\n    var results = [];\r\n    var resultsMap = {};\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n      DOC_STORE + '.winningseq';\r\n\r\n    if ('keys' in opts) {\r\n      sql += ' WHERE ' + DOC_STORE + '.id IN (' + opts.keys.map(function(key){\r\n        return quote(key);\r\n      }).join(',') + ')';\r\n    } else {\r\n      if (start) {\r\n        sql += ' WHERE ' + DOC_STORE + '.id >= \"' + start + '\"';\r\n      }\r\n      if (end) {\r\n        sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= \"' + end + '\"';\r\n      }\r\n      sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\r\n    }\r\n\r\n    db.transaction(function(tx) {\r\n      tx.executeSql(sql, [], function(tx, result) {\r\n        for (var i = 0, l = result.rows.length; i < l; i++ ) {\r\n          var doc = result.rows.item(i);\r\n          var metadata = JSON.parse(doc.metadata);\r\n          var data = JSON.parse(doc.data);\r\n          if (!(isLocalId(metadata.id))) {\r\n            doc = {\r\n              id: metadata.id,\r\n              key: metadata.id,\r\n              value: {rev: Pouch.merge.winningRev(metadata)}\r\n            };\r\n            if (opts.include_docs) {\r\n              doc.doc = data;\r\n              doc.doc._rev = Pouch.merge.winningRev(metadata);\r\n              if (opts.conflicts) {\r\n                doc.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\r\n              }\r\n            }\r\n            if ('keys' in opts) {\r\n              if (opts.keys.indexOf(metadata.id) > -1) {\r\n                if (isDeleted(metadata)) {\r\n                  doc.value.deleted = true;\r\n                  doc.doc = null;\r\n                }\r\n                resultsMap[doc.id] = doc;\r\n              }\r\n            } else {\r\n              if(!isDeleted(metadata)) {\r\n                results.push(doc);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }, unknownError(callback), function() {\r\n      if ('keys' in opts) {\r\n        opts.keys.forEach(function(key) {\r\n          if (key in resultsMap) {\r\n            results.push(resultsMap[key]);\r\n          } else {\r\n            results.push({\"key\": key, \"error\": \"not_found\"});\r\n          }\r\n        });\r\n        if (opts.descending) {\r\n          results.reverse();\r\n        }\r\n      }\r\n      call(callback, null, {\r\n        total_rows: results.length,\r\n        rows: ('limit' in opts) ? results.slice(0, opts.limit) : results\r\n      });\r\n    });\r\n  };\r\n\r\n  api._changes = function idb_changes(opts) {\r\n\r\n    if (Pouch.DEBUG) {\r\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\r\n    }\r\n\r\n    if (!opts.since) {\r\n      opts.since = 0;\r\n    }\r\n\r\n    if (opts.continuous) {\r\n      var id = name + ':' + Math.uuid();\r\n      opts.cancelled = false;\r\n      webSqlPouch.Changes.addListener(name, id, api, opts);\r\n      webSqlPouch.Changes.notify(name);\r\n      return {\r\n        cancel: function() {\r\n          if (Pouch.DEBUG) {\r\n            console.log(name + ': Cancel Changes Feed');\r\n          }\r\n          opts.cancelled = true;\r\n          webSqlPouch.Changes.removeListener(name, id);\r\n        }\r\n      };\r\n    }\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    // Ignore the `since` parameter when `descending` is true\r\n    opts.since = opts.since && !descending ? opts.since : 0;\r\n\r\n    var results = [], resultIndices = {}, dedupResults = [];\r\n    var txn;\r\n\r\n    function fetchChanges() {\r\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +\r\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\r\n\r\n      if (opts.limit) {\r\n        sql += ' LIMIT ' + opts.limit;\r\n      }\r\n\r\n      db.transaction(function(tx) {\r\n        tx.executeSql(sql, [], function(tx, result) {\r\n          for (var i = 0, l = result.rows.length; i < l; i++ ) {\r\n            var doc = result.rows.item(i);\r\n            var metadata = JSON.parse(doc.metadata);\r\n            if (!isLocalId(metadata.id)) {\r\n              var change = {\r\n                id: metadata.id,\r\n                seq: doc.seq,\r\n                changes: makeRevs(Pouch.merge.collectLeaves(metadata.rev_tree)),\r\n                doc: JSON.parse(doc.data)\r\n              };\r\n              change.doc._rev = Pouch.merge.winningRev(metadata);\r\n              if (isDeleted(metadata, change.doc._rev)) {\r\n                change.deleted = true;\r\n              }\r\n              if (opts.conflicts) {\r\n                change.doc._conflicts = makeIds(Pouch.merge.collectConflicts(metadata));\r\n              }\r\n              results.push(change);\r\n            }\r\n          }\r\n          for (i = 0, l = results.length; i < l; i++ ) {\r\n            result = results[i];\r\n            if (result) {\r\n              dedupResults.push(result);\r\n            }\r\n          }\r\n          dedupResults = dedupResults.filter(filterChange(opts));\r\n          call(opts.complete, null, {results: dedupResults});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      var filterName = opts.filter.split('/');\r\n      api.get('_design/' + filterName[0], function(err, ddoc) {\r\n        /*jshint evil: true */\r\n        var filter = eval('(function() { return ' +\r\n                          ddoc.filters[filterName[1]] + ' })()');\r\n        opts.filter = filter;\r\n        fetchChanges();\r\n      });\r\n    } else {\r\n      fetchChanges();\r\n    }\r\n  };\r\n\r\n  api._getAttachment = function(attachment, opts, callback) {\r\n    var res;\r\n    var tx = opts.ctx;\r\n    var digest = attachment.digest;\r\n    var type = attachment.content_type;\r\n    var sql = 'SELECT body FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n    tx.executeSql(sql, [digest], function(tx, result) {\r\n      var data = result.rows.item(0).body;\r\n      if (opts.encode) {\r\n        res = btoa(data);\r\n      } else {\r\n        res = new Blob([data], {type: type});\r\n      }\r\n      call(callback, null, res);\r\n    });\r\n  };\r\n\r\n  api._getRevisionTree = function(docId, callback) {\r\n    db.transaction(function (tx) {\r\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\r\n      tx.executeSql(sql, [docId], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          call(callback, Pouch.Errors.MISSING_DOC);\r\n        } else {\r\n          var data = JSON.parse(result.rows.item(0).metadata);\r\n          call(callback, null, data.rev_tree);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  api._doCompaction = function(docId, rev_tree, revs, callback) {\r\n    db.transaction(function (tx) {\r\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\r\n      tx.executeSql(sql, [docId], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          return call(callback);\r\n        }\r\n        var metadata = JSON.parse(result.rows.item(0).metadata);\r\n        metadata.rev_tree = rev_tree;\r\n\r\n        var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +\r\n          revs.map(function(rev){return quote(docId + '::' + rev);}).join(',') + ')';\r\n\r\n        tx.executeSql(sql, [], function(tx, result) {\r\n          var sql = 'UPDATE ' + DOC_STORE + ' SET json = ? WHERE id = ?';\r\n\r\n          tx.executeSql(sql, [JSON.stringify(metadata), docId], function(tx, result) {\r\n            callback();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\nwebSqlPouch.valid = function() {\r\n  return !!window.openDatabase;\r\n};\r\n\r\nwebSqlPouch.destroy = function(name, callback) {\r\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  db.transaction(function (tx) {\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\r\n  }, unknownError(callback), function() {\r\n    call(callback, null);\r\n  });\r\n};\r\n\r\nwebSqlPouch.Changes = new Changes();\r\n\r\nPouch.adapter('websql', webSqlPouch);\r\n\r\n/*global Pouch: true */\r\n\r\n\"use strict\";\r\n\r\n// This is the first implementation of a basic plugin, we register the\r\n// plugin object with pouch and it is mixin'd to each database created\r\n// (regardless of adapter), adapters can override plugins by providing\r\n// their own implementation. functions on the plugin object that start\r\n// with _ are reserved function that are called by pouchdb for special\r\n// notifications.\r\n\r\n// If we wanted to store incremental views we can do it here by listening\r\n// to the changes feed (keeping track of our last update_seq between page loads)\r\n// and storing the result of the map function (possibly using the upcoming\r\n// extracted adapter functions)\r\n\r\nvar MapReduce = function(db) {\r\n\r\n  function viewQuery(fun, options) {\r\n    if (!options.complete) {\r\n      return;\r\n    }\r\n\r\n    if (!fun.reduce) {\r\n      options.reduce = false;\r\n    }\r\n\r\n    function sum(values) {\r\n      return values.reduce(function(a, b) { return a + b; }, 0);\r\n    }\r\n\r\n    var results = [];\r\n    var current = null;\r\n    var num_started= 0;\r\n    var completed= false;\r\n\r\n    var emit = function(key, val) {\r\n      var viewRow = {\r\n        id: current.doc._id,\r\n        key: key,\r\n        value: val\r\n      };\r\n\r\n      if (options.startkey && Pouch.collate(key, options.startkey) < 0) return;\r\n      if (options.endkey && Pouch.collate(key, options.endkey) > 0) return;\r\n      if (options.key && Pouch.collate(key, options.key) !== 0) return;\r\n\r\n      num_started++;\r\n      if (options.include_docs) {\r\n        //in this special case, join on _id (issue #106)\r\n        if (val && typeof val === 'object' && val._id){\r\n          db.get(val._id,\r\n              function(_, joined_doc){\r\n                if (joined_doc) {\r\n                  viewRow.doc = joined_doc;\r\n                }\r\n                results.push(viewRow);\r\n                checkComplete();\r\n              });\r\n          return;\r\n        } else {\r\n          viewRow.doc = current.doc;\r\n        }\r\n      }\r\n      results.push(viewRow);\r\n    };\r\n\r\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\r\n    // above emit\r\n    eval('fun.map = ' + fun.map.toString() + ';');\r\n    if (fun.reduce) {\r\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\r\n    }\r\n\r\n    //only proceed once all documents are mapped and joined\r\n    var checkComplete= function(){\r\n      if (completed && results.length == num_started){\r\n        results.sort(function(a, b) {\r\n          return Pouch.collate(a.key, b.key);\r\n        });\r\n        if (options.descending) {\r\n          results.reverse();\r\n        }\r\n        if (options.reduce === false) {\r\n          return options.complete(null, {\r\n            rows: ('limit' in options)\r\n              ? results.slice(0, options.limit)\r\n              : results,\r\n            total_rows: results.length\r\n          });\r\n        }\r\n\r\n        var groups = [];\r\n        results.forEach(function(e) {\r\n          var last = groups[groups.length-1] || null;\r\n          if (last && Pouch.collate(last.key[0][0], e.key) === 0) {\r\n            last.key.push([e.key, e.id]);\r\n            last.value.push(e.value);\r\n            return;\r\n          }\r\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\r\n        });\r\n        groups.forEach(function(e) {\r\n          e.value = fun.reduce(e.key, e.value) || null;\r\n          e.key = e.key[0][0];\r\n        });\r\n        options.complete(null, {\r\n          rows: ('limit' in options)\r\n            ? groups.slice(0, options.limit)\r\n            : groups,\r\n          total_rows: groups.length\r\n        });\r\n      }\r\n    }\r\n\r\n    db.changes({\r\n      conflicts: true,\r\n      include_docs: true,\r\n      onChange: function(doc) {\r\n        if (!('deleted' in doc)) {\r\n          current = {doc: doc.doc};\r\n          fun.map.call(this, doc.doc);\r\n        }\r\n      },\r\n      complete: function() {\r\n        completed= true;\r\n        checkComplete();\r\n      }\r\n    });\r\n  }\r\n\r\n  function httpQuery(fun, opts, callback) {\r\n\r\n    // List of parameters to add to the PUT request\r\n    var params = [];\r\n    var body = undefined;\r\n    var method = 'GET';\r\n\r\n    // If opts.reduce exists and is defined, then add it to the list\r\n    // of parameters.\r\n    // If reduce=false then the results are that of only the map function\r\n    // not the final result of map and reduce.\r\n    if (typeof opts.reduce !== 'undefined') {\r\n      params.push('reduce=' + opts.reduce);\r\n    }\r\n    if (typeof opts.include_docs !== 'undefined') {\r\n      params.push('include_docs=' + opts.include_docs);\r\n    }\r\n    if (typeof opts.limit !== 'undefined') {\r\n      params.push('limit=' + opts.limit);\r\n    }\r\n    if (typeof opts.descending !== 'undefined') {\r\n      params.push('descending=' + opts.descending);\r\n    }\r\n    if (typeof opts.startkey !== 'undefined') {\r\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\r\n    }\r\n    if (typeof opts.endkey !== 'undefined') {\r\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\r\n    }\r\n    if (typeof opts.key !== 'undefined') {\r\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\r\n    }\r\n\r\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\r\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\r\n    if (typeof opts.keys !== 'undefined') {\r\n      method = 'POST';\r\n      body = JSON.stringify({keys:opts.keys});\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    params = params === '' ? '' : '?' + params;\r\n\r\n    // We are referencing a query defined in the design doc\r\n    if (typeof fun === 'string') {\r\n      var parts = fun.split('/');\r\n      db.request({\r\n        method: method,\r\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\r\n        body: body\r\n      }, callback);\r\n      return;\r\n    }\r\n\r\n    // We are using a temporary view, terrible for performance but good for testing\r\n    var queryObject = JSON.parse(JSON.stringify(fun, function(key, val) {\r\n      if (typeof val === 'function') {\r\n        return val + ''; // implicitly `toString` it\r\n      }\r\n      return val;\r\n    }));\r\n\r\n    db.request({\r\n      method:'POST',\r\n      url: '_temp_view' + params,\r\n      body: queryObject\r\n    }, callback);\r\n  }\r\n\r\n  function query(fun, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (callback) {\r\n      opts.complete = callback;\r\n    }\r\n\r\n    if (db.type() === 'http') {\r\n\t  if (typeof fun === 'function'){\r\n\t    return httpQuery({map: fun}, opts, callback);\r\n\t  }\r\n\t  return httpQuery(fun, opts, callback);\r\n    }\r\n\r\n    if (typeof fun === 'object') {\r\n      return viewQuery(fun, opts);\r\n    }\r\n\r\n    if (typeof fun === 'function') {\r\n      return viewQuery({map: fun}, opts);\r\n    }\r\n\r\n    var parts = fun.split('/');\r\n    db.get('_design/' + parts[0], function(err, doc) {\r\n      if (err) {\r\n        if (callback) callback(err);\r\n        return;\r\n      }\r\n      viewQuery({\r\n        map: doc.views[parts[1]].map,\r\n        reduce: doc.views[parts[1]].reduce\r\n      }, opts);\r\n    });\r\n  }\r\n\r\n  return {'query': query};\r\n};\r\n\r\n// Deletion is a noop since we dont store the results of the view\r\nMapReduce._delete = function() { };\r\n\r\nPouch.plugin('mapreduce', MapReduce);\r\n\r"],[0,"\n })"]],"start1":7,"start2":7,"length1":151425,"length2":158952}]],"length":158966,"saved":false}
